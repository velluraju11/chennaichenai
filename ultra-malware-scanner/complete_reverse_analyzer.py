#!/usr/bin/env python3
"""
Complete Reverse Engineering Analyzer
Comprehensive tool for reverse engineering analysis with automated reporting
"""

import os
import sys
import json
import shutil
import argparse
import subprocess
import datetime
from pathlib import Path
import hashlib
# import magic  # Optional dependency
import requests
import time

class CompleteReverseAnalyzer:
    def __init__(self, gemini_api_key=None):
        self.gemini_api_key = gemini_api_key
        self.test_folder = "test_analysis"
        self.reports_folder = "reports"
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.results = {
            "metadata": {},
            "file_info": {},
            "analysis_results": {},
            "security_findings": [],
            "recommendations": [],
            "timestamp": self.timestamp
        }
        
    def setup_environment(self):
        """Setup test and reports directories"""
        os.makedirs(self.test_folder, exist_ok=True)
        os.makedirs(self.reports_folder, exist_ok=True)
        print(f"[+] Created directories: {self.test_folder}, {self.reports_folder}")
        
    def copy_target_file(self, source_path):
        """Copy target file to test folder"""
        if not os.path.exists(source_path):
            raise FileNotFoundError(f"Target file not found: {source_path}")
            
        filename = os.path.basename(source_path)
        target_path = os.path.join(self.test_folder, filename)
        shutil.copy2(source_path, target_path)
        
        print(f"[+] Copied {source_path} to {target_path}")
        return target_path, filename
        
    def get_file_info(self, file_path):
        """Extract basic file information"""
        try:
            stat = os.stat(file_path)
            with open(file_path, 'rb') as f:
                content = f.read()
                
            file_info = {
                "filename": os.path.basename(file_path),
                "size": stat.st_size,
                "md5": hashlib.md5(content).hexdigest(),
                "sha256": hashlib.sha256(content).hexdigest(),
                "created": datetime.datetime.fromtimestamp(stat.st_ctime).isoformat(),
                "modified": datetime.datetime.fromtimestamp(stat.st_mtime).isoformat(),
            }
            
            # Try to get file type using file command
            try:
                result = subprocess.run(['file', '-b', '--mime-type', file_path], 
                                      capture_output=True, text=True, timeout=30)
                file_info["mime_type"] = result.stdout.strip() if result.returncode == 0 else "unknown"
                
                result = subprocess.run(['file', '-b', file_path], 
                                      capture_output=True, text=True, timeout=30)
                file_info["file_type"] = result.stdout.strip() if result.returncode == 0 else "unknown"
            except:
                file_info["mime_type"] = "text/plain"
                file_info["file_type"] = "text file"
                
            return file_info
        except Exception as e:
            return {"error": str(e)}
            
    def run_strings_analysis(self, file_path):
        """Run strings analysis"""
        try:
            print("[+] Running strings analysis...")
            result = subprocess.run(['strings', file_path], 
                                  capture_output=True, text=True, timeout=60)
            
            strings_output = result.stdout.split('\n')
            interesting_strings = []
            
            # Filter for interesting strings
            keywords = ['password', 'key', 'secret', 'token', 'api', 'url', 'http', 
                       'ftp', 'sql', 'admin', 'root', 'config', 'debug']
            
            for string in strings_output:
                if len(string) > 4:
                    for keyword in keywords:
                        if keyword.lower() in string.lower():
                            interesting_strings.append(string)
                            break
                            
            return {
                "total_strings": len(strings_output),
                "interesting_strings": interesting_strings[:50],  # Limit output
                "status": "success"
            }
        except Exception as e:
            return {"error": str(e), "status": "failed"}
            
    def run_hexdump_analysis(self, file_path):
        """Run hexdump analysis"""
        try:
            print("[+] Running hexdump analysis...")
            result = subprocess.run(['hexdump', '-C', file_path], 
                                  capture_output=True, text=True, timeout=60)
            
            hex_lines = result.stdout.split('\n')[:100]  # First 100 lines
            
            return {
                "hex_preview": hex_lines,
                "total_lines": len(result.stdout.split('\n')),
                "status": "success"
            }
        except Exception as e:
            return {"error": str(e), "status": "failed"}
            
    def run_file_analysis(self, file_path):
        """Run file command analysis"""
        try:
            print("[+] Running file analysis...")
            result = subprocess.run(['file', '-b', file_path], 
                                  capture_output=True, text=True, timeout=30)
            
            return {
                "file_type": result.stdout.strip(),
                "status": "success"
            }
        except Exception as e:
            return {"error": str(e), "status": "failed"}
            
    def run_binwalk_analysis(self, file_path):
        """Run binwalk analysis"""
        try:
            print("[+] Running binwalk analysis...")
            result = subprocess.run(['binwalk', file_path], 
                                  capture_output=True, text=True, timeout=120)
            
            return {
                "binwalk_output": result.stdout,
                "status": "success"
            }
        except Exception as e:
            return {"error": str(e), "status": "failed"}
            
    def run_objdump_analysis(self, file_path):
        """Run objdump analysis"""
        try:
            print("[+] Running objdump analysis...")
            
            # Try different objdump options
            analyses = {}
            
            # Headers
            try:
                result = subprocess.run(['objdump', '-h', file_path], 
                                      capture_output=True, text=True, timeout=60)
                analyses["headers"] = result.stdout
            except:
                analyses["headers"] = "Not available"
                
            # Symbols
            try:
                result = subprocess.run(['objdump', '-t', file_path], 
                                      capture_output=True, text=True, timeout=60)
                analyses["symbols"] = result.stdout
            except:
                analyses["symbols"] = "Not available"
                
            return {
                "objdump_analysis": analyses,
                "status": "success"
            }
        except Exception as e:
            return {"error": str(e), "status": "failed"}
            
    def run_readelf_analysis(self, file_path):
        """Run readelf analysis"""
        try:
            print("[+] Running readelf analysis...")
            
            analyses = {}
            
            # ELF header
            try:
                result = subprocess.run(['readelf', '-h', file_path], 
                                      capture_output=True, text=True, timeout=60)
                analyses["elf_header"] = result.stdout
            except:
                analyses["elf_header"] = "Not available"
                
            # Sections
            try:
                result = subprocess.run(['readelf', '-S', file_path], 
                                      capture_output=True, text=True, timeout=60)
                analyses["sections"] = result.stdout
            except:
                analyses["sections"] = "Not available"
                
            return {
                "readelf_analysis": analyses,
                "status": "success"
            }
        except Exception as e:
            return {"error": str(e), "status": "failed"}
            
    def analyze_security_risks(self, analysis_results):
        """Analyze security risks from all results"""
        risks = []
        
        # Check strings for sensitive data
        if "strings" in analysis_results and "interesting_strings" in analysis_results["strings"]:
            for string in analysis_results["strings"]["interesting_strings"]:
                if any(keyword in string.lower() for keyword in ['password', 'secret', 'key']):
                    risks.append({
                        "type": "Sensitive Data Exposure",
                        "severity": "HIGH",
                        "description": f"Potential sensitive string found: {string[:50]}...",
                        "recommendation": "Remove or encrypt sensitive strings"
                    })
                    
        # Check file type for potential risks
        if "file_info" in self.results and "file_type" in self.results["file_info"]:
            file_type = self.results["file_info"]["file_type"].lower()
            if "executable" in file_type:
                risks.append({
                    "type": "Executable File",
                    "severity": "MEDIUM",
                    "description": "File is executable and may contain malicious code",
                    "recommendation": "Analyze in isolated environment before execution"
                })
                
        return risks
        
    def generate_recommendations(self, analysis_results, security_risks):
        """Generate security recommendations"""
        recommendations = []
        
        # General recommendations
        recommendations.extend([
            {
                "category": "Analysis",
                "recommendation": "Always analyze unknown files in isolated environments",
                "priority": "HIGH"
            },
            {
                "category": "Security",
                "recommendation": "Scan files with multiple antivirus engines before analysis",
                "priority": "HIGH"
            },
            {
                "category": "Documentation",
                "recommendation": "Document all findings and maintain analysis logs",
                "priority": "MEDIUM"
            }
        ])
        
        # Risk-specific recommendations
        for risk in security_risks:
            if risk["severity"] == "HIGH":
                recommendations.append({
                    "category": "Security",
                    "recommendation": f"Address {risk['type']}: {risk['recommendation']}",
                    "priority": "HIGH"
                })
                
        return recommendations
        
    def call_gemini_api(self, json_data):
        """Call Gemini API to generate HTML report"""
        if not self.gemini_api_key:
            print("[-] No Gemini API key provided, skipping HTML generation")
            return None
            
        try:
            print("[+] Generating HTML report with Gemini API...")
            
            prompt = f"""
            Convert the following reverse engineering analysis JSON data into a comprehensive HTML report.
            
            Requirements:
            1. Create a professional, well-structured HTML document
            2. Include CSS styling for better readability
            3. Add sections for:
               - Executive Summary
               - File Information
               - Analysis Results
               - Security Findings
               - Impact Analysis
               - Recreation Steps
               - Recommendations
               - Mitigation Strategies
            4. Use tables, charts, and visual elements where appropriate
            5. Include severity color coding for security findings
            6. Add a table of contents
            7. Make it suitable for security reporting
            
            JSON Data:
            {json.dumps(json_data, indent=2)}
            
            Generate only the HTML content, no explanations.
            """
            
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={self.gemini_api_key}"
            
            headers = {
                "Content-Type": "application/json"
            }
            
            data = {
                "contents": [{
                    "parts": [{
                        "text": prompt
                    }]
                }]
            }
            
            response = requests.post(url, headers=headers, json=data, timeout=60)
            
            if response.status_code == 200:
                result = response.json()
                if "candidates" in result and len(result["candidates"]) > 0:
                    html_content = result["candidates"][0]["content"]["parts"][0]["text"]
                    return html_content
                else:
                    print("[-] No content generated by Gemini API")
                    return None
            else:
                print(f"[-] Gemini API error: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"[-] Error calling Gemini API: {str(e)}")
            return None
            
    def run_complete_analysis(self, file_path):
        """Run complete reverse engineering analysis"""
        try:
            print(f"[+] Starting complete analysis of: {file_path}")
            
            # Setup environment
            self.setup_environment()
            
            # Copy target file
            target_path, filename = self.copy_target_file(file_path)
            
            # Get file information
            print("[+] Extracting file information...")
            self.results["file_info"] = self.get_file_info(target_path)
            self.results["metadata"]["target_file"] = file_path
            self.results["metadata"]["analysis_file"] = target_path
            
            # Run all analysis tools
            analysis_tools = {
                "strings": self.run_strings_analysis,
                "hexdump": self.run_hexdump_analysis,
                "file": self.run_file_analysis,
                "binwalk": self.run_binwalk_analysis,
                "objdump": self.run_objdump_analysis,
                "readelf": self.run_readelf_analysis
            }
            
            for tool_name, tool_func in analysis_tools.items():
                print(f"[+] Running {tool_name} analysis...")
                try:
                    self.results["analysis_results"][tool_name] = tool_func(target_path)
                    time.sleep(1)  # Brief pause between tools
                except Exception as e:
                    print(f"[-] Error running {tool_name}: {str(e)}")
                    self.results["analysis_results"][tool_name] = {"error": str(e), "status": "failed"}
                    
            # Analyze security risks
            print("[+] Analyzing security risks...")
            self.results["security_findings"] = self.analyze_security_risks(self.results["analysis_results"])
            
            # Generate recommendations
            print("[+] Generating recommendations...")
            self.results["recommendations"] = self.generate_recommendations(
                self.results["analysis_results"], 
                self.results["security_findings"]
            )
            
            # Save JSON report
            json_filename = f"complete_analysis_{filename}_{self.timestamp}.json"
            json_path = os.path.join(self.reports_folder, json_filename)
            
            with open(json_path, 'w') as f:
                json.dump(self.results, f, indent=2, default=str)
                
            print(f"[+] JSON report saved: {json_path}")
            
            # Generate HTML report if API key provided
            html_path = None
            if self.gemini_api_key:
                html_content = self.call_gemini_api(self.results)
                if html_content:
                    html_filename = f"complete_analysis_{filename}_{self.timestamp}.html"
                    html_path = os.path.join(self.reports_folder, html_filename)
                    
                    with open(html_path, 'w', encoding='utf-8') as f:
                        f.write(html_content)
                        
                    print(f"[+] HTML report saved: {html_path}")
                    
            return {
                "json_report": json_path,
                "html_report": html_path,
                "results": self.results
            }
            
        except Exception as e:
            print(f"[-] Analysis failed: {str(e)}")
            return {"error": str(e)}

def main():
    parser = argparse.ArgumentParser(description="Complete Reverse Engineering Analyzer")
    parser.add_argument("file_path", help="Path to the file to analyze")
    parser.add_argument("--gemini-key", help="Gemini API key for HTML report generation")
    parser.add_argument("--output-dir", default="reports", help="Output directory for reports")
    
    args = parser.parse_args()
    
    # Initialize analyzer
    analyzer = CompleteReverseAnalyzer(gemini_api_key=args.gemini_key)
    
    if args.output_dir != "reports":
        analyzer.reports_folder = args.output_dir
        
    # Run analysis
    result = analyzer.run_complete_analysis(args.file_path)
    
    if "error" in result:
        print(f"[-] Analysis failed: {result['error']}")
        sys.exit(1)
    else:
        print("\n" + "="*60)
        print("ANALYSIS COMPLETE")
        print("="*60)
        print(f"JSON Report: {result['json_report']}")
        if result['html_report']:
            print(f"HTML Report: {result['html_report']}")
        print(f"Security Findings: {len(result['results']['security_findings'])}")
        print(f"Recommendations: {len(result['results']['recommendations'])}")
        print("="*60)

if __name__ == "__main__":
    main()