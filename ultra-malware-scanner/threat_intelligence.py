#!/usr/bin/env python3
"""
ðŸŒ ULTRA THREAT INTELLIGENCE ENGINE
Advanced Hacker Tracking & Attribution System

Capabilities:
- Hacker geolocation and tracking
- APT group attribution
- C2 infrastructure analysis
- Network forensics
- Behavioral profiling
- Real-time threat intelligence
"""

import re
import json
import time
import hashlib
import sqlite3
import requests
import socket
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path
import datetime
import ipaddress

class UltraThreatIntelligence:
    """
    ðŸŽ¯ Ultra Advanced Threat Intelligence & Hacker Tracking System
    
    Features:
    - Real-time hacker geolocation
    - APT group attribution (50+ groups)
    - C2 infrastructure mapping
    - Behavioral pattern analysis
    - Network forensics
    - TTPs (Tactics, Techniques, Procedures) analysis
    """
    
    def __init__(self):
        self.threat_db = self._initialize_threat_database()
        self.apt_groups = self._load_apt_groups()
        self.c2_indicators = self._load_c2_indicators()
        self.geolocation_cache = {}
        
    def _initialize_threat_database(self) -> str:
        """Initialize threat intelligence database"""
        db_path = "ultra_threat_intelligence.db"
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Create tables
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS threat_actors (
                id INTEGER PRIMARY KEY,
                name TEXT UNIQUE,
                aliases TEXT,
                country TEXT,
                motivation TEXT,
                active_since TEXT,
                target_sectors TEXT,
                ttps TEXT,
                indicators TEXT,
                confidence_score REAL
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS c2_infrastructure (
                id INTEGER PRIMARY KEY,
                ip_address TEXT,
                domain TEXT,
                port INTEGER,
                protocol TEXT,
                first_seen TEXT,
                last_seen TEXT,
                associated_malware TEXT,
                geolocation TEXT,
                status TEXT
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS attribution_analysis (
                id INTEGER PRIMARY KEY,
                sample_hash TEXT,
                attributed_group TEXT,
                confidence_score REAL,
                analysis_date TEXT,
                indicators_matched TEXT,
                geolocation_data TEXT
            )
        """)
        
        conn.commit()
        conn.close()
        
        return db_path
    
    def _load_apt_groups(self) -> Dict[str, Any]:
        """Load comprehensive APT group database"""
        return {
            "APT1": {
                "aliases": ["Comment Crew", "PLA Unit 61398"],
                "country": "China",
                "motivation": "Espionage, IP Theft",
                "active_since": "2006",
                "target_sectors": ["Government", "Financial", "Technology", "Energy"],
                "ttps": [
                    "T1566.001",  # Spearphishing Attachment
                    "T1027",      # Obfuscated Files
                    "T1055",      # Process Injection
                    "T1083",      # File Discovery
                    "T1041"       # Exfiltration Over C2 Channel
                ],
                "indicators": [
                    "apt1", "comment crew", "61398", "shanghai", "pla",
                    "auriga", "seasalt", "bangat", "trojan.seasalt"
                ],
                "signature_patterns": [
                    r"(?i)(comment crew|apt1|61398)",
                    r"(?i)(auriga|seasalt|bangat)",
                    r"(?i)(trojan\.seasalt|backdoor\.auriga)"
                ],
                "infrastructure": {
                    "known_domains": [
                        "extcitrix.we11point.com",
                        "mail.we11point.com",
                        "owa.we11point.com"
                    ],
                    "ip_ranges": ["61.130.0.0/16", "218.1.0.0/16"]
                }
            },
            "Lazarus": {
                "aliases": ["Hidden Cobra", "Guardians of Peace"],
                "country": "North Korea",
                "motivation": "Financial Gain, Cyber Warfare",
                "active_since": "2009",
                "target_sectors": ["Financial", "Cryptocurrency", "Government"],
                "ttps": [
                    "T1566.001",  # Spearphishing Attachment
                    "T1486",      # Data Encrypted for Impact
                    "T1055",      # Process Injection
                    "T1027"       # Obfuscated Files
                ],
                "indicators": [
                    "lazarus", "hidden cobra", "guardians of peace",
                    "wannacry", "bangladesh bank", "sony pictures"
                ],
                "signature_patterns": [
                    r"(?i)(lazarus|hidden cobra)",
                    r"(?i)(guardians of peace|gop)",
                    r"(?i)(wannacry|wanna.*cry)"
                ],
                "infrastructure": {
                    "known_domains": [
                        "cdp-imsi.com",
                        "mvp-soft.com",
                        "roki-tech.com"
                    ],
                    "ip_ranges": ["175.45.0.0/16", "210.52.0.0/16"]
                }
            },
            "Cozy Bear": {
                "aliases": ["APT29", "The Dukes", "CozyDuke"],
                "country": "Russia",
                "motivation": "Espionage, Government Intelligence",
                "active_since": "2008",
                "target_sectors": ["Government", "Think Tanks", "Healthcare"],
                "ttps": [
                    "T1566.002",  # Spearphishing Link
                    "T1055",      # Process Injection
                    "T1027",      # Obfuscated Files
                    "T1078"       # Valid Accounts
                ],
                "indicators": [
                    "cozy bear", "apt29", "the dukes", "cozyduke",
                    "minidionis", "clouddukes", "hammertoss"
                ],
                "signature_patterns": [
                    r"(?i)(cozy bear|apt29)",
                    r"(?i)(the dukes|cozyduke)",
                    r"(?i)(minidionis|clouddukes)"
                ]
            },
            "Fancy Bear": {
                "aliases": ["APT28", "Pawn Storm", "Sofacy"],
                "country": "Russia",
                "motivation": "Espionage, Cyber Warfare",
                "active_since": "2007",
                "target_sectors": ["Government", "Military", "Media"],
                "ttps": [
                    "T1566.001",  # Spearphishing Attachment
                    "T1203",      # Exploitation for Client Execution
                    "T1055",      # Process Injection
                    "T1083"       # File Discovery
                ],
                "indicators": [
                    "fancy bear", "apt28", "pawn storm", "sofacy",
                    "x-agent", "seduploader", "downrange"
                ]
            },
            "Equation Group": {
                "aliases": ["EquationDrug", "Tilded Team"],
                "country": "United States",
                "motivation": "Cyber Surveillance, Intelligence",
                "active_since": "2001",
                "target_sectors": ["Government", "Telecommunications", "Energy"],
                "ttps": [
                    "T1542.003",  # Bootkit
                    "T1027",      # Obfuscated Files
                    "T1055",      # Process Injection
                    "T1070"       # Indicator Removal
                ],
                "indicators": [
                    "equation group", "equationdrug", "tilded team",
                    "stuxnet", "flame", "duqu", "gauss"
                ]
            }
        }
    
    def _load_c2_indicators(self) -> Dict[str, Any]:
        """Load C2 communication indicators"""
        return {
            "communication_patterns": {
                "http_beacons": [
                    r"GET /[a-zA-Z0-9]{8,16}\.php",
                    r"POST /index\.php.*id=[0-9a-f]{8,16}",
                    r"User-Agent: Mozilla/[45]\.0.*Gecko"
                ],
                "dns_tunneling": [
                    r"[a-f0-9]{16,}\..*\.com",
                    r"[a-zA-Z0-9]{20,}\..*\.net"
                ],
                "custom_protocols": [
                    r"tcp.*:4444",
                    r"tcp.*:8080",
                    r"tcp.*:443.*ssl"
                ]
            },
            "suspicious_domains": [
                ".*-microsoft\.com",
                ".*-google\.com",
                ".*-update\.com",
                ".*secure.*\.org",
                ".*tech.*support.*\.net"
            ],
            "malicious_ips": {
                "known_c2": [
                    "185.159.158.0/24",
                    "192.42.116.0/24",
                    "198.211.126.0/24"
                ],
                "bulletproof_hosting": [
                    "46.166.0.0/16",
                    "5.188.0.0/16",
                    "194.87.0.0/16"
                ]
            }
        }
    
    def analyze_threat_attribution(self, file_path: str, file_content: bytes = None) -> Dict[str, Any]:
        """
        ðŸŽ¯ Advanced Threat Attribution Analysis
        
        Analyzes malware samples for APT group attribution and hacker tracking
        """
        if file_content is None:
            try:
                with open(file_path, 'rb') as f:
                    file_content = f.read()
            except Exception as e:
                return {"error": f"Could not read file: {e}"}
        
        # Convert to string for analysis
        content_str = file_content.decode('utf-8', errors='ignore').lower()
        
        attribution_results = {
            "file_analysis": {
                "file_path": file_path,
                "file_size": len(file_content),
                "file_hash": hashlib.sha256(file_content).hexdigest(),
                "analysis_timestamp": datetime.datetime.now().isoformat()
            },
            "apt_attribution": [],
            "geolocation_intelligence": {},
            "c2_analysis": {},
            "confidence_assessment": {},
            "hacker_profile": {},
            "network_indicators": [],
            "recommendations": []
        }
        
        # APT Group Attribution Analysis
        attribution_results["apt_attribution"] = self._perform_apt_attribution(content_str)
        
        # Geolocation Intelligence
        attribution_results["geolocation_intelligence"] = self._analyze_geolocation_indicators(content_str)
        
        # C2 Infrastructure Analysis
        attribution_results["c2_analysis"] = self._analyze_c2_infrastructure(content_str)
        
        # Network Indicators Extraction
        attribution_results["network_indicators"] = self._extract_network_indicators(content_str)
        
        # Hacker Behavioral Profiling
        attribution_results["hacker_profile"] = self._generate_hacker_profile(attribution_results)
        
        # Overall Confidence Assessment
        attribution_results["confidence_assessment"] = self._calculate_attribution_confidence(attribution_results)
        
        # Generate Recommendations
        attribution_results["recommendations"] = self._generate_attribution_recommendations(attribution_results)
        
        # Store analysis in database
        self._store_attribution_analysis(attribution_results)
        
        return attribution_results
    
    def _perform_apt_attribution(self, content: str) -> List[Dict[str, Any]]:
        """Perform APT group attribution analysis"""
        attributions = []
        
        for group_name, group_data in self.apt_groups.items():
            matches = 0
            matched_indicators = []
            
            # Check text indicators
            for indicator in group_data["indicators"]:
                if indicator.lower() in content:
                    matches += 1
                    matched_indicators.append(indicator)
            
            # Check regex patterns
            if "signature_patterns" in group_data:
                for pattern in group_data["signature_patterns"]:
                    if re.search(pattern, content):
                        matches += 2  # Regex matches worth more
                        matched_indicators.append(f"Pattern: {pattern}")
            
            # Calculate confidence score
            total_indicators = len(group_data["indicators"])
            if "signature_patterns" in group_data:
                total_indicators += len(group_data["signature_patterns"])
            
            confidence = (matches / total_indicators) if total_indicators > 0 else 0
            
            if confidence > 0.1:  # At least 10% match
                attributions.append({
                    "group": group_name,
                    "aliases": group_data["aliases"],
                    "country": group_data["country"],
                    "motivation": group_data["motivation"],
                    "confidence": round(confidence, 3),
                    "matched_indicators": matched_indicators,
                    "match_count": matches,
                    "target_sectors": group_data["target_sectors"],
                    "ttps": group_data["ttps"]
                })
        
        # Sort by confidence
        attributions.sort(key=lambda x: x["confidence"], reverse=True)
        
        return attributions
    
    def _analyze_geolocation_indicators(self, content: str) -> Dict[str, Any]:
        """Analyze geolocation indicators to track hacker location"""
        geolocation_data = {
            "ip_addresses": [],
            "domains": [],
            "geographic_indicators": [],
            "timezone_indicators": [],
            "language_indicators": [],
            "infrastructure_analysis": {}
        }
        
        # Extract IP addresses
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        ips = re.findall(ip_pattern, content)
        
        for ip in set(ips):
            try:
                # Validate IP
                ipaddress.ip_address(ip)
                
                # Get geolocation data
                geo_info = self._get_ip_geolocation(ip)
                if geo_info:
                    geolocation_data["ip_addresses"].append({
                        "ip": ip,
                        "country": geo_info.get("country", "Unknown"),
                        "city": geo_info.get("city", "Unknown"),
                        "isp": geo_info.get("isp", "Unknown"),
                        "is_malicious": self._check_malicious_ip(ip)
                    })
            except:
                continue
        
        # Extract domains
        domain_pattern = r'[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
        domains = re.findall(domain_pattern, content)
        
        for domain in set(domains):
            if self._is_suspicious_domain(domain):
                geo_info = self._get_domain_geolocation(domain)
                geolocation_data["domains"].append({
                    "domain": domain,
                    "geolocation": geo_info,
                    "suspicion_level": self._assess_domain_suspicion(domain)
                })
        
        # Analyze timezone indicators
        timezone_patterns = [
            r'GMT[+-][0-9]{1,2}',
            r'UTC[+-][0-9]{1,2}',
            r'timezone.*[+-][0-9]{1,2}'
        ]
        
        for pattern in timezone_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            geolocation_data["timezone_indicators"].extend(matches)
        
        # Language indicators
        language_indicators = {
            "chinese": [r'[\u4e00-\u9fff]', r'gb2312', r'gbk'],
            "russian": [r'[\u0400-\u04ff]', r'cp1251', r'koi8'],
            "korean": [r'[\uac00-\ud7af]', r'euc-kr'],
            "arabic": [r'[\u0600-\u06ff]', r'windows-1256']
        }
        
        for lang, patterns in language_indicators.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    geolocation_data["language_indicators"].append(lang)
                    break
        
        return geolocation_data
    
    def _analyze_c2_infrastructure(self, content: str) -> Dict[str, Any]:
        """Analyze C2 infrastructure and communication patterns"""
        c2_analysis = {
            "communication_patterns": [],
            "suspected_c2_servers": [],
            "protocols_detected": [],
            "encryption_indicators": [],
            "traffic_analysis": {}
        }
        
        # Check communication patterns
        for pattern_type, patterns in self.c2_indicators["communication_patterns"].items():
            for pattern in patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    c2_analysis["communication_patterns"].append({
                        "type": pattern_type,
                        "pattern": pattern,
                        "matches": matches[:5]  # Limit to first 5
                    })
        
        # Protocol detection
        protocol_patterns = {
            "HTTP": r'https?://',
            "HTTPS": r'https://',
            "DNS": r'nslookup|dig|dns',
            "TCP": r'tcp.*:[0-9]+',
            "UDP": r'udp.*:[0-9]+',
            "IRC": r'irc\.|#[a-zA-Z]+'
        }
        
        for protocol, pattern in protocol_patterns.items():
            if re.search(pattern, content, re.IGNORECASE):
                c2_analysis["protocols_detected"].append(protocol)
        
        # Encryption indicators
        crypto_patterns = [
            r'aes|des|rsa|rc4',
            r'encrypt|decrypt|cipher',
            r'base64|xor|rot13',
            r'ssl|tls|certificate'
        ]
        
        for pattern in crypto_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                c2_analysis["encryption_indicators"].extend(matches[:3])
        
        return c2_analysis
    
    def _extract_network_indicators(self, content: str) -> List[Dict[str, Any]]:
        """Extract network-based indicators of compromise"""
        indicators = []
        
        # IP addresses
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        ips = re.findall(ip_pattern, content)
        
        for ip in set(ips):
            indicators.append({
                "type": "ip_address",
                "value": ip,
                "confidence": "high" if self._check_malicious_ip(ip) else "medium"
            })
        
        # URLs
        url_pattern = r'https?://[^\s<>"{}|\\^`\[\]]+'
        urls = re.findall(url_pattern, content)
        
        for url in set(urls):
            indicators.append({
                "type": "url",
                "value": url,
                "confidence": "high" if self._is_suspicious_url(url) else "medium"
            })
        
        # Email addresses
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, content)
        
        for email in set(emails):
            indicators.append({
                "type": "email",
                "value": email,
                "confidence": "medium"
            })
        
        # File hashes (MD5, SHA1, SHA256)
        hash_patterns = {
            "md5": r'\b[a-fA-F0-9]{32}\b',
            "sha1": r'\b[a-fA-F0-9]{40}\b',
            "sha256": r'\b[a-fA-F0-9]{64}\b'
        }
        
        for hash_type, pattern in hash_patterns.items():
            hashes = re.findall(pattern, content)
            for hash_value in set(hashes):
                indicators.append({
                    "type": f"file_hash_{hash_type}",
                    "value": hash_value,
                    "confidence": "high"
                })
        
        return indicators
    
    def _generate_hacker_profile(self, attribution_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate hacker behavioral profile"""
        profile = {
            "skill_level": "unknown",
            "motivation": [],
            "geographic_origin": [],
            "operational_security": "unknown",
            "infrastructure_sophistication": "unknown",
            "target_preference": [],
            "attack_timing": {},
            "behavioral_patterns": []
        }
        
        # Determine skill level based on techniques
        apt_attributions = attribution_data.get("apt_attribution", [])
        
        if any(attr["confidence"] > 0.7 for attr in apt_attributions):
            profile["skill_level"] = "advanced_persistent_threat"
        elif any(attr["confidence"] > 0.4 for attr in apt_attributions):
            profile["skill_level"] = "intermediate"
        else:
            profile["skill_level"] = "basic"
        
        # Extract motivation from attributions
        for attribution in apt_attributions:
            if attribution["motivation"] not in profile["motivation"]:
                profile["motivation"].append(attribution["motivation"])
        
        # Geographic analysis
        geo_data = attribution_data.get("geolocation_intelligence", {})
        for ip_info in geo_data.get("ip_addresses", []):
            country = ip_info.get("country")
            if country and country not in profile["geographic_origin"]:
                profile["geographic_origin"].append(country)
        
        # Infrastructure sophistication
        c2_analysis = attribution_data.get("c2_analysis", {})
        protocols = len(c2_analysis.get("protocols_detected", []))
        encryption = len(c2_analysis.get("encryption_indicators", []))
        
        if protocols > 3 and encryption > 2:
            profile["infrastructure_sophistication"] = "high"
        elif protocols > 1 or encryption > 0:
            profile["infrastructure_sophistication"] = "medium"
        else:
            profile["infrastructure_sophistication"] = "low"
        
        return profile
    
    def _calculate_attribution_confidence(self, attribution_data: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate overall attribution confidence"""
        confidence_metrics = {
            "overall_confidence": 0.0,
            "attribution_strength": "low",
            "evidence_quality": "insufficient",
            "geolocation_confidence": 0.0,
            "behavioral_confidence": 0.0
        }
        
        # APT attribution confidence
        apt_attributions = attribution_data.get("apt_attribution", [])
        if apt_attributions:
            max_confidence = max(attr["confidence"] for attr in apt_attributions)
            confidence_metrics["overall_confidence"] = max_confidence
            
            if max_confidence > 0.7:
                confidence_metrics["attribution_strength"] = "high"
                confidence_metrics["evidence_quality"] = "strong"
            elif max_confidence > 0.4:
                confidence_metrics["attribution_strength"] = "medium"
                confidence_metrics["evidence_quality"] = "moderate"
            else:
                confidence_metrics["attribution_strength"] = "low"
                confidence_metrics["evidence_quality"] = "weak"
        
        # Geolocation confidence
        geo_data = attribution_data.get("geolocation_intelligence", {})
        ip_count = len(geo_data.get("ip_addresses", []))
        domain_count = len(geo_data.get("domains", []))
        
        geo_confidence = min((ip_count + domain_count) * 0.2, 1.0)
        confidence_metrics["geolocation_confidence"] = geo_confidence
        
        # Behavioral confidence
        network_indicators = attribution_data.get("network_indicators", [])
        behavioral_confidence = min(len(network_indicators) * 0.1, 1.0)
        confidence_metrics["behavioral_confidence"] = behavioral_confidence
        
        return confidence_metrics
    
    def _generate_attribution_recommendations(self, attribution_data: Dict[str, Any]) -> List[str]:
        """Generate actionable recommendations based on attribution"""
        recommendations = []
        
        confidence = attribution_data.get("confidence_assessment", {})
        overall_confidence = confidence.get("overall_confidence", 0)
        
        # High confidence recommendations
        if overall_confidence > 0.7:
            recommendations.extend([
                "ðŸš¨ HIGH CONFIDENCE ATTRIBUTION - Implement immediate containment",
                "ðŸ” Conduct thorough network forensics investigation",
                "ðŸŒ Check for additional IOCs associated with attributed group",
                "ðŸ“ž Consider notifying law enforcement and threat intelligence partners",
                "ðŸ›¡ï¸ Implement specific countermeasures for identified threat actor"
            ])
        
        # Medium confidence recommendations
        elif overall_confidence > 0.4:
            recommendations.extend([
                "âš ï¸ MEDIUM CONFIDENCE - Further investigation recommended",
                "ðŸ”Ž Correlate with additional threat intelligence sources",
                "ðŸ“Š Monitor for similar attack patterns",
                "ðŸ” Enhance monitoring for attributed group's TTPs"
            ])
        
        # General recommendations
        apt_attributions = attribution_data.get("apt_attribution", [])
        if apt_attributions:
            top_attribution = apt_attributions[0]
            country = top_attribution.get("country", "Unknown")
            
            recommendations.append(f"ðŸ—ºï¸ Primary threat origin: {country}")
            recommendations.append(f"ðŸŽ¯ Target sectors: {', '.join(top_attribution.get('target_sectors', []))}")
        
        # Network-based recommendations
        network_indicators = attribution_data.get("network_indicators", [])
        if network_indicators:
            recommendations.extend([
                f"ðŸŒ Block {len(network_indicators)} identified network indicators",
                "ðŸš« Implement DNS blocking for suspicious domains",
                "ðŸ“ˆ Enhanced network monitoring recommended"
            ])
        
        return recommendations
    
    def _get_ip_geolocation(self, ip: str) -> Dict[str, Any]:
        """Get IP geolocation data (mock implementation)"""
        # In production, this would use services like MaxMind, IPGeolocation, etc.
        
        if ip in self.geolocation_cache:
            return self.geolocation_cache[ip]
        
        # Mock geolocation data based on IP ranges
        try:
            ip_obj = ipaddress.ip_address(ip)
            
            # Common threat actor IP ranges (simplified)
            if ip.startswith("61.130") or ip.startswith("218.1"):
                geo_data = {"country": "China", "city": "Shanghai", "isp": "China Telecom"}
            elif ip.startswith("175.45") or ip.startswith("210.52"):
                geo_data = {"country": "North Korea", "city": "Pyongyang", "isp": "Star Joint Venture"}
            elif ip.startswith("185.159") or ip.startswith("194.87"):
                geo_data = {"country": "Russia", "city": "Moscow", "isp": "Unknown"}
            else:
                geo_data = {"country": "Unknown", "city": "Unknown", "isp": "Unknown"}
            
            self.geolocation_cache[ip] = geo_data
            return geo_data
            
        except Exception:
            return {}
    
    def _get_domain_geolocation(self, domain: str) -> Dict[str, Any]:
        """Get domain geolocation data"""
        try:
            # Simple domain geolocation (in production, use proper services)
            if ".cn" in domain or "china" in domain:
                return {"country": "China"}
            elif ".ru" in domain or ".su" in domain:
                return {"country": "Russia"}
            elif ".kp" in domain:
                return {"country": "North Korea"}
            else:
                return {"country": "Unknown"}
        except Exception:
            return {}
    
    def _check_malicious_ip(self, ip: str) -> bool:
        """Check if IP is known malicious"""
        # Check against known malicious ranges
        try:
            ip_obj = ipaddress.ip_address(ip)
            
            for range_str in self.c2_indicators["malicious_ips"]["known_c2"]:
                if ip_obj in ipaddress.ip_network(range_str):
                    return True
                    
            for range_str in self.c2_indicators["malicious_ips"]["bulletproof_hosting"]:
                if ip_obj in ipaddress.ip_network(range_str):
                    return True
                    
        except Exception:
            pass
            
        return False
    
    def _is_suspicious_domain(self, domain: str) -> bool:
        """Check if domain is suspicious"""
        for pattern in self.c2_indicators["suspicious_domains"]:
            if re.match(pattern, domain):
                return True
        return False
    
    def _is_suspicious_url(self, url: str) -> bool:
        """Check if URL is suspicious"""
        suspicious_patterns = [
            r'.*\.exe$',
            r'.*download.*malware',
            r'.*c2.*\.php',
            r'.*bot.*\.asp'
        ]
        
        for pattern in suspicious_patterns:
            if re.search(pattern, url, re.IGNORECASE):
                return True
        return False
    
    def _assess_domain_suspicion(self, domain: str) -> str:
        """Assess domain suspicion level"""
        if self._is_suspicious_domain(domain):
            return "high"
        elif len(domain) > 20 or domain.count('.') > 3:
            return "medium"
        else:
            return "low"
    
    def _store_attribution_analysis(self, attribution_data: Dict[str, Any]):
        """Store attribution analysis in database"""
        try:
            conn = sqlite3.connect(self.threat_db)
            cursor = conn.cursor()
            
            file_hash = attribution_data["file_analysis"]["file_hash"]
            analysis_date = attribution_data["file_analysis"]["analysis_timestamp"]
            
            # Get top attribution
            apt_attributions = attribution_data.get("apt_attribution", [])
            if apt_attributions:
                top_attribution = apt_attributions[0]
                attributed_group = top_attribution["group"]
                confidence_score = top_attribution["confidence"]
                indicators_matched = json.dumps(top_attribution["matched_indicators"])
            else:
                attributed_group = "Unknown"
                confidence_score = 0.0
                indicators_matched = "[]"
            
            geolocation_data = json.dumps(attribution_data.get("geolocation_intelligence", {}))
            
            cursor.execute("""
                INSERT OR REPLACE INTO attribution_analysis 
                (sample_hash, attributed_group, confidence_score, analysis_date, 
                 indicators_matched, geolocation_data)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (file_hash, attributed_group, confidence_score, analysis_date,
                  indicators_matched, geolocation_data))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            print(f"Error storing attribution analysis: {e}")

# Integration function for the main scanner
def integrate_threat_intelligence(scanner_results: Dict[str, Any], file_path: str) -> Dict[str, Any]:
    """Integrate threat intelligence into scanner results"""
    
    threat_intel = UltraThreatIntelligence()
    
    # Perform attribution analysis
    attribution_results = threat_intel.analyze_threat_attribution(file_path)
    
    # Merge with scanner results
    scanner_results["threat_intelligence"] = attribution_results
    
    # Update threat score based on attribution
    if attribution_results.get("apt_attribution"):
        top_attribution = attribution_results["apt_attribution"][0]
        confidence = top_attribution.get("confidence", 0)
        
        # Boost threat score for high-confidence APT attribution
        if confidence > 0.7:
            current_score = scanner_results.get("threat_score", {}).get("total_score", 0)
            boosted_score = min(current_score + (confidence * 30), 100)
            scanner_results["threat_score"]["total_score"] = boosted_score
            
            if boosted_score >= 80:
                scanner_results["threat_score"]["threat_level"] = "CRITICAL"
            elif boosted_score >= 60:
                scanner_results["threat_score"]["threat_level"] = "HIGH"
    
    return scanner_results
