"""
ReverseGod Built-in Radare2 Tool
Custom implementation of 'r2' and 'radare2' command functionality
"""

import struct
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
import re
import hashlib
from .rg_readelf import RGReadElf

class RGRadare2:
    """Built-in reverse engineering analysis tool (Radare2 alternative)"""
    
    def __init__(self):
        self.elf_reader = RGReadElf()
        self.current_file = None
        self.current_data = None
        self.analysis_cache = {}
        
        # x86/x86-64 instruction patterns (simplified)
        self.x86_instructions = self._load_x86_patterns()
        
    def analyze_binary(self, file_path: Path, analysis_level: str = "aaa") -> Dict[str, Any]:
        """Perform comprehensive binary analysis"""
        try:
            with open(file_path, 'rb') as f:
                self.current_data = f.read()
            
            self.current_file = file_path
            
            results = {
                "file_path": str(file_path),
                "analysis_level": analysis_level,
                "file_info": self._get_file_info(),
                "functions": self._analyze_functions(),
                "imports": self._analyze_imports(),
                "exports": self._analyze_exports(),
                "strings": self._analyze_strings(),
                "sections": self._analyze_sections(),
                "entry_points": self._find_entry_points(),
                "symbols": self._analyze_symbols(),
                "relocations": self._analyze_relocations(),
                "control_flow": self._analyze_control_flow(),
                "disassembly": self._basic_disassembly(),
                "analysis_complete": True
            }
            
            return results
            
        except Exception as e:
            return {"error": f"Radare2 analysis failed: {str(e)}"}
    
    def _load_x86_patterns(self) -> Dict[int, Dict[str, Any]]:
        """Load x86/x86-64 instruction patterns"""
        return {
            # Common x86 instructions
            0x90: {"mnemonic": "nop", "operands": "", "type": "nop"},
            0xc3: {"mnemonic": "ret", "operands": "", "type": "ret"},
            0xc2: {"mnemonic": "ret", "operands": "imm16", "type": "ret"},
            0xe8: {"mnemonic": "call", "operands": "rel32", "type": "call"},
            0xe9: {"mnemonic": "jmp", "operands": "rel32", "type": "jmp"},
            0xeb: {"mnemonic": "jmp", "operands": "rel8", "type": "jmp"},
            0x74: {"mnemonic": "je", "operands": "rel8", "type": "cjmp"},
            0x75: {"mnemonic": "jne", "operands": "rel8", "type": "cjmp"},
            0x72: {"mnemonic": "jb", "operands": "rel8", "type": "cjmp"},
            0x73: {"mnemonic": "jae", "operands": "rel8", "type": "cjmp"},
            0x76: {"mnemonic": "jbe", "operands": "rel8", "type": "cjmp"},
            0x77: {"mnemonic": "ja", "operands": "rel8", "type": "cjmp"},
            0x78: {"mnemonic": "js", "operands": "rel8", "type": "cjmp"},
            0x79: {"mnemonic": "jns", "operands": "rel8", "type": "cjmp"},
            
            # Push/Pop
            0x50: {"mnemonic": "push", "operands": "eax", "type": "push"},
            0x51: {"mnemonic": "push", "operands": "ecx", "type": "push"},
            0x52: {"mnemonic": "push", "operands": "edx", "type": "push"},
            0x53: {"mnemonic": "push", "operands": "ebx", "type": "push"},
            0x54: {"mnemonic": "push", "operands": "esp", "type": "push"},
            0x55: {"mnemonic": "push", "operands": "ebp", "type": "push"},
            0x56: {"mnemonic": "push", "operands": "esi", "type": "push"},
            0x57: {"mnemonic": "push", "operands": "edi", "type": "push"},
            
            0x58: {"mnemonic": "pop", "operands": "eax", "type": "pop"},
            0x59: {"mnemonic": "pop", "operands": "ecx", "type": "pop"},
            0x5a: {"mnemonic": "pop", "operands": "edx", "type": "pop"},
            0x5b: {"mnemonic": "pop", "operands": "ebx", "type": "pop"},
            0x5c: {"mnemonic": "pop", "operands": "esp", "type": "pop"},
            0x5d: {"mnemonic": "pop", "operands": "ebp", "type": "pop"},
            0x5e: {"mnemonic": "pop", "operands": "esi", "type": "pop"},
            0x5f: {"mnemonic": "pop", "operands": "edi", "type": "pop"},
            
            # Move instructions
            0x89: {"mnemonic": "mov", "operands": "r/m32, r32", "type": "mov"},
            0x8b: {"mnemonic": "mov", "operands": "r32, r/m32", "type": "mov"},
            0xb8: {"mnemonic": "mov", "operands": "eax, imm32", "type": "mov"},
            0xb9: {"mnemonic": "mov", "operands": "ecx, imm32", "type": "mov"},
            0xba: {"mnemonic": "mov", "operands": "edx, imm32", "type": "mov"},
            0xbb: {"mnemonic": "mov", "operands": "ebx, imm32", "type": "mov"},
            
            # Arithmetic
            0x01: {"mnemonic": "add", "operands": "r/m32, r32", "type": "arith"},
            0x03: {"mnemonic": "add", "operands": "r32, r/m32", "type": "arith"},
            0x29: {"mnemonic": "sub", "operands": "r/m32, r32", "type": "arith"},
            0x2b: {"mnemonic": "sub", "operands": "r32, r/m32", "type": "arith"},
            0x39: {"mnemonic": "cmp", "operands": "r/m32, r32", "type": "cmp"},
            0x3b: {"mnemonic": "cmp", "operands": "r32, r/m32", "type": "cmp"},
            
            # Test and logic
            0x85: {"mnemonic": "test", "operands": "r/m32, r32", "type": "test"},
            0x21: {"mnemonic": "and", "operands": "r/m32, r32", "type": "logic"},
            0x09: {"mnemonic": "or", "operands": "r/m32, r32", "type": "logic"},
            0x31: {"mnemonic": "xor", "operands": "r/m32, r32", "type": "logic"},
            
            # x86-64 REX prefixes
            0x48: {"mnemonic": "rex.W", "operands": "", "type": "prefix"},
            0x49: {"mnemonic": "rex.WB", "operands": "", "type": "prefix"},
            0x4a: {"mnemonic": "rex.WX", "operands": "", "type": "prefix"},
            0x4b: {"mnemonic": "rex.WXB", "operands": "", "type": "prefix"},
        }
    
    def _get_file_info(self) -> Dict[str, Any]:
        """Get basic file information"""
        if not self.current_data:
            return {}
        
        info = {
            "size": len(self.current_data),
            "md5": hashlib.md5(self.current_data).hexdigest(),
            "sha256": hashlib.sha256(self.current_data).hexdigest(),
        }
        
        # Detect file format
        if self.current_data.startswith(b'\x7fELF'):
            info["format"] = "elf"
            info["arch"] = self._detect_elf_arch()
        elif self.current_data.startswith(b'MZ'):
            info["format"] = "pe"
            info["arch"] = self._detect_pe_arch()
        else:
            info["format"] = "unknown"
            info["arch"] = "unknown"
        
        return info
    
    def _detect_elf_arch(self) -> str:
        """Detect ELF architecture"""
        try:
            if len(self.current_data) >= 20:
                e_machine = struct.unpack('<H', self.current_data[18:20])[0]
                arch_map = {
                    0x03: "x86",
                    0x3E: "x86-64",
                    0x28: "arm",
                    0xB7: "aarch64",
                    0x08: "mips"
                }
                return arch_map.get(e_machine, f"unknown-{e_machine}")
        except:
            pass
        return "unknown"
    
    def _detect_pe_arch(self) -> str:
        """Detect PE architecture"""
        try:
            if len(self.current_data) >= 64:
                pe_offset = struct.unpack('<I', self.current_data[60:64])[0]
                if pe_offset + 6 < len(self.current_data):
                    machine = struct.unpack('<H', self.current_data[pe_offset + 4:pe_offset + 6])[0]
                    arch_map = {
                        0x014c: "x86",
                        0x8664: "x86-64",
                        0x01c0: "arm"
                    }
                    return arch_map.get(machine, f"unknown-{machine}")
        except:
            pass
        return "unknown"
    
    def _analyze_functions(self) -> List[Dict[str, Any]]:
        """Analyze and identify functions"""
        functions = []
        
        if self.current_data.startswith(b'\x7fELF'):
            functions.extend(self._analyze_elf_functions())
        elif self.current_data.startswith(b'MZ'):
            functions.extend(self._analyze_pe_functions())
        
        # Add heuristic function detection
        functions.extend(self._heuristic_function_detection())
        
        # Remove duplicates and sort
        unique_functions = {}
        for func in functions:
            addr = func.get("address", 0)
            if addr not in unique_functions:
                unique_functions[addr] = func
        
        result = list(unique_functions.values())
        result.sort(key=lambda x: x.get("address", 0))
        return result[:100]  # Limit output
    
    def _analyze_elf_functions(self) -> List[Dict[str, Any]]:
        """Analyze ELF functions using symbol table"""
        functions = []
        
        try:
            elf_info = self.elf_reader.analyze_elf(self.current_file)
            if "symbols" in elf_info:
                for symbol_table in ["symbol_table", "dynamic_symbols"]:
                    for symbol in elf_info["symbols"].get(symbol_table, []):
                        if symbol.get("type") == "FUNC":
                            functions.append({
                                "name": symbol.get("name", f"func_{symbol.get('index', 0)}"),
                                "address": int(symbol.get("value", "0x0"), 16),
                                "size": symbol.get("size", 0),
                                "type": "function",
                                "source": "symbol_table"
                            })
        except:
            pass
        
        return functions
    
    def _analyze_pe_functions(self) -> List[Dict[str, Any]]:
        """Analyze PE functions using export table"""
        functions = []
        
        try:
            # This is a simplified PE export table parser
            # In a real implementation, you'd parse the full PE structure
            if len(self.current_data) >= 64:
                pe_offset = struct.unpack('<I', self.current_data[60:64])[0]
                if pe_offset + 120 < len(self.current_data):
                    # Look for export directory (simplified)
                    export_rva = struct.unpack('<I', self.current_data[pe_offset + 112:pe_offset + 116])[0]
                    if export_rva > 0:
                        functions.append({
                            "name": "exported_function",
                            "address": export_rva,
                            "size": 0,
                            "type": "function",
                            "source": "export_table"
                        })
        except:
            pass
        
        return functions
    
    def _heuristic_function_detection(self) -> List[Dict[str, Any]]:
        """Detect functions using heuristic analysis"""
        functions = []
        
        # Look for common function prologues
        prologues = [
            b'\x55\x8b\xec',        # push ebp; mov ebp, esp
            b'\x55\x48\x89\xe5',    # push rbp; mov rbp, rsp (x64)
            b'\x48\x83\xec',        # sub rsp, imm8 (x64)
            b'\x48\x81\xec',        # sub rsp, imm32 (x64)
        ]
        
        for prologue in prologues:
            offset = 0
            while True:
                pos = self.current_data.find(prologue, offset)
                if pos == -1:
                    break
                
                # Validate this looks like a real function
                if self._validate_function_start(pos):
                    functions.append({
                        "name": f"sub_{pos:x}",
                        "address": pos,
                        "size": self._estimate_function_size(pos),
                        "type": "function",
                        "source": "heuristic"
                    })
                
                offset = pos + 1
        
        return functions[:50]  # Limit heuristic functions
    
    def _validate_function_start(self, offset: int) -> bool:
        """Validate that offset looks like a function start"""
        if offset < 16 or offset + 16 >= len(self.current_data):
            return False
        
        # Check alignment (functions often start on aligned boundaries)
        if offset % 4 != 0:
            return False
        
        # Check for reasonable instruction sequence
        try:
            instructions = self._disassemble_bytes(self.current_data[offset:offset + 16])
            if len(instructions) < 2:
                return False
            
            # First instruction should be a prologue
            first_inst = instructions[0]
            if first_inst.get("type") not in ["push", "mov", "sub"]:
                return False
            
            return True
        except:
            return False
    
    def _estimate_function_size(self, start_offset: int) -> int:
        """Estimate function size by looking for return instructions"""
        max_size = 4096  # Maximum function size to scan
        
        for i in range(start_offset, min(start_offset + max_size, len(self.current_data))):
            if self.current_data[i] == 0xc3:  # ret instruction
                return i - start_offset + 1
            elif self.current_data[i:i+2] == b'\xc2':  # ret imm16
                return i - start_offset + 3
        
        return 256  # Default estimate
    
    def _analyze_imports(self) -> List[Dict[str, Any]]:
        """Analyze imported functions"""
        imports = []
        
        if self.current_data.startswith(b'\x7fELF'):
            imports.extend(self._analyze_elf_imports())
        elif self.current_data.startswith(b'MZ'):
            imports.extend(self._analyze_pe_imports())
        
        return imports
    
    def _analyze_elf_imports(self) -> List[Dict[str, Any]]:
        """Analyze ELF imports from dynamic symbols"""
        imports = []
        
        try:
            elf_info = self.elf_reader.analyze_elf(self.current_file)
            if "symbols" in elf_info:
                for symbol in elf_info["symbols"].get("dynamic_symbols", []):
                    if symbol.get("section_index") == 0:  # Undefined symbol (import)
                        imports.append({
                            "name": symbol.get("name", f"import_{symbol.get('index', 0)}"),
                            "address": int(symbol.get("value", "0x0"), 16),
                            "type": "import",
                            "library": "unknown"
                        })
        except:
            pass
        
        return imports
    
    def _analyze_pe_imports(self) -> List[Dict[str, Any]]:
        """Analyze PE imports from import table"""
        imports = []
        
        # Simplified PE import analysis
        # In a real implementation, you'd parse the full import table
        common_imports = [
            "kernel32.dll", "user32.dll", "ntdll.dll", "msvcrt.dll",
            "advapi32.dll", "ws2_32.dll", "shell32.dll"
        ]
        
        for dll in common_imports:
            if dll.encode() in self.current_data:
                imports.append({
                    "name": dll,
                    "address": 0,
                    "type": "import",
                    "library": dll
                })
        
        return imports
    
    def _analyze_exports(self) -> List[Dict[str, Any]]:
        """Analyze exported functions"""
        exports = []
        
        # Look for export patterns in the binary
        if self.current_data.startswith(b'MZ'):
            # PE exports would be parsed from export table
            pass
        elif self.current_data.startswith(b'\x7fELF'):
            # ELF exports are in symbol table
            try:
                elf_info = self.elf_reader.analyze_elf(self.current_file)
                if "symbols" in elf_info:
                    for symbol in elf_info["symbols"].get("symbol_table", []):
                        if (symbol.get("binding") == "GLOBAL" and 
                            symbol.get("section_index") != 0):
                            exports.append({
                                "name": symbol.get("name", f"export_{symbol.get('index', 0)}"),
                                "address": int(symbol.get("value", "0x0"), 16),
                                "type": "export",
                                "size": symbol.get("size", 0)
                            })
            except:
                pass
        
        return exports
    
    def _analyze_strings(self) -> List[Dict[str, Any]]:
        """Analyze strings in the binary"""
        strings = []
        
        # Extract ASCII strings
        current_string = b""
        start_offset = 0
        
        for i, byte in enumerate(self.current_data):
            if 32 <= byte <= 126:  # Printable ASCII
                if not current_string:
                    start_offset = i
                current_string += bytes([byte])
            else:
                if len(current_string) >= 4:
                    strings.append({
                        "string": current_string.decode('ascii'),
                        "offset": start_offset,
                        "length": len(current_string),
                        "encoding": "ascii"
                    })
                current_string = b""
        
        # Don't forget the last string
        if len(current_string) >= 4:
            strings.append({
                "string": current_string.decode('ascii'),
                "offset": start_offset,
                "length": len(current_string),
                "encoding": "ascii"
            })
        
        return strings[:200]  # Limit output
    
    def _analyze_sections(self) -> List[Dict[str, Any]]:
        """Analyze binary sections"""
        sections = []
        
        if self.current_data.startswith(b'\x7fELF'):
            try:
                elf_info = self.elf_reader.analyze_elf(self.current_file)
                for section in elf_info.get("sections", []):
                    sections.append({
                        "name": section.get("name", ""),
                        "address": section.get("address", "0x0"),
                        "size": section.get("size", 0),
                        "offset": section.get("offset", "0x0"),
                        "flags": section.get("flags", ""),
                        "type": section.get("type", "")
                    })
            except:
                pass
        
        return sections
    
    def _find_entry_points(self) -> List[Dict[str, Any]]:
        """Find entry points in the binary"""
        entry_points = []
        
        if self.current_data.startswith(b'\x7fELF'):
            try:
                elf_info = self.elf_reader.analyze_elf(self.current_file)
                entry_addr = elf_info.get("header", {}).get("entry_point", "0x0")
                if entry_addr != "0x0":
                    entry_points.append({
                        "name": "main",
                        "address": entry_addr,
                        "type": "entry_point"
                    })
            except:
                pass
        elif self.current_data.startswith(b'MZ'):
            # PE entry point would be parsed from optional header
            try:
                pe_offset = struct.unpack('<I', self.current_data[60:64])[0]
                if pe_offset + 40 < len(self.current_data):
                    entry_rva = struct.unpack('<I', self.current_data[pe_offset + 40:pe_offset + 44])[0]
                    entry_points.append({
                        "name": "main",
                        "address": f"0x{entry_rva:x}",
                        "type": "entry_point"
                    })
            except:
                pass
        
        return entry_points
    
    def _analyze_symbols(self) -> List[Dict[str, Any]]:
        """Analyze symbols in the binary"""
        symbols = []
        
        if self.current_data.startswith(b'\x7fELF'):
            try:
                elf_info = self.elf_reader.analyze_elf(self.current_file)
                for symbol_table in ["symbol_table", "dynamic_symbols"]:
                    for symbol in elf_info.get("symbols", {}).get(symbol_table, []):
                        symbols.append({
                            "name": symbol.get("name", ""),
                            "address": symbol.get("value", "0x0"),
                            "size": symbol.get("size", 0),
                            "type": symbol.get("type", ""),
                            "binding": symbol.get("binding", ""),
                            "section": symbol.get("section_index", 0)
                        })
            except:
                pass
        
        return symbols[:100]  # Limit output
    
    def _analyze_relocations(self) -> List[Dict[str, Any]]:
        """Analyze relocations in the binary"""
        relocations = []
        
        # This would parse relocation tables from ELF/PE
        # For now, return empty list as it's complex to implement fully
        
        return relocations
    
    def _analyze_control_flow(self) -> Dict[str, Any]:
        """Analyze control flow graph"""
        control_flow = {
            "basic_blocks": [],
            "call_graph": [],
            "jump_targets": []
        }
        
        # Find jump and call targets
        for i in range(len(self.current_data) - 5):
            byte = self.current_data[i]
            
            # Call instruction (0xe8)
            if byte == 0xe8:
                try:
                    rel_offset = struct.unpack('<i', self.current_data[i+1:i+5])[0]
                    target = i + 5 + rel_offset
                    if 0 <= target < len(self.current_data):
                        control_flow["call_graph"].append({
                            "from": i,
                            "to": target,
                            "type": "call"
                        })
                except:
                    pass
            
            # Jump instruction (0xe9)
            elif byte == 0xe9:
                try:
                    rel_offset = struct.unpack('<i', self.current_data[i+1:i+5])[0]
                    target = i + 5 + rel_offset
                    if 0 <= target < len(self.current_data):
                        control_flow["jump_targets"].append({
                            "from": i,
                            "to": target,
                            "type": "jmp"
                        })
                except:
                    pass
        
        return control_flow
    
    def _basic_disassembly(self) -> List[Dict[str, Any]]:
        """Perform basic disassembly of the binary"""
        disassembly = []
        
        # Disassemble first 256 bytes as example
        max_bytes = min(256, len(self.current_data))
        
        i = 0
        while i < max_bytes:
            instruction = self._disassemble_instruction(i)
            if instruction:
                disassembly.append(instruction)
                i += instruction.get("size", 1)
            else:
                i += 1
        
        return disassembly
    
    def _disassemble_instruction(self, offset: int) -> Optional[Dict[str, Any]]:
        """Disassemble a single instruction"""
        if offset >= len(self.current_data):
            return None
        
        byte = self.current_data[offset]
        
        if byte in self.x86_instructions:
            inst_info = self.x86_instructions[byte]
            size = self._calculate_instruction_size(offset, inst_info)
            
            return {
                "address": f"0x{offset:x}",
                "bytes": self.current_data[offset:offset + size].hex(),
                "mnemonic": inst_info["mnemonic"],
                "operands": inst_info["operands"],
                "type": inst_info["type"],
                "size": size
            }
        
        # Unknown instruction
        return {
            "address": f"0x{offset:x}",
            "bytes": f"{byte:02x}",
            "mnemonic": "db",
            "operands": f"0x{byte:02x}",
            "type": "data",
            "size": 1
        }
    
    def _calculate_instruction_size(self, offset: int, inst_info: Dict[str, Any]) -> int:
        """Calculate instruction size based on operands"""
        base_size = 1
        operands = inst_info.get("operands", "")
        
        if "rel32" in operands:
            base_size += 4
        elif "rel8" in operands:
            base_size += 1
        elif "imm32" in operands:
            base_size += 4
        elif "imm16" in operands:
            base_size += 2
        elif "r/m32" in operands:
            base_size += 1  # ModR/M byte, simplified
        
        return base_size
    
    def _disassemble_bytes(self, data: bytes) -> List[Dict[str, Any]]:
        """Disassemble a sequence of bytes"""
        instructions = []
        i = 0
        
        while i < len(data):
            if data[i] in self.x86_instructions:
                inst_info = self.x86_instructions[data[i]]
                size = min(self._calculate_instruction_size(i, inst_info), len(data) - i)
                
                instructions.append({
                    "offset": i,
                    "bytes": data[i:i + size].hex(),
                    "mnemonic": inst_info["mnemonic"],
                    "operands": inst_info["operands"],
                    "type": inst_info["type"],
                    "size": size
                })
                
                i += size
            else:
                i += 1
        
        return instructions
    
    def get_r2_output(self, file_path: Path, commands: List[str] = None) -> str:
        """Get output in radare2 format"""
        if not commands:
            commands = ["aaa", "afl", "ii", "iE", "iz", "iS", "ie", "is"]
        
        result = self.analyze_binary(file_path)
        
        if "error" in result:
            return f"r2: {result['error']}"
        
        output_lines = []
        
        for cmd in commands:
            if cmd == "aaa":
                output_lines.append("# Analysis complete")
            elif cmd == "afl":
                output_lines.append("# Functions:")
                for func in result.get("functions", []):
                    output_lines.append(f"0x{func.get('address', 0):08x} {func.get('size', 0):4d} {func.get('name', 'unknown')}")
            elif cmd == "ii":
                output_lines.append("# Imports:")
                for imp in result.get("imports", []):
                    output_lines.append(f"0x{imp.get('address', 0):08x} {imp.get('name', 'unknown')}")
            elif cmd == "iE":
                output_lines.append("# Exports:")
                for exp in result.get("exports", []):
                    output_lines.append(f"0x{exp.get('address', 0):08x} {exp.get('name', 'unknown')}")
            elif cmd == "iz":
                output_lines.append("# Strings:")
                for string in result.get("strings", [])[:10]:
                    output_lines.append(f"0x{string.get('offset', 0):08x} {string.get('string', '')}")
            elif cmd == "iS":
                output_lines.append("# Sections:")
                for section in result.get("sections", []):
                    output_lines.append(f"{section.get('name', ''):12} {section.get('address', '0x0'):>10} {section.get('size', 0):>8}")
            elif cmd == "ie":
                output_lines.append("# Entry points:")
                for entry in result.get("entry_points", []):
                    output_lines.append(f"0x{entry.get('address', '0x0')} {entry.get('name', 'main')}")
            elif cmd == "is":
                output_lines.append("# Symbols:")
                for symbol in result.get("symbols", [])[:10]:
                    output_lines.append(f"0x{symbol.get('address', '0x0')} {symbol.get('name', 'unknown')}")
        
        return "\n".join(output_lines)