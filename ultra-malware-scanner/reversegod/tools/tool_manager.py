"""
ReverseGod Tool Manager
Manages built-in tools and provides fallbacks for external tools
"""

from pathlib import Path
from typing import Dict, Any, List, Optional, Union
import subprocess
import sys

from .rg_file import RGFile
from .rg_strings import RGStrings
from .rg_readelf import RGReadElf
from .rg_objdump import RGObjdump
from .rg_hexdump import RGHexdump
from .rg_binwalk import RGBinwalk
from .rg_radare2 import RGRadare2
from .rg_gdb import RGGdb
from .rg_strace import RGStrace
from .rg_ltrace import RGLtrace
from .rg_valgrind import RGValgrind

class ToolManager:
    """Manages both external and built-in tools"""
    
    def __init__(self):
        # Initialize built-in tools
        self.rg_file = RGFile()
        self.rg_strings = RGStrings()
        self.rg_readelf = RGReadElf()
        self.rg_objdump = RGObjdump()
        self.rg_hexdump = RGHexdump()
        self.rg_binwalk = RGBinwalk()
        self.rg_radare2 = RGRadare2()
        self.rg_gdb = RGGdb()
        self.rg_strace = RGStrace()
        self.rg_ltrace = RGLtrace()
        self.rg_valgrind = RGValgrind()
        
        # Cache for tool availability
        self._tool_availability_cache = {}
        
        # Tool mappings
        self.tool_mappings = {
            'file': self._run_file_command,
            'strings': self._run_strings_command,
            'readelf': self._run_readelf_command,
            'objdump': self._run_objdump_command,
            'xxd': self._run_xxd_command,
            'hexdump': self._run_hexdump_command,
            'binwalk': self._run_binwalk_command,
            'r2': self._run_radare2_command,
            'radare2': self._run_radare2_command,
            'gdb': self._run_gdb_command,
            'strace': self._run_strace_command,
            'ltrace': self._run_ltrace_command,
            'valgrind': self._run_valgrind_command
        }
    
    def run_tool(self, tool_name: str, args: List[str], timeout: int = 60) -> Dict[str, Any]:
        """Run a tool with built-in fallback support"""
        
        # Check if we have a custom implementation
        if tool_name in self.tool_mappings:
            return self.tool_mappings[tool_name](args, timeout)
        
        # Fall back to external tool
        return self._run_external_tool(tool_name, args, timeout)
    
    def is_tool_available(self, tool_name: str) -> bool:
        """Check if tool is available (external or built-in)"""
        if tool_name in self._tool_availability_cache:
            return self._tool_availability_cache[tool_name]
        
        # Built-in tools are always available
        if tool_name in ['file', 'strings', 'readelf', 'objdump', 'xxd', 'hexdump', 'binwalk', 'r2', 'radare2', 'gdb', 'strace', 'ltrace', 'valgrind']:
            self._tool_availability_cache[tool_name] = True
            return True
        
        # Check external tool
        try:
            result = subprocess.run(
                [tool_name, '--version'], 
                capture_output=True, 
                timeout=5,
                text=True
            )
            available = result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
            try:
                # Try alternative check
                result = subprocess.run(
                    [tool_name, '-h'], 
                    capture_output=True, 
                    timeout=5,
                    text=True
                )
                available = result.returncode == 0
            except:
                available = False
        
        self._tool_availability_cache[tool_name] = available
        return available
    
    def get_tool_status(self) -> Dict[str, Dict[str, Any]]:
        """Get status of all tools"""
        tools = [
            'file', 'strings', 'readelf', 'objdump', 'xxd', 'hexdump',
            'binwalk', 'r2', 'radare2', 'gdb', 'strace', 'ltrace', 'valgrind'
        ]
        
        status = {}
        for tool in tools:
            is_builtin = tool in ['file', 'strings', 'readelf', 'objdump', 'xxd', 'hexdump', 'binwalk', 'r2', 'radare2', 'gdb', 'strace', 'ltrace', 'valgrind']
            is_available = self.is_tool_available(tool)
            
            status[tool] = {
                'available': is_available,
                'builtin': is_builtin,
                'type': 'Built-in ReverseGod Tool' if is_builtin else 'External Tool',
                'status': '✅ Available' if is_available else '❌ Not Available'
            }
        
        return status
    
    # Built-in tool implementations
    
    def _run_file_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run file command using built-in implementation"""
        try:
            # Parse arguments
            brief = '-b' in args
            file_path = None
            
            for arg in args:
                if not arg.startswith('-') and arg != 'file':
                    file_path = Path(arg)
                    break
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'file: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_file.get_file_info(file_path, brief)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'file: {str(e)}',
                'return_code': 1
            }
    
    def _run_strings_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run strings command using built-in implementation"""
        try:
            # Parse arguments
            min_length = 4
            print_offset = False
            file_path = None
            
            i = 0
            while i < len(args):
                if args[i] == '-n' and i + 1 < len(args):
                    min_length = int(args[i + 1])
                    i += 2
                elif args[i] == '-t' and i + 1 < len(args):
                    if args[i + 1] == 'x':
                        print_offset = True
                    i += 2
                elif not args[i].startswith('-') and args[i] != 'strings':
                    file_path = Path(args[i])
                    i += 1
                else:
                    i += 1
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'strings: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_strings.get_strings_output(
                file_path, min_length, print_offset
            )
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'strings: {str(e)}',
                'return_code': 1
            }
    
    def _run_readelf_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run readelf command using built-in implementation"""
        try:
            # Parse arguments
            show_headers = '-h' in args
            show_sections = '-S' in args
            show_symbols = '-s' in args
            show_all = '-a' in args
            
            file_path = None
            for arg in args:
                if not arg.startswith('-') and arg != 'readelf':
                    file_path = Path(arg)
                    break
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'readelf: No such file or directory',
                    'return_code': 1
                }
            
            # Check if it's an ELF file
            with open(file_path, 'rb') as f:
                magic = f.read(4)
            
            if magic != b'\x7fELF':
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'readelf: Not an ELF file',
                    'return_code': 1
                }
            
            if show_headers or show_all:
                result = self.rg_readelf.get_header_output(file_path)
            else:
                # Default to showing headers
                result = self.rg_readelf.get_header_output(file_path)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'readelf: {str(e)}',
                'return_code': 1
            }
    
    def _run_objdump_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run objdump command using built-in implementation"""
        try:
            # Parse arguments
            show_file_headers = '-f' in args
            show_section_headers = '-h' in args
            show_all_headers = '-x' in args
            disassemble = '-d' in args
            
            file_path = None
            for arg in args:
                if not arg.startswith('-') and arg != 'objdump':
                    file_path = Path(arg)
                    break
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'objdump: No such file or directory',
                    'return_code': 1
                }
            
            if show_file_headers:
                result = self.rg_objdump.get_file_headers_output(file_path)
            elif show_section_headers:
                result = self.rg_objdump.get_section_headers_output(file_path)
            elif show_all_headers:
                result = self.rg_objdump.get_all_headers_output(file_path)
            elif disassemble:
                result = self.rg_objdump.get_disassembly_output(file_path)
            else:
                result = self.rg_objdump.get_file_headers_output(file_path)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'objdump: {str(e)}',
                'return_code': 1
            }
    
    def _run_xxd_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run xxd command using built-in implementation"""
        try:
            # Parse arguments
            length = None
            offset = 0
            cols = 16
            file_path = None
            
            i = 0
            while i < len(args):
                if args[i] == '-l' and i + 1 < len(args):
                    length = int(args[i + 1])
                    i += 2
                elif args[i] == '-s' and i + 1 < len(args):
                    offset = int(args[i + 1])
                    i += 2
                elif args[i] == '-c' and i + 1 < len(args):
                    cols = int(args[i + 1])
                    i += 2
                elif not args[i].startswith('-') and args[i] != 'xxd':
                    file_path = Path(args[i])
                    i += 1
                else:
                    i += 1
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'xxd: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_hexdump.get_xxd_output(file_path, length, offset, cols)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'xxd: {str(e)}',
                'return_code': 1
            }
    
    def _run_hexdump_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run hexdump command using built-in implementation"""
        try:
            # Parse arguments
            canonical = '-C' in args
            length = None
            offset = 0
            file_path = None
            
            i = 0
            while i < len(args):
                if args[i] == '-n' and i + 1 < len(args):
                    length = int(args[i + 1])
                    i += 2
                elif args[i] == '-s' and i + 1 < len(args):
                    offset = int(args[i + 1])
                    i += 2
                elif not args[i].startswith('-') and args[i] != 'hexdump':
                    file_path = Path(args[i])
                    i += 1
                else:
                    i += 1
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'hexdump: No such file or directory',
                    'return_code': 1
                }
            
            format_type = "canonical" if canonical else "canonical"
            result = self.rg_hexdump.get_hexdump_output(file_path, format_type, length, offset)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'hexdump: {str(e)}',
                'return_code': 1
            }
    
    # Built-in tool implementations for advanced tools
    
    def _run_binwalk_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run binwalk command using built-in implementation"""
        try:
            # Parse arguments
            extract = '-e' in args or '--extract' in args
            signature_scan = True  # Default behavior
            file_path = None
            
            for arg in args:
                if not arg.startswith('-') and arg != 'binwalk':
                    file_path = Path(arg)
                    break
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'binwalk: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_binwalk.get_binwalk_output(file_path, extract)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'binwalk: {str(e)}',
                'return_code': 1
            }
    
    def _run_radare2_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run radare2 command using built-in implementation"""
        try:
            # Parse arguments
            quiet = '-q' in args
            script_file = None
            file_path = None
            
            i = 0
            while i < len(args):
                if args[i] == '-i' and i + 1 < len(args):
                    script_file = args[i + 1]
                    i += 2
                elif not args[i].startswith('-') and args[i] not in ['r2', 'radare2']:
                    file_path = Path(args[i])
                    i += 1
                else:
                    i += 1
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'r2: No such file or directory',
                    'return_code': 1
                }
            
            # Default commands if no script provided
            commands = ["aaa", "afl", "ii", "iE", "iz", "iS", "ie", "is"]
            result = self.rg_radare2.get_r2_output(file_path, commands)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'r2: {str(e)}',
                'return_code': 1
            }
    
    def _run_gdb_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run gdb command using built-in implementation"""
        try:
            # Parse arguments
            batch = '-batch' in args
            script_file = None
            file_path = None
            
            i = 0
            while i < len(args):
                if args[i] == '-x' and i + 1 < len(args):
                    script_file = args[i + 1]
                    i += 2
                elif not args[i].startswith('-') and args[i] != 'gdb':
                    file_path = Path(args[i])
                    i += 1
                else:
                    i += 1
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'gdb: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_gdb.get_gdb_output(file_path)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'gdb: {str(e)}',
                'return_code': 1
            }
    
    def _run_strace_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run strace command using built-in implementation"""
        try:
            # Parse arguments
            follow_forks = '-f' in args
            trace_all = '-e' in args and 'trace=all' in ' '.join(args)
            file_path = None
            
            for arg in args:
                if not arg.startswith('-') and arg != 'strace':
                    file_path = Path(arg)
                    break
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'strace: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_strace.get_strace_output(file_path, follow_forks, trace_all)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'strace: {str(e)}',
                'return_code': 1
            }
    
    def _run_ltrace_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run ltrace command using built-in implementation"""
        try:
            # Parse arguments
            follow_forks = '-f' in args
            file_path = None
            
            for arg in args:
                if not arg.startswith('-') and arg != 'ltrace':
                    file_path = Path(arg)
                    break
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'ltrace: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_ltrace.get_ltrace_output(file_path, follow_forks)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'ltrace: {str(e)}',
                'return_code': 1
            }
    
    def _run_valgrind_command(self, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run valgrind command using built-in implementation"""
        try:
            # Parse arguments
            tool = "memcheck"  # Default tool
            leak_check = "full"  # Default leak check
            file_path = None
            
            i = 0
            while i < len(args):
                if args[i] == '--tool' and i + 1 < len(args):
                    tool = args[i + 1]
                    i += 2
                elif args[i] == '--leak-check' and i + 1 < len(args):
                    leak_check = args[i + 1]
                    i += 2
                elif not args[i].startswith('-') and args[i] != 'valgrind':
                    file_path = Path(args[i])
                    i += 1
                else:
                    i += 1
            
            if not file_path or not file_path.exists():
                return {
                    'success': False,
                    'stdout': '',
                    'stderr': 'valgrind: No such file or directory',
                    'return_code': 1
                }
            
            result = self.rg_valgrind.get_valgrind_output(file_path, tool, leak_check)
            
            return {
                'success': True,
                'stdout': result,
                'stderr': '',
                'return_code': 0,
                'tool_used': 'builtin'
            }
            
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'valgrind: {str(e)}',
                'return_code': 1
            }
    
    def _run_external_tool(self, tool_name: str, args: List[str], timeout: int) -> Dict[str, Any]:
        """Run external tool via subprocess"""
        try:
            # Build command
            cmd = [tool_name] + args
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                timeout=timeout,
                text=True
            )
            
            return {
                'success': result.returncode == 0,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'return_code': result.returncode,
                'tool_used': 'external'
            }
            
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'{tool_name}: Command timed out after {timeout} seconds',
                'return_code': -1
            }
        except FileNotFoundError:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'Command not found: {tool_name}',
                'return_code': 127
            }
        except Exception as e:
            return {
                'success': False,
                'stdout': '',
                'stderr': f'{tool_name}: {str(e)}',
                'return_code': 1
            }
    
    def get_comprehensive_analysis(self, file_path: Path) -> Dict[str, Any]:
        """Get comprehensive analysis using all available built-in tools"""
        analysis = {
            'file_path': str(file_path),
            'tools_used': []
        }
        
        try:
            # File type detection
            file_info = self.rg_file.identify_file(file_path)
            analysis['file_info'] = file_info
            analysis['tools_used'].append('rg_file')
            
            # String extraction
            strings_info = self.rg_strings.analyze_strings(file_path)
            analysis['strings_analysis'] = strings_info
            analysis['tools_used'].append('rg_strings')
            
            # Hex analysis
            hex_info = self.rg_hexdump.analyze_hex_patterns(file_path)
            analysis['hex_analysis'] = hex_info
            analysis['tools_used'].append('rg_hexdump')
            
            # Format-specific analysis
            if file_info.get('file_type') == 'ELF':
                elf_info = self.rg_readelf.analyze_elf(file_path)
                analysis['elf_analysis'] = elf_info
                analysis['tools_used'].append('rg_readelf')
                
                objdump_info = self.rg_objdump.analyze_file(file_path)
                analysis['objdump_analysis'] = objdump_info
                analysis['tools_used'].append('rg_objdump')
            
            analysis['analysis_complete'] = True
            
        except Exception as e:
            analysis['error'] = str(e)
            analysis['analysis_complete'] = False
        
        return analysis