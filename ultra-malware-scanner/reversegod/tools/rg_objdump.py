"""
ReverseGod Built-in Object Dump Tool
Custom implementation of 'objdump' command functionality
"""

import struct
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from .rg_readelf import RGReadElf

class RGObjdump:
    """Built-in object dump and disassembly tool"""
    
    def __init__(self):
        self.elf_reader = RGReadElf()
        self.pe_reader = None  # Could add PE support later
    
    def analyze_file(self, file_path: Path) -> Dict[str, Any]:
        """Analyze file and provide objdump-like information"""
        try:
            with open(file_path, 'rb') as f:
                data = f.read(16)
            
            if data.startswith(b'\x7fELF'):
                return self._analyze_elf_file(file_path)
            elif data.startswith(b'MZ'):
                return self._analyze_pe_file(file_path)
            else:
                return self._analyze_unknown_file(file_path)
                
        except Exception as e:
            return {"error": f"Failed to analyze file: {str(e)}"}
    
    def _analyze_elf_file(self, file_path: Path) -> Dict[str, Any]:
        """Analyze ELF file"""
        elf_info = self.elf_reader.analyze_elf(file_path)
        
        if "error" in elf_info:
            return elf_info
        
        return {
            "file_format": "elf",
            "architecture": self._get_elf_architecture(elf_info),
            "file_header": self._format_elf_file_header(elf_info),
            "section_headers": self._format_elf_section_headers(elf_info),
            "program_headers": elf_info.get("program_headers", []),
            "symbols": elf_info.get("symbols", {}),
            "disassembly": self._get_basic_disassembly(file_path, elf_info)
        }
    
    def _analyze_pe_file(self, file_path: Path) -> Dict[str, Any]:
        """Analyze PE file (basic implementation)"""
        try:
            with open(file_path, 'rb') as f:
                data = f.read(1024)
            
            # Basic PE header parsing
            if len(data) < 64:
                return {"error": "PE file too small"}
            
            # Get PE header offset
            pe_offset = struct.unpack('<I', data[60:64])[0]
            
            if len(data) < pe_offset + 24:
                return {"error": "Invalid PE header"}
            
            # Check PE signature
            if data[pe_offset:pe_offset + 4] != b'PE\x00\x00':
                return {"error": "Invalid PE signature"}
            
            # Get machine type
            machine = struct.unpack('<H', data[pe_offset + 4:pe_offset + 6])[0]
            
            machine_names = {
                0x014c: "i386",
                0x8664: "x86-64",
                0x01c0: "ARM",
                0xaa64: "AArch64"
            }
            
            arch = machine_names.get(machine, f"unknown (0x{machine:x})")
            
            return {
                "file_format": "pe",
                "architecture": arch,
                "file_header": {
                    "machine": f"0x{machine:x}",
                    "architecture": arch,
                    "format": "PE32+ executable"
                },
                "section_headers": [],
                "disassembly": []
            }
            
        except Exception as e:
            return {"error": f"PE analysis failed: {str(e)}"}
    
    def _analyze_unknown_file(self, file_path: Path) -> Dict[str, Any]:
        """Analyze unknown file format"""
        return {
            "file_format": "unknown",
            "architecture": "unknown",
            "file_header": {"format": "data"},
            "section_headers": [],
            "disassembly": []
        }
    
    def _get_elf_architecture(self, elf_info: Dict[str, Any]) -> str:
        """Get architecture string from ELF info"""
        header = elf_info.get("header", {})
        machine = header.get("machine", "")
        
        if "X86-64" in machine:
            return "i386:x86-64"
        elif "80386" in machine:
            return "i386"
        elif "ARM" in machine:
            return "arm"
        else:
            return "unknown"
    
    def _format_elf_file_header(self, elf_info: Dict[str, Any]) -> Dict[str, Any]:
        """Format ELF file header for objdump output"""
        header = elf_info.get("header", {})
        
        return {
            "format": f"elf{64 if 'ELF64' in header.get('class', '') else 32}-{self._get_elf_architecture(elf_info)}",
            "architecture": self._get_elf_architecture(elf_info),
            "start_address": header.get("entry_point", "0x0")
        }
    
    def _format_elf_section_headers(self, elf_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Format ELF section headers for objdump output"""
        sections = elf_info.get("sections", [])
        formatted_sections = []
        
        for section in sections:
            formatted_sections.append({
                "index": section.get("index", 0),
                "name": section.get("name", ""),
                "size": f"0x{section.get('size', 0):08x}",
                "vma": section.get("address", "0x0"),
                "lma": section.get("address", "0x0"),
                "file_offset": section.get("offset", "0x0"),
                "alignment": f"2**{section.get('alignment', 0).bit_length() - 1 if section.get('alignment', 0) > 0 else 0}",
                "flags": section.get("flags", "")
            })
        
        return formatted_sections
    
    def _get_basic_disassembly(self, file_path: Path, elf_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get basic disassembly information"""
        # This is a simplified disassembly - in a real implementation,
        # you would use a proper disassembly engine like Capstone
        
        disassembly = []
        sections = elf_info.get("sections", [])
        
        # Find executable sections
        executable_sections = [s for s in sections if "EXEC" in s.get("flags", "")]
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            for section in executable_sections[:3]:  # Limit to first 3 executable sections
                offset = int(section.get("offset", "0x0"), 16)
                size = min(section.get("size", 0), 256)  # Limit size for demo
                
                if offset + size <= len(data):
                    section_data = data[offset:offset + size]
                    
                    # Simple byte-by-byte "disassembly" (placeholder)
                    for i in range(0, min(len(section_data), 64), 4):  # Show first 64 bytes
                        addr = int(section.get("address", "0x0"), 16) + i
                        bytes_chunk = section_data[i:i + 4]
                        
                        hex_bytes = ' '.join(f'{b:02x}' for b in bytes_chunk)
                        
                        disassembly.append({
                            "address": f"{addr:08x}",
                            "bytes": hex_bytes,
                            "instruction": self._guess_instruction(bytes_chunk),
                            "section": section.get("name", "unknown")
                        })
            
            return disassembly
            
        except Exception:
            return []
    
    def _guess_instruction(self, bytes_data: bytes) -> str:
        """Guess instruction from bytes (very basic)"""
        if not bytes_data:
            return "???"
        
        # Very basic x86/x86-64 instruction guessing
        first_byte = bytes_data[0]
        
        common_instructions = {
            0x90: "nop",
            0xc3: "ret",
            0xe8: "call",
            0xe9: "jmp",
            0x74: "je",
            0x75: "jne",
            0x48: "rex.W",  # x86-64 prefix
            0x50: "push %eax",
            0x51: "push %ecx",
            0x52: "push %edx",
            0x53: "push %ebx",
            0x58: "pop %eax",
            0x59: "pop %ecx",
            0x5a: "pop %edx",
            0x5b: "pop %ebx",
            0xb8: "mov $imm32, %eax",
            0x89: "mov",
            0x8b: "mov"
        }
        
        return common_instructions.get(first_byte, f"data{first_byte:02x}")
    
    def get_file_headers_output(self, file_path: Path) -> str:
        """Get file headers output in objdump format"""
        result = self.analyze_file(file_path)
        
        if "error" in result:
            return f"objdump: {result['error']}"
        
        file_header = result.get("file_header", {})
        
        output = f"{file_path}:     file format {file_header.get('format', 'unknown')}\n"
        output += f"architecture: {file_header.get('architecture', 'unknown')}, "
        output += f"flags 0x00000000:\n"
        
        if "start_address" in file_header:
            output += f"start address {file_header['start_address']}\n"
        
        return output
    
    def get_section_headers_output(self, file_path: Path) -> str:
        """Get section headers output in objdump format"""
        result = self.analyze_file(file_path)
        
        if "error" in result:
            return f"objdump: {result['error']}"
        
        sections = result.get("section_headers", [])
        
        if not sections:
            return f"{file_path}:     file format {result.get('file_format', 'unknown')}\n\nSections:\nNone\n"
        
        output = f"{file_path}:     file format {result.get('file_format', 'unknown')}\n\n"
        output += "Sections:\n"
        output += "Idx Name          Size      VMA       LMA       File off  Algn\n"
        
        for section in sections:
            output += f"{section.get('index', 0):3d} "
            output += f"{section.get('name', ''):<13} "
            output += f"{section.get('size', '00000000'):>8} "
            output += f"{section.get('vma', '00000000'):>8} "
            output += f"{section.get('lma', '00000000'):>8} "
            output += f"{section.get('file_offset', '00000000'):>8} "
            output += f"{section.get('alignment', '2**0'):>5}\n"
            
            flags = section.get('flags', '')
            if flags:
                output += f"                  {flags}\n"
        
        return output
    
    def get_disassembly_output(self, file_path: Path, section_name: str = None) -> str:
        """Get disassembly output in objdump format"""
        result = self.analyze_file(file_path)
        
        if "error" in result:
            return f"objdump: {result['error']}"
        
        disassembly = result.get("disassembly", [])
        
        if not disassembly:
            return f"{file_path}:     file format {result.get('file_format', 'unknown')}\n\nNo disassembly available\n"
        
        output = f"{file_path}:     file format {result.get('file_format', 'unknown')}\n\n"
        
        current_section = None
        for entry in disassembly:
            section = entry.get("section", "unknown")
            
            if section != current_section:
                output += f"\nDisassembly of section {section}:\n\n"
                current_section = section
            
            output += f"{entry.get('address', '00000000')}:\t"
            output += f"{entry.get('bytes', ''):24} "
            output += f"{entry.get('instruction', '???')}\n"
        
        return output
    
    def get_all_headers_output(self, file_path: Path) -> str:
        """Get all headers output in objdump format"""
        result = self.analyze_file(file_path)
        
        if "error" in result:
            return f"objdump: {result['error']}"
        
        output = self.get_file_headers_output(file_path)
        output += "\n" + self.get_section_headers_output(file_path)
        
        # Add program headers for ELF files
        if result.get("file_format") == "elf":
            program_headers = result.get("program_headers", [])
            if program_headers:
                output += "\nProgram Header:\n"
                for ph in program_headers:
                    output += f"    {ph.get('type', 'UNKNOWN'):8} "
                    output += f"off    {ph.get('offset', '0x0'):8} "
                    output += f"vaddr  {ph.get('virtual_address', '0x0'):8} "
                    output += f"paddr  {ph.get('physical_address', '0x0'):8} "
                    output += f"align 2**{ph.get('alignment', 0).bit_length() - 1 if ph.get('alignment', 0) > 0 else 0}\n"
                    output += f"         filesz {ph.get('file_size', 0):8x} "
                    output += f"memsz  {ph.get('memory_size', 0):8x} "
                    output += f"flags {ph.get('flags', 'NONE')}\n"
        
        return output