"""
ReverseGod Built-in File Type Detection Tool
Custom implementation of 'file' command functionality
"""

import struct
from pathlib import Path
from typing import Dict, Any, List, Tuple
import re

class RGFile:
    """Built-in file type detection tool"""
    
    def __init__(self):
        self.magic_signatures = self._load_magic_signatures()
    
    def identify_file(self, file_path: Path) -> Dict[str, Any]:
        """Identify file type and characteristics"""
        try:
            with open(file_path, 'rb') as f:
                data = f.read(8192)  # Read first 8KB for analysis
            
            if not data:
                return {
                    "file_type": "empty file",
                    "mime_type": "inode/x-empty",
                    "description": "empty",
                    "confidence": 100
                }
            
            # Check magic signatures
            for signature in self.magic_signatures:
                if self._matches_signature(data, signature):
                    return signature
            
            # Fallback analysis
            return self._analyze_unknown_file(data, file_path)
            
        except Exception as e:
            return {
                "file_type": "cannot open",
                "mime_type": "application/octet-stream",
                "description": f"cannot open ({str(e)})",
                "confidence": 0
            }
    
    def _load_magic_signatures(self) -> List[Dict[str, Any]]:
        """Load magic byte signatures for file type detection"""
        return [
            # Executable formats
            {
                "magic": b'\x7fELF',
                "offset": 0,
                "file_type": "ELF",
                "mime_type": "application/x-executable",
                "description": "ELF executable",
                "confidence": 95,
                "analyzer": self._analyze_elf
            },
            {
                "magic": b'MZ',
                "offset": 0,
                "file_type": "PE",
                "mime_type": "application/x-dosexec",
                "description": "MS-DOS executable",
                "confidence": 90,
                "analyzer": self._analyze_pe
            },
            {
                "magic": b'\xfe\xed\xfa\xce',
                "offset": 0,
                "file_type": "Mach-O",
                "mime_type": "application/x-mach-binary",
                "description": "Mach-O executable (32-bit big endian)",
                "confidence": 95,
                "analyzer": self._analyze_macho
            },
            {
                "magic": b'\xce\xfa\xed\xfe',
                "offset": 0,
                "file_type": "Mach-O",
                "mime_type": "application/x-mach-binary",
                "description": "Mach-O executable (32-bit little endian)",
                "confidence": 95,
                "analyzer": self._analyze_macho
            },
            {
                "magic": b'\xfe\xed\xfa\xcf',
                "offset": 0,
                "file_type": "Mach-O",
                "mime_type": "application/x-mach-binary",
                "description": "Mach-O executable (64-bit big endian)",
                "confidence": 95,
                "analyzer": self._analyze_macho
            },
            {
                "magic": b'\xcf\xfa\xed\xfe',
                "offset": 0,
                "file_type": "Mach-O",
                "mime_type": "application/x-mach-binary",
                "description": "Mach-O executable (64-bit little endian)",
                "confidence": 95,
                "analyzer": self._analyze_macho
            },
            
            # Archive formats
            {
                "magic": b'PK\x03\x04',
                "offset": 0,
                "file_type": "ZIP",
                "mime_type": "application/zip",
                "description": "ZIP archive",
                "confidence": 90,
                "analyzer": None
            },
            {
                "magic": b'Rar!\x1a\x07\x00',
                "offset": 0,
                "file_type": "RAR",
                "mime_type": "application/x-rar-compressed",
                "description": "RAR archive",
                "confidence": 95,
                "analyzer": None
            },
            {
                "magic": b'\x1f\x8b\x08',
                "offset": 0,
                "file_type": "GZIP",
                "mime_type": "application/gzip",
                "description": "gzip compressed data",
                "confidence": 90,
                "analyzer": None
            },
            
            # Image formats
            {
                "magic": b'\x89PNG\r\n\x1a\n',
                "offset": 0,
                "file_type": "PNG",
                "mime_type": "image/png",
                "description": "PNG image data",
                "confidence": 100,
                "analyzer": None
            },
            {
                "magic": b'\xff\xd8\xff',
                "offset": 0,
                "file_type": "JPEG",
                "mime_type": "image/jpeg",
                "description": "JPEG image data",
                "confidence": 90,
                "analyzer": None
            },
            {
                "magic": b'GIF8',
                "offset": 0,
                "file_type": "GIF",
                "mime_type": "image/gif",
                "description": "GIF image data",
                "confidence": 95,
                "analyzer": None
            },
            
            # Document formats
            {
                "magic": b'%PDF',
                "offset": 0,
                "file_type": "PDF",
                "mime_type": "application/pdf",
                "description": "PDF document",
                "confidence": 100,
                "analyzer": None
            },
            
            # Script files
            {
                "magic": b'#!/bin/sh',
                "offset": 0,
                "file_type": "Shell Script",
                "mime_type": "text/x-shellscript",
                "description": "POSIX shell script",
                "confidence": 100,
                "analyzer": None
            },
            {
                "magic": b'#!/bin/bash',
                "offset": 0,
                "file_type": "Bash Script",
                "mime_type": "text/x-shellscript",
                "description": "Bash shell script",
                "confidence": 100,
                "analyzer": None
            },
            {
                "magic": b'#!/usr/bin/python',
                "offset": 0,
                "file_type": "Python Script",
                "mime_type": "text/x-python",
                "description": "Python script",
                "confidence": 100,
                "analyzer": None
            },
        ]
    
    def _matches_signature(self, data: bytes, signature: Dict[str, Any]) -> bool:
        """Check if data matches a magic signature"""
        magic = signature["magic"]
        offset = signature.get("offset", 0)
        
        if len(data) < offset + len(magic):
            return False
        
        return data[offset:offset + len(magic)] == magic
    
    def _analyze_elf(self, data: bytes) -> Dict[str, Any]:
        """Analyze ELF file details"""
        if len(data) < 64:  # Minimum ELF header size
            return {}
        
        try:
            # ELF header analysis
            ei_class = data[4]  # 32/64 bit
            ei_data = data[5]   # Endianness
            e_type = struct.unpack('<H' if ei_data == 1 else '>H', data[16:18])[0]
            e_machine = struct.unpack('<H' if ei_data == 1 else '>H', data[18:20])[0]
            
            # Determine architecture
            arch_map = {
                0x03: "i386",
                0x3E: "x86-64",
                0x28: "ARM",
                0xB7: "AArch64",
                0x08: "MIPS",
                0x14: "PowerPC"
            }
            
            # Determine file type
            type_map = {
                1: "relocatable",
                2: "executable",
                3: "shared object",
                4: "core dump"
            }
            
            arch = arch_map.get(e_machine, f"unknown (0x{e_machine:x})")
            file_type = type_map.get(e_type, f"unknown type (0x{e_type:x})")
            bits = "64-bit" if ei_class == 2 else "32-bit"
            endian = "LSB" if ei_data == 1 else "MSB"
            
            description = f"ELF {bits} {endian} {file_type}, {arch}"
            
            return {
                "file_type": "ELF",
                "mime_type": "application/x-executable",
                "description": description,
                "confidence": 95,
                "details": {
                    "architecture": arch,
                    "bits": bits,
                    "endianness": endian,
                    "type": file_type,
                    "machine": e_machine
                }
            }
            
        except Exception:
            return {
                "file_type": "ELF",
                "mime_type": "application/x-executable",
                "description": "ELF executable (corrupted header)",
                "confidence": 70
            }
    
    def _analyze_pe(self, data: bytes) -> Dict[str, Any]:
        """Analyze PE file details"""
        try:
            # Check for PE signature
            if len(data) < 64:
                return {
                    "file_type": "PE",
                    "mime_type": "application/x-dosexec",
                    "description": "MS-DOS executable",
                    "confidence": 80
                }
            
            # Get PE header offset
            pe_offset = struct.unpack('<I', data[60:64])[0]
            
            if len(data) < pe_offset + 24:
                return {
                    "file_type": "PE",
                    "mime_type": "application/x-dosexec",
                    "description": "MS-DOS executable",
                    "confidence": 80
                }
            
            # Check PE signature
            if data[pe_offset:pe_offset + 4] != b'PE\x00\x00':
                return {
                    "file_type": "PE",
                    "mime_type": "application/x-dosexec",
                    "description": "MS-DOS executable",
                    "confidence": 80
                }
            
            # Get machine type
            machine = struct.unpack('<H', data[pe_offset + 4:pe_offset + 6])[0]
            
            machine_map = {
                0x014c: "i386",
                0x8664: "x86-64",
                0x01c0: "ARM",
                0xaa64: "AArch64"
            }
            
            arch = machine_map.get(machine, f"unknown (0x{machine:x})")
            bits = "64-bit" if machine == 0x8664 else "32-bit"
            
            description = f"PE32+ executable (console) {arch}, for MS Windows"
            
            return {
                "file_type": "PE",
                "mime_type": "application/x-dosexec",
                "description": description,
                "confidence": 90,
                "details": {
                    "architecture": arch,
                    "bits": bits,
                    "machine": machine
                }
            }
            
        except Exception:
            return {
                "file_type": "PE",
                "mime_type": "application/x-dosexec",
                "description": "MS-DOS executable (corrupted header)",
                "confidence": 70
            }
    
    def _analyze_macho(self, data: bytes) -> Dict[str, Any]:
        """Analyze Mach-O file details"""
        try:
            if len(data) < 28:
                return {}
            
            # Determine endianness from magic
            magic = data[:4]
            if magic in [b'\xfe\xed\xfa\xce', b'\xfe\xed\xfa\xcf']:
                endian = '>'  # Big endian
                endian_desc = "big endian"
            else:
                endian = '<'  # Little endian
                endian_desc = "little endian"
            
            # Get CPU type
            cputype = struct.unpack(endian + 'I', data[4:8])[0]
            
            cpu_map = {
                7: "i386",
                0x01000007: "x86-64",
                12: "ARM",
                0x0100000c: "AArch64"
            }
            
            arch = cpu_map.get(cputype, f"unknown (0x{cputype:x})")
            bits = "64-bit" if magic in [b'\xfe\xed\xfa\xcf', b'\xcf\xfa\xed\xfe'] else "32-bit"
            
            description = f"Mach-O {bits} executable {arch} ({endian_desc})"
            
            return {
                "file_type": "Mach-O",
                "mime_type": "application/x-mach-binary",
                "description": description,
                "confidence": 95,
                "details": {
                    "architecture": arch,
                    "bits": bits,
                    "endianness": endian_desc,
                    "cputype": cputype
                }
            }
            
        except Exception:
            return {
                "file_type": "Mach-O",
                "mime_type": "application/x-mach-binary",
                "description": "Mach-O executable (corrupted header)",
                "confidence": 70
            }
    
    def _analyze_unknown_file(self, data: bytes, file_path: Path) -> Dict[str, Any]:
        """Analyze unknown file type"""
        # Check if it's text
        if self._is_text_file(data):
            return {
                "file_type": "Text",
                "mime_type": "text/plain",
                "description": f"ASCII text",
                "confidence": 80
            }
        
        # Check if it's binary data
        return {
            "file_type": "Binary",
            "mime_type": "application/octet-stream",
            "description": "data",
            "confidence": 50
        }
    
    def _is_text_file(self, data: bytes) -> bool:
        """Check if file appears to be text"""
        try:
            # Try to decode as UTF-8
            text = data.decode('utf-8')
            
            # Check for high ratio of printable characters
            printable_chars = sum(1 for c in text if c.isprintable() or c.isspace())
            ratio = printable_chars / len(text) if text else 0
            
            return ratio > 0.8
            
        except UnicodeDecodeError:
            # Try ASCII
            try:
                text = data.decode('ascii')
                printable_chars = sum(1 for c in text if ord(c) < 128 and (c.isprintable() or c.isspace()))
                ratio = printable_chars / len(text) if text else 0
                return ratio > 0.8
            except UnicodeDecodeError:
                return False
    
    def get_file_info(self, file_path: Path, brief: bool = False) -> str:
        """Get file information in format similar to 'file' command"""
        result = self.identify_file(file_path)
        
        if brief:
            return result.get("description", "data")
        else:
            return f"{file_path}: {result.get('description', 'data')}"