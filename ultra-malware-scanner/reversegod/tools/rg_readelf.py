"""
ReverseGod Built-in ELF Reader Tool
Custom implementation of 'readelf' command functionality
"""

import struct
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from enum import IntEnum

class ELFClass(IntEnum):
    ELFCLASS32 = 1
    ELFCLASS64 = 2

class ELFData(IntEnum):
    ELFDATA2LSB = 1  # Little endian
    ELFDATA2MSB = 2  # Big endian

class ELFType(IntEnum):
    ET_NONE = 0    # No file type
    ET_REL = 1     # Relocatable file
    ET_EXEC = 2    # Executable file
    ET_DYN = 3     # Shared object file
    ET_CORE = 4    # Core file

class ELFMachine(IntEnum):
    EM_NONE = 0
    EM_386 = 3      # Intel 80386
    EM_ARM = 40     # ARM
    EM_X86_64 = 62  # AMD x86-64
    EM_AARCH64 = 183 # ARM 64-bit

class RGReadElf:
    """Built-in ELF file reader and analyzer"""
    
    def __init__(self):
        self.elf_data = None
        self.header = None
        self.is_64bit = False
        self.is_little_endian = True
        self.endian_char = '<'
    
    def analyze_elf(self, file_path: Path) -> Dict[str, Any]:
        """Analyze ELF file and return comprehensive information"""
        try:
            with open(file_path, 'rb') as f:
                self.elf_data = f.read()
            
            if not self._is_elf_file():
                return {"error": "Not an ELF file"}
            
            # Parse ELF header
            header_info = self._parse_elf_header()
            if not header_info:
                return {"error": "Failed to parse ELF header"}
            
            # Parse sections
            sections_info = self._parse_sections()
            
            # Parse program headers
            program_headers_info = self._parse_program_headers()
            
            # Parse symbols
            symbols_info = self._parse_symbols()
            
            # Parse dynamic section
            dynamic_info = self._parse_dynamic_section()
            
            return {
                "file_path": str(file_path),
                "header": header_info,
                "sections": sections_info,
                "program_headers": program_headers_info,
                "symbols": symbols_info,
                "dynamic": dynamic_info,
                "analysis_complete": True
            }
            
        except Exception as e:
            return {"error": f"ELF analysis failed: {str(e)}"}
    
    def _is_elf_file(self) -> bool:
        """Check if file is ELF format"""
        return (len(self.elf_data) >= 4 and 
                self.elf_data[:4] == b'\x7fELF')
    
    def _parse_elf_header(self) -> Optional[Dict[str, Any]]:
        """Parse ELF header"""
        if len(self.elf_data) < 64:  # Minimum header size
            return None
        
        try:
            # ELF identification
            ei_class = self.elf_data[4]
            ei_data = self.elf_data[5]
            ei_version = self.elf_data[6]
            ei_osabi = self.elf_data[7]
            ei_abiversion = self.elf_data[8]
            
            self.is_64bit = (ei_class == ELFClass.ELFCLASS64)
            self.is_little_endian = (ei_data == ELFData.ELFDATA2LSB)
            self.endian_char = '<' if self.is_little_endian else '>'
            
            # Parse rest of header based on architecture
            if self.is_64bit:
                header_format = self.endian_char + 'HHIQQQIHHHHHH'
                header_size = 64
            else:
                header_format = self.endian_char + 'HHIIIIIHHHHHH'
                header_size = 52
            
            if len(self.elf_data) < header_size:
                return None
            
            header_data = struct.unpack(header_format, self.elf_data[16:header_size])
            
            if self.is_64bit:
                (e_type, e_machine, e_version, e_entry, e_phoff, e_shoff,
                 e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum, e_shstrndx) = header_data
            else:
                (e_type, e_machine, e_version, e_entry, e_phoff, e_shoff,
                 e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum, e_shstrndx) = header_data
            
            self.header = {
                'e_type': e_type,
                'e_machine': e_machine,
                'e_version': e_version,
                'e_entry': e_entry,
                'e_phoff': e_phoff,
                'e_shoff': e_shoff,
                'e_flags': e_flags,
                'e_ehsize': e_ehsize,
                'e_phentsize': e_phentsize,
                'e_phnum': e_phnum,
                'e_shentsize': e_shentsize,
                'e_shnum': e_shnum,
                'e_shstrndx': e_shstrndx
            }
            
            return {
                "class": "ELF64" if self.is_64bit else "ELF32",
                "data": "2's complement, little endian" if self.is_little_endian else "2's complement, big endian",
                "version": f"{ei_version} (current)",
                "os_abi": self._get_osabi_name(ei_osabi),
                "abi_version": ei_abiversion,
                "type": self._get_type_name(e_type),
                "machine": self._get_machine_name(e_machine),
                "version_num": e_version,
                "entry_point": f"0x{e_entry:x}",
                "program_headers_offset": e_phoff,
                "section_headers_offset": e_shoff,
                "flags": f"0x{e_flags:x}",
                "header_size": e_ehsize,
                "program_header_size": e_phentsize,
                "program_header_count": e_phnum,
                "section_header_size": e_shentsize,
                "section_header_count": e_shnum,
                "section_header_string_index": e_shstrndx
            }
            
        except Exception:
            return None
    
    def _parse_sections(self) -> List[Dict[str, Any]]:
        """Parse ELF sections"""
        if not self.header:
            return []
        
        sections = []
        shoff = self.header['e_shoff']
        shentsize = self.header['e_shentsize']
        shnum = self.header['e_shnum']
        
        if shoff == 0 or shnum == 0:
            return []
        
        try:
            # Get section header string table
            shstrtab = self._get_section_header_string_table()
            
            for i in range(shnum):
                section_offset = shoff + i * shentsize
                
                if section_offset + shentsize > len(self.elf_data):
                    break
                
                if self.is_64bit:
                    format_str = self.endian_char + 'IIQQQQIIQQ'
                    (sh_name, sh_type, sh_flags, sh_addr, sh_offset,
                     sh_size, sh_link, sh_info, sh_addralign, sh_entsize) = struct.unpack(
                        format_str, self.elf_data[section_offset:section_offset + 64])
                else:
                    format_str = self.endian_char + 'IIIIIIIIII'
                    (sh_name, sh_type, sh_flags, sh_addr, sh_offset,
                     sh_size, sh_link, sh_info, sh_addralign, sh_entsize) = struct.unpack(
                        format_str, self.elf_data[section_offset:section_offset + 40])
                
                # Get section name
                section_name = self._get_string_from_table(shstrtab, sh_name) if shstrtab else f"section_{i}"
                
                sections.append({
                    "index": i,
                    "name": section_name,
                    "type": self._get_section_type_name(sh_type),
                    "flags": self._get_section_flags(sh_flags),
                    "address": f"0x{sh_addr:x}",
                    "offset": f"0x{sh_offset:x}",
                    "size": sh_size,
                    "link": sh_link,
                    "info": sh_info,
                    "alignment": sh_addralign,
                    "entry_size": sh_entsize
                })
            
            return sections
            
        except Exception:
            return []
    
    def _parse_program_headers(self) -> List[Dict[str, Any]]:
        """Parse ELF program headers"""
        if not self.header:
            return []
        
        program_headers = []
        phoff = self.header['e_phoff']
        phentsize = self.header['e_phentsize']
        phnum = self.header['e_phnum']
        
        if phoff == 0 or phnum == 0:
            return []
        
        try:
            for i in range(phnum):
                ph_offset = phoff + i * phentsize
                
                if ph_offset + phentsize > len(self.elf_data):
                    break
                
                if self.is_64bit:
                    format_str = self.endian_char + 'IIQQQQQQ'
                    (p_type, p_flags, p_offset, p_vaddr, p_paddr,
                     p_filesz, p_memsz, p_align) = struct.unpack(
                        format_str, self.elf_data[ph_offset:ph_offset + 56])
                else:
                    format_str = self.endian_char + 'IIIIIIII'
                    (p_type, p_offset, p_vaddr, p_paddr, p_filesz,
                     p_memsz, p_flags, p_align) = struct.unpack(
                        format_str, self.elf_data[ph_offset:ph_offset + 32])
                
                program_headers.append({
                    "index": i,
                    "type": self._get_program_type_name(p_type),
                    "flags": self._get_program_flags(p_flags),
                    "offset": f"0x{p_offset:x}",
                    "virtual_address": f"0x{p_vaddr:x}",
                    "physical_address": f"0x{p_paddr:x}",
                    "file_size": p_filesz,
                    "memory_size": p_memsz,
                    "alignment": p_align
                })
            
            return program_headers
            
        except Exception:
            return []
    
    def _parse_symbols(self) -> Dict[str, Any]:
        """Parse ELF symbols"""
        symbols = {
            "symbol_table": [],
            "dynamic_symbols": []
        }
        
        try:
            sections = self._parse_sections()
            
            for section in sections:
                if section["type"] == "SYMTAB":
                    symbols["symbol_table"] = self._parse_symbol_table(section)
                elif section["type"] == "DYNSYM":
                    symbols["dynamic_symbols"] = self._parse_symbol_table(section)
            
            return symbols
            
        except Exception:
            return symbols
    
    def _parse_symbol_table(self, section: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Parse a symbol table section"""
        symbols = []
        
        try:
            offset = int(section["offset"], 16)
            size = section["size"]
            entry_size = section["entry_size"]
            
            if entry_size == 0:
                entry_size = 24 if self.is_64bit else 16
            
            num_symbols = size // entry_size
            
            for i in range(num_symbols):
                sym_offset = offset + i * entry_size
                
                if sym_offset + entry_size > len(self.elf_data):
                    break
                
                if self.is_64bit:
                    format_str = self.endian_char + 'IBBHQQ'
                    (st_name, st_info, st_other, st_shndx, st_value, st_size) = struct.unpack(
                        format_str, self.elf_data[sym_offset:sym_offset + 24])
                else:
                    format_str = self.endian_char + 'IIIBBH'
                    (st_name, st_value, st_size, st_info, st_other, st_shndx) = struct.unpack(
                        format_str, self.elf_data[sym_offset:sym_offset + 16])
                
                # Get symbol name (would need string table)
                symbol_name = f"symbol_{i}"  # Simplified
                
                symbols.append({
                    "index": i,
                    "name": symbol_name,
                    "value": f"0x{st_value:x}",
                    "size": st_size,
                    "type": self._get_symbol_type(st_info & 0xf),
                    "binding": self._get_symbol_binding(st_info >> 4),
                    "visibility": self._get_symbol_visibility(st_other),
                    "section_index": st_shndx
                })
            
            return symbols[:100]  # Limit output
            
        except Exception:
            return []
    
    def _parse_dynamic_section(self) -> List[Dict[str, Any]]:
        """Parse dynamic section"""
        dynamic_entries = []
        
        try:
            sections = self._parse_sections()
            
            for section in sections:
                if section["type"] == "DYNAMIC":
                    offset = int(section["offset"], 16)
                    size = section["size"]
                    entry_size = 16 if self.is_64bit else 8
                    
                    num_entries = size // entry_size
                    
                    for i in range(num_entries):
                        entry_offset = offset + i * entry_size
                        
                        if entry_offset + entry_size > len(self.elf_data):
                            break
                        
                        if self.is_64bit:
                            format_str = self.endian_char + 'QQ'
                            d_tag, d_val = struct.unpack(
                                format_str, self.elf_data[entry_offset:entry_offset + 16])
                        else:
                            format_str = self.endian_char + 'II'
                            d_tag, d_val = struct.unpack(
                                format_str, self.elf_data[entry_offset:entry_offset + 8])
                        
                        if d_tag == 0:  # DT_NULL
                            break
                        
                        dynamic_entries.append({
                            "tag": self._get_dynamic_tag_name(d_tag),
                            "value": f"0x{d_val:x}"
                        })
                    
                    break
            
            return dynamic_entries
            
        except Exception:
            return []
    
    def _get_section_header_string_table(self) -> Optional[bytes]:
        """Get section header string table"""
        if not self.header:
            return None
        
        try:
            shstrndx = self.header['e_shstrndx']
            if shstrndx == 0:
                return None
            
            shoff = self.header['e_shoff']
            shentsize = self.header['e_shentsize']
            
            section_offset = shoff + shstrndx * shentsize
            
            if self.is_64bit:
                format_str = self.endian_char + 'IIQQQQIIQQ'
                sh_offset_idx = 4
                sh_size_idx = 5
            else:
                format_str = self.endian_char + 'IIIIIIIIII'
                sh_offset_idx = 4
                sh_size_idx = 5
            
            section_data = struct.unpack(format_str, 
                self.elf_data[section_offset:section_offset + shentsize])
            
            str_offset = section_data[sh_offset_idx]
            str_size = section_data[sh_size_idx]
            
            return self.elf_data[str_offset:str_offset + str_size]
            
        except Exception:
            return None
    
    def _get_string_from_table(self, string_table: bytes, offset: int) -> str:
        """Get string from string table"""
        try:
            if offset >= len(string_table):
                return ""
            
            end = string_table.find(b'\x00', offset)
            if end == -1:
                end = len(string_table)
            
            return string_table[offset:end].decode('utf-8', errors='ignore')
            
        except Exception:
            return ""
    
    # Helper methods for name lookups
    def _get_osabi_name(self, osabi: int) -> str:
        osabi_names = {
            0: "UNIX - System V",
            1: "HP-UX",
            2: "NetBSD",
            3: "Linux",
            6: "Solaris",
            7: "AIX",
            8: "IRIX",
            9: "FreeBSD",
            10: "Tru64",
            11: "Novell Modesto",
            12: "OpenBSD"
        }
        return osabi_names.get(osabi, f"Unknown (0x{osabi:x})")
    
    def _get_type_name(self, e_type: int) -> str:
        type_names = {
            0: "NONE (No file type)",
            1: "REL (Relocatable file)",
            2: "EXEC (Executable file)",
            3: "DYN (Shared object file)",
            4: "CORE (Core file)"
        }
        return type_names.get(e_type, f"Unknown (0x{e_type:x})")
    
    def _get_machine_name(self, machine: int) -> str:
        machine_names = {
            0: "No machine",
            3: "Intel 80386",
            40: "ARM",
            62: "Advanced Micro Devices X86-64",
            183: "ARM AARCH64"
        }
        return machine_names.get(machine, f"Unknown (0x{machine:x})")
    
    def _get_section_type_name(self, sh_type: int) -> str:
        type_names = {
            0: "NULL",
            1: "PROGBITS",
            2: "SYMTAB",
            3: "STRTAB",
            4: "RELA",
            5: "HASH",
            6: "DYNAMIC",
            7: "NOTE",
            8: "NOBITS",
            9: "REL",
            10: "SHLIB",
            11: "DYNSYM"
        }
        return type_names.get(sh_type, f"UNKNOWN (0x{sh_type:x})")
    
    def _get_section_flags(self, flags: int) -> str:
        flag_names = []
        if flags & 0x1: flag_names.append("WRITE")
        if flags & 0x2: flag_names.append("ALLOC")
        if flags & 0x4: flag_names.append("EXEC")
        return " | ".join(flag_names) if flag_names else "NONE"
    
    def _get_program_type_name(self, p_type: int) -> str:
        type_names = {
            0: "NULL",
            1: "LOAD",
            2: "DYNAMIC",
            3: "INTERP",
            4: "NOTE",
            5: "SHLIB",
            6: "PHDR"
        }
        return type_names.get(p_type, f"UNKNOWN (0x{p_type:x})")
    
    def _get_program_flags(self, flags: int) -> str:
        flag_names = []
        if flags & 0x1: flag_names.append("EXEC")
        if flags & 0x2: flag_names.append("WRITE")
        if flags & 0x4: flag_names.append("READ")
        return " | ".join(flag_names) if flag_names else "NONE"
    
    def _get_symbol_type(self, st_type: int) -> str:
        type_names = {
            0: "NOTYPE",
            1: "OBJECT",
            2: "FUNC",
            3: "SECTION",
            4: "FILE"
        }
        return type_names.get(st_type, f"UNKNOWN ({st_type})")
    
    def _get_symbol_binding(self, st_bind: int) -> str:
        bind_names = {
            0: "LOCAL",
            1: "GLOBAL",
            2: "WEAK"
        }
        return bind_names.get(st_bind, f"UNKNOWN ({st_bind})")
    
    def _get_symbol_visibility(self, st_other: int) -> str:
        vis_names = {
            0: "DEFAULT",
            1: "INTERNAL",
            2: "HIDDEN",
            3: "PROTECTED"
        }
        return vis_names.get(st_other & 0x3, f"UNKNOWN ({st_other & 0x3})")
    
    def _get_dynamic_tag_name(self, tag: int) -> str:
        tag_names = {
            0: "NULL",
            1: "NEEDED",
            2: "PLTRELSZ",
            3: "PLTGOT",
            4: "HASH",
            5: "STRTAB",
            6: "SYMTAB",
            7: "RELA",
            8: "RELASZ",
            9: "RELAENT",
            10: "STRSZ",
            11: "SYMENT",
            12: "INIT",
            13: "FINI",
            14: "SONAME",
            15: "RPATH"
        }
        return tag_names.get(tag, f"UNKNOWN (0x{tag:x})")
    
    def get_header_output(self, file_path: Path) -> str:
        """Get ELF header output in readelf format"""
        result = self.analyze_elf(file_path)
        
        if "error" in result:
            return f"readelf: Error: {result['error']}"
        
        header = result.get("header", {})
        
        output = f"ELF Header:\n"
        output += f"  Magic:   7f 45 4c 46\n"
        output += f"  Class:                             {header.get('class', 'Unknown')}\n"
        output += f"  Data:                              {header.get('data', 'Unknown')}\n"
        output += f"  Version:                           {header.get('version', 'Unknown')}\n"
        output += f"  OS/ABI:                            {header.get('os_abi', 'Unknown')}\n"
        output += f"  ABI Version:                       {header.get('abi_version', 0)}\n"
        output += f"  Type:                              {header.get('type', 'Unknown')}\n"
        output += f"  Machine:                           {header.get('machine', 'Unknown')}\n"
        output += f"  Version:                           {header.get('version_num', 0)}\n"
        output += f"  Entry point address:               {header.get('entry_point', '0x0')}\n"
        output += f"  Start of program headers:          {header.get('program_headers_offset', 0)} (bytes into file)\n"
        output += f"  Start of section headers:          {header.get('section_headers_offset', 0)} (bytes into file)\n"
        output += f"  Flags:                             {header.get('flags', '0x0')}\n"
        output += f"  Size of this header:               {header.get('header_size', 0)} (bytes)\n"
        output += f"  Size of program headers:           {header.get('program_header_size', 0)} (bytes)\n"
        output += f"  Number of program headers:         {header.get('program_header_count', 0)}\n"
        output += f"  Size of section headers:           {header.get('section_header_size', 0)} (bytes)\n"
        output += f"  Number of section headers:         {header.get('section_header_count', 0)}\n"
        output += f"  Section header string table index: {header.get('section_header_string_index', 0)}\n"
        
        return output