"""
ReverseGod Built-in Hex Dump Tool
Custom implementation of 'xxd' and 'hexdump' command functionality
"""

from pathlib import Path
from typing import Dict, Any, List, Optional, Iterator
import string

class RGHexdump:
    """Built-in hex dump tool with xxd and hexdump compatibility"""
    
    def __init__(self):
        self.printable_chars = set(string.printable) - set(string.whitespace) | {' '}
    
    def xxd_format(self, file_path: Path, length: Optional[int] = None, 
                   offset: int = 0, cols: int = 16) -> str:
        """Generate hex dump in xxd format"""
        try:
            with open(file_path, 'rb') as f:
                f.seek(offset)
                data = f.read(length) if length else f.read()
            
            if not data:
                return ""
            
            output_lines = []
            
            for i in range(0, len(data), cols):
                chunk = data[i:i + cols]
                addr = offset + i
                
                # Address
                line = f"{addr:08x}: "
                
                # Hex bytes
                hex_parts = []
                for j in range(0, cols, 2):
                    if j < len(chunk):
                        if j + 1 < len(chunk):
                            hex_parts.append(f"{chunk[j]:02x}{chunk[j+1]:02x}")
                        else:
                            hex_parts.append(f"{chunk[j]:02x}  ")
                    else:
                        hex_parts.append("    ")
                
                line += " ".join(hex_parts)
                
                # Pad hex section to fixed width
                hex_width = (cols // 2) * 5 - 1  # 4 chars per pair + space, minus last space
                current_hex_width = len(" ".join(hex_parts))
                line += " " * (hex_width - current_hex_width)
                
                # ASCII representation
                line += "  "
                ascii_repr = ""
                for byte in chunk:
                    if chr(byte) in self.printable_chars:
                        ascii_repr += chr(byte)
                    else:
                        ascii_repr += "."
                
                line += ascii_repr
                output_lines.append(line)
            
            return "\n".join(output_lines)
            
        except Exception as e:
            return f"xxd: {str(e)}"
    
    def hexdump_canonical(self, file_path: Path, length: Optional[int] = None, 
                         offset: int = 0) -> str:
        """Generate hex dump in canonical hexdump format (-C option)"""
        try:
            with open(file_path, 'rb') as f:
                f.seek(offset)
                data = f.read(length) if length else f.read()
            
            if not data:
                return ""
            
            output_lines = []
            
            for i in range(0, len(data), 16):
                chunk = data[i:i + 16]
                addr = offset + i
                
                # Address
                line = f"{addr:08x}  "
                
                # First 8 bytes
                hex_part1 = " ".join(f"{b:02x}" for b in chunk[:8])
                line += f"{hex_part1:<23} "
                
                # Second 8 bytes
                if len(chunk) > 8:
                    hex_part2 = " ".join(f"{b:02x}" for b in chunk[8:16])
                    line += f"{hex_part2:<23} "
                else:
                    line += " " * 24
                
                # ASCII representation
                line += " |"
                for byte in chunk:
                    if 32 <= byte <= 126:  # Printable ASCII
                        line += chr(byte)
                    else:
                        line += "."
                line += "|"
                
                output_lines.append(line)
            
            # Add final address line
            if data:
                final_addr = offset + len(data)
                output_lines.append(f"{final_addr:08x}")
            
            return "\n".join(output_lines)
            
        except Exception as e:
            return f"hexdump: {str(e)}"
    
    def hexdump_octal(self, file_path: Path, length: Optional[int] = None, 
                     offset: int = 0) -> str:
        """Generate hex dump in octal format"""
        try:
            with open(file_path, 'rb') as f:
                f.seek(offset)
                data = f.read(length) if length else f.read()
            
            if not data:
                return ""
            
            output_lines = []
            
            for i in range(0, len(data), 16):
                chunk = data[i:i + 16]
                addr = offset + i
                
                line = f"{addr:07o} "
                
                # Octal bytes
                octal_parts = []
                for j in range(0, len(chunk), 2):
                    if j + 1 < len(chunk):
                        # Combine two bytes in little-endian order
                        word = chunk[j] | (chunk[j + 1] << 8)
                        octal_parts.append(f"{word:06o}")
                    elif j < len(chunk):
                        octal_parts.append(f"{chunk[j]:06o}")
                
                line += " ".join(octal_parts)
                output_lines.append(line)
            
            return "\n".join(output_lines)
            
        except Exception as e:
            return f"hexdump: {str(e)}"
    
    def analyze_hex_patterns(self, file_path: Path, max_bytes: int = 4096) -> Dict[str, Any]:
        """Analyze hex patterns in file"""
        try:
            with open(file_path, 'rb') as f:
                data = f.read(max_bytes)
            
            if not data:
                return {"error": "Empty file"}
            
            analysis = {
                "file_size": len(data),
                "entropy": self._calculate_entropy(data),
                "magic_bytes": self._identify_magic_bytes(data),
                "byte_frequency": self._calculate_byte_frequency(data),
                "patterns": self._find_patterns(data),
                "strings_preview": self._extract_string_preview(data)
            }
            
            return analysis
            
        except Exception as e:
            return {"error": f"Analysis failed: {str(e)}"}
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0.0
        
        # Count byte frequencies
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # Calculate entropy
        entropy = 0.0
        data_len = len(data)
        
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * (probability.bit_length() - 1)
        
        return entropy
    
    def _identify_magic_bytes(self, data: bytes) -> List[Dict[str, Any]]:
        """Identify magic byte signatures"""
        magic_signatures = [
            (b'\x7fELF', 0, "ELF executable"),
            (b'MZ', 0, "PE/DOS executable"),
            (b'PK\x03\x04', 0, "ZIP archive"),
            (b'\x89PNG\r\n\x1a\n', 0, "PNG image"),
            (b'\xff\xd8\xff', 0, "JPEG image"),
            (b'GIF8', 0, "GIF image"),
            (b'%PDF', 0, "PDF document"),
            (b'\x1f\x8b\x08', 0, "GZIP compressed"),
            (b'Rar!\x1a\x07\x00', 0, "RAR archive"),
            (b'\xfe\xed\xfa\xce', 0, "Mach-O (32-bit BE)"),
            (b'\xce\xfa\xed\xfe', 0, "Mach-O (32-bit LE)"),
            (b'\xfe\xed\xfa\xcf', 0, "Mach-O (64-bit BE)"),
            (b'\xcf\xfa\xed\xfe', 0, "Mach-O (64-bit LE)"),
        ]
        
        found_signatures = []
        
        for signature, offset, description in magic_signatures:
            if len(data) >= offset + len(signature):
                if data[offset:offset + len(signature)] == signature:
                    found_signatures.append({
                        "signature": signature.hex(),
                        "offset": offset,
                        "description": description
                    })
        
        return found_signatures
    
    def _calculate_byte_frequency(self, data: bytes) -> Dict[str, int]:
        """Calculate frequency of each byte value"""
        frequency = {}
        
        for byte in data:
            frequency[f"0x{byte:02x}"] = frequency.get(f"0x{byte:02x}", 0) + 1
        
        # Return top 10 most frequent bytes
        sorted_freq = sorted(frequency.items(), key=lambda x: x[1], reverse=True)
        return dict(sorted_freq[:10])
    
    def _find_patterns(self, data: bytes) -> List[Dict[str, Any]]:
        """Find repeating patterns in data"""
        patterns = []
        
        # Look for repeating byte sequences
        common_patterns = [
            (b'\x00' * 4, "NULL padding"),
            (b'\xff' * 4, "0xFF padding"),
            (b'\x90' * 4, "NOP sled (x86)"),
            (b'\xcc' * 4, "INT3 padding"),
            (b'AAAA', "Test pattern A"),
            (b'BBBB', "Test pattern B"),
        ]
        
        for pattern, description in common_patterns:
            count = data.count(pattern)
            if count > 0:
                first_offset = data.find(pattern)
                patterns.append({
                    "pattern": pattern.hex(),
                    "description": description,
                    "count": count,
                    "first_offset": first_offset
                })
        
        return patterns
    
    def _extract_string_preview(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract preview of strings from data"""
        strings = []
        current_string = ""
        
        for byte in data:
            if 32 <= byte <= 126:  # Printable ASCII
                current_string += chr(byte)
            else:
                if len(current_string) >= min_length:
                    strings.append(current_string)
                current_string = ""
        
        # Don't forget the last string
        if len(current_string) >= min_length:
            strings.append(current_string)
        
        return strings[:10]  # Return first 10 strings
    
    def create_hex_diff(self, file1_path: Path, file2_path: Path, 
                       context_bytes: int = 16) -> str:
        """Create hex diff between two files"""
        try:
            with open(file1_path, 'rb') as f1, open(file2_path, 'rb') as f2:
                data1 = f1.read()
                data2 = f2.read()
            
            max_len = max(len(data1), len(data2))
            
            # Pad shorter data with zeros
            if len(data1) < max_len:
                data1 += b'\x00' * (max_len - len(data1))
            if len(data2) < max_len:
                data2 += b'\x00' * (max_len - len(data2))
            
            diff_lines = []
            diff_lines.append(f"--- {file1_path}")
            diff_lines.append(f"+++ {file2_path}")
            
            i = 0
            while i < max_len:
                # Find next difference
                while i < max_len and data1[i] == data2[i]:
                    i += 1
                
                if i >= max_len:
                    break
                
                # Found difference, show context
                start = max(0, i - context_bytes)
                end = min(max_len, i + context_bytes)
                
                diff_lines.append(f"@@ -{start:x},{end-start:x} +{start:x},{end-start:x} @@")
                
                # Show differing bytes
                for j in range(start, end):
                    if j < len(data1) and j < len(data2):
                        if data1[j] != data2[j]:
                            diff_lines.append(f"-{j:08x}: {data1[j]:02x}")
                            diff_lines.append(f"+{j:08x}: {data2[j]:02x}")
                        else:
                            diff_lines.append(f" {j:08x}: {data1[j]:02x}")
                
                i = end
            
            return "\n".join(diff_lines)
            
        except Exception as e:
            return f"hex diff error: {str(e)}"
    
    def get_xxd_output(self, file_path: Path, length: Optional[int] = None, 
                      offset: int = 0, cols: int = 16) -> str:
        """Get output in xxd format (main interface)"""
        return self.xxd_format(file_path, length, offset, cols)
    
    def get_hexdump_output(self, file_path: Path, format_type: str = "canonical", 
                          length: Optional[int] = None, offset: int = 0) -> str:
        """Get output in hexdump format (main interface)"""
        if format_type == "canonical":
            return self.hexdump_canonical(file_path, length, offset)
        elif format_type == "octal":
            return self.hexdump_octal(file_path, length, offset)
        else:
            return self.hexdump_canonical(file_path, length, offset)