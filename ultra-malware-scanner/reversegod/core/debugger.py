"""
Debugger Module
Performs dynamic analysis and debugging with GDB, strace, ltrace, and valgrind
"""

import json
import tempfile
import subprocess
from pathlib import Path
from typing import Dict, Any, List
import time

class Debugger:
    def __init__(self, tool_runner):
        self.tool_runner = tool_runner
        
    def analyze(self, binary_path: Path) -> Dict[str, Any]:
        """Perform comprehensive dynamic analysis"""
        results = {
            "binary_path": str(binary_path),
            "timestamp": self._get_timestamp()
        }
        
        # System call tracing
        results["strace"] = self._run_strace_analysis(binary_path)
        
        # Library call tracing
        results["ltrace"] = self._run_ltrace_analysis(binary_path)
        
        # Memory analysis with Valgrind
        results["valgrind"] = self._run_valgrind_analysis(binary_path)
        
        # GDB automated debugging
        results["gdb"] = self._run_gdb_analysis(binary_path)
        
        return results
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.now().isoformat()
    
    def _run_strace_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Run strace to monitor system calls"""
        try:
            # Basic strace run
            result = self.tool_runner.run_command([
                "strace", "-f", "-e", "trace=all", "-o", "/dev/stdout", 
                str(binary_path)
            ], timeout=30)
            
            if result["success"] or result["stderr"]:  # strace outputs to stderr
                syscalls = self._parse_strace_output(result["stderr"])
                return {
                    "syscalls": syscalls,
                    "raw_output": result["stderr"],
                    "analysis_complete": True
                }
            else:
                return {
                    "error": "strace failed to execute",
                    "stderr": result["stderr"]
                }
                
        except Exception as e:
            return {"error": f"strace analysis exception: {str(e)}"}
    
    def _parse_strace_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse strace output to extract system calls"""
        syscalls = []
        
        for line in output.split('\n'):
            if '(' in line and ')' in line:
                try:
                    # Basic parsing of syscall format: syscall(args) = return
                    parts = line.split('(', 1)
                    if len(parts) >= 2:
                        syscall_name = parts[0].strip().split()[-1]
                        rest = parts[1]
                        
                        if ') = ' in rest:
                            args_part, return_part = rest.split(') = ', 1)
                            syscalls.append({
                                "name": syscall_name,
                                "args": args_part.strip(),
                                "return": return_part.strip(),
                                "raw_line": line.strip()
                            })
                except Exception:
                    continue  # Skip malformed lines
        
        return syscalls[:500]  # Limit to first 500 syscalls
    
    def _run_ltrace_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Run ltrace to monitor library calls"""
        try:
            result = self.tool_runner.run_command([
                "ltrace", "-f", "-e", "*", str(binary_path)
            ], timeout=30)
            
            if result["success"] or result["stderr"]:  # ltrace outputs to stderr
                libcalls = self._parse_ltrace_output(result["stderr"])
                return {
                    "library_calls": libcalls,
                    "raw_output": result["stderr"],
                    "analysis_complete": True
                }
            else:
                return {
                    "error": "ltrace failed to execute",
                    "stderr": result["stderr"]
                }
                
        except Exception as e:
            return {"error": f"ltrace analysis exception: {str(e)}"}
    
    def _parse_ltrace_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse ltrace output to extract library calls"""
        libcalls = []
        
        for line in output.split('\n'):
            if '(' in line and ')' in line:
                try:
                    # Basic parsing similar to strace
                    parts = line.split('(', 1)
                    if len(parts) >= 2:
                        func_name = parts[0].strip().split()[-1]
                        rest = parts[1]
                        
                        if ') = ' in rest:
                            args_part, return_part = rest.split(') = ', 1)
                            libcalls.append({
                                "function": func_name,
                                "args": args_part.strip(),
                                "return": return_part.strip(),
                                "raw_line": line.strip()
                            })
                except Exception:
                    continue
        
        return libcalls[:500]  # Limit to first 500 calls
    
    def _run_valgrind_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Run Valgrind for memory analysis"""
        try:
            # Run with memcheck tool
            result = self.tool_runner.run_command([
                "valgrind", "--tool=memcheck", "--leak-check=full", 
                "--show-leak-kinds=all", "--track-origins=yes",
                str(binary_path)
            ], timeout=60)
            
            if result["success"] or result["stderr"]:
                memory_issues = self._parse_valgrind_output(result["stderr"])
                return {
                    "memory_analysis": memory_issues,
                    "raw_output": result["stderr"],
                    "analysis_complete": True
                }
            else:
                return {
                    "error": "Valgrind failed to execute",
                    "stderr": result["stderr"]
                }
                
        except Exception as e:
            return {"error": f"Valgrind analysis exception: {str(e)}"}
    
    def _parse_valgrind_output(self, output: str) -> Dict[str, Any]:
        """Parse Valgrind output for memory issues"""
        issues = {
            "memory_leaks": [],
            "invalid_reads": [],
            "invalid_writes": [],
            "uninitialized_values": [],
            "summary": {}
        }
        
        current_issue = None
        
        for line in output.split('\n'):
            line = line.strip()
            
            if "definitely lost:" in line or "possibly lost:" in line:
                issues["summary"]["memory_leaks"] = line
            elif "Invalid read" in line:
                issues["invalid_reads"].append(line)
            elif "Invalid write" in line:
                issues["invalid_writes"].append(line)
            elif "Conditional jump" in line and "uninitialised" in line:
                issues["uninitialized_values"].append(line)
            elif "HEAP SUMMARY:" in line:
                issues["summary"]["heap_summary"] = line
        
        return issues
    
    def _run_gdb_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Run automated GDB analysis"""
        try:
            # Create GDB script for automated analysis
            gdb_script = self._create_gdb_script()
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as script_file:
                script_file.write(gdb_script)
                script_path = script_file.name
            
            try:
                # Run GDB with script
                result = self.tool_runner.run_command([
                    "gdb", "-batch", "-x", script_path, str(binary_path)
                ], timeout=120)
                
                if result["success"]:
                    return self._parse_gdb_output(result["stdout"])
                else:
                    return {
                        "error": "GDB analysis failed",
                        "stderr": result["stderr"]
                    }
            finally:
                Path(script_path).unlink(missing_ok=True)
                
        except Exception as e:
            return {"error": f"GDB analysis exception: {str(e)}"}
    
    def _create_gdb_script(self) -> str:
        """Create GDB analysis script"""
        return """
# GDB automated analysis script
set pagination off
set confirm off

echo === BINARY INFO ===\\n
info file
echo \\n=== FUNCTIONS ===\\n
info functions
echo \\n=== VARIABLES ===\\n
info variables
echo \\n=== REGISTERS ===\\n
info registers
echo \\n=== MEMORY MAPPINGS ===\\n
info proc mappings
echo \\n=== SHARED LIBRARIES ===\\n
info sharedlibrary

# Try to run and get basic execution info
echo \\n=== EXECUTION ATTEMPT ===\\n
run
bt
info registers

quit
"""
    
    def _parse_gdb_output(self, output: str) -> Dict[str, Any]:
        """Parse GDB output into structured data"""
        sections = {}
        current_section = None
        current_content = []
        
        for line in output.split('\n'):
            if line.startswith('=== ') and line.endswith(' ==='):
                if current_section:
                    sections[current_section] = '\n'.join(current_content)
                current_section = line.strip('= ')
                current_content = []
            else:
                current_content.append(line)
        
        if current_section:
            sections[current_section] = '\n'.join(current_content)
        
        return {
            "analysis_complete": True,
            "sections": sections,
            "raw_output": output
        }