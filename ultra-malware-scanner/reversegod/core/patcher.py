"""
Patcher Module
Simulates binary modification and hex editing for analysis reporting
"""

import tempfile
import shutil
from pathlib import Path
from typing import Dict, Any, List
import subprocess

class Patcher:
    def __init__(self, tool_runner):
        self.tool_runner = tool_runner
        
    def analyze(self, binary_path: Path) -> Dict[str, Any]:
        """Perform binary modification analysis and simulation"""
        results = {
            "binary_path": str(binary_path),
            "timestamp": self._get_timestamp()
        }
        
        # Hex dump analysis
        results["hex_analysis"] = self._generate_hex_analysis(binary_path)
        
        # Radare2 patching simulation
        results["r2_patch_simulation"] = self._simulate_r2_patching(binary_path)
        
        # Binary structure analysis for patching opportunities
        results["patch_opportunities"] = self._analyze_patch_opportunities(binary_path)
        
        # Entry point analysis
        results["entry_point_analysis"] = self._analyze_entry_points(binary_path)
        
        return results
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.now().isoformat()
    
    def _generate_hex_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Generate comprehensive hex dump and analysis"""
        try:
            # Generate hex dump with xxd
            xxd_result = self.tool_runner.run_command([
                "xxd", "-l", "2048", str(binary_path)  # First 2KB
            ])
            
            # Generate hex dump with hexdump as fallback
            hexdump_result = self.tool_runner.run_command([
                "hexdump", "-C", "-n", "2048", str(binary_path)
            ])
            
            # Analyze hex patterns
            hex_patterns = self._analyze_hex_patterns(binary_path)
            
            return {
                "xxd_output": xxd_result["stdout"] if xxd_result["success"] else None,
                "hexdump_output": hexdump_result["stdout"] if hexdump_result["success"] else None,
                "patterns": hex_patterns,
                "analysis_complete": True
            }
            
        except Exception as e:
            return {"error": f"Hex analysis exception: {str(e)}"}
    
    def _analyze_hex_patterns(self, binary_path: Path) -> Dict[str, Any]:
        """Analyze hex patterns for interesting bytes"""
        patterns = {
            "magic_bytes": [],
            "string_patterns": [],
            "suspicious_patterns": [],
            "entropy_analysis": {}
        }
        
        try:
            with open(binary_path, 'rb') as f:
                data = f.read(4096)  # First 4KB
            
            # Look for magic bytes
            magic_signatures = {
                b'\x7fELF': 'ELF Header',
                b'MZ': 'PE/DOS Header',
                b'\xfe\xed\xfa\xce': 'Mach-O (32-bit big endian)',
                b'\xce\xfa\xed\xfe': 'Mach-O (32-bit little endian)',
                b'\xfe\xed\xfa\xcf': 'Mach-O (64-bit big endian)',
                b'\xcf\xfa\xed\xfe': 'Mach-O (64-bit little endian)',
                b'PK': 'ZIP/JAR Archive',
                b'\x89PNG': 'PNG Image',
                b'GIF8': 'GIF Image'
            }
            
            for signature, description in magic_signatures.items():
                if signature in data:
                    patterns["magic_bytes"].append({
                        "signature": signature.hex(),
                        "description": description,
                        "offset": data.find(signature)
                    })
            
            # Look for suspicious patterns
            suspicious = [
                b'\x90\x90\x90\x90',  # NOP sled
                b'\xcc\xcc\xcc\xcc',  # INT3 padding
                b'\x00\x00\x00\x00',  # NULL padding
                b'\xff\xff\xff\xff'   # 0xFF padding
            ]
            
            for pattern in suspicious:
                if pattern in data:
                    patterns["suspicious_patterns"].append({
                        "pattern": pattern.hex(),
                        "offset": data.find(pattern),
                        "description": f"Suspicious pattern: {pattern.hex()}"
                    })
            
            # Basic entropy calculation
            if data:
                byte_counts = [0] * 256
                for byte in data:
                    byte_counts[byte] += 1
                
                entropy = 0
                data_len = len(data)
                for count in byte_counts:
                    if count > 0:
                        p = count / data_len
                        entropy -= p * (p.bit_length() - 1)
                
                patterns["entropy_analysis"] = {
                    "entropy": entropy,
                    "assessment": "High" if entropy > 7 else "Medium" if entropy > 5 else "Low"
                }
            
        except Exception as e:
            patterns["error"] = str(e)
        
        return patterns
    
    def _simulate_r2_patching(self, binary_path: Path) -> Dict[str, Any]:
        """Simulate binary patching with Radare2"""
        try:
            # Create r2 script for patch simulation
            r2_script = """
# Open binary for analysis
aaa
# Show entry point
ie
# Show functions that could be patched
afl
# Show strings that could be modified
iz
# Show imports that could be hooked
ii
# Simulate patch analysis - show writable sections
iS~w
# Show relocations
ir
q
"""
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.r2', delete=False) as script_file:
                script_file.write(r2_script)
                script_path = script_file.name
            
            try:
                result = self.tool_runner.run_command([
                    "r2", "-q", "-i", script_path, str(binary_path)
                ])
                
                if result["success"]:
                    return {
                        "patch_simulation": self._parse_r2_patch_output(result["stdout"]),
                        "raw_output": result["stdout"],
                        "analysis_complete": True
                    }
                else:
                    return {
                        "error": "R2 patch simulation failed",
                        "stderr": result["stderr"]
                    }
            finally:
                Path(script_path).unlink(missing_ok=True)
                
        except Exception as e:
            return {"error": f"R2 patch simulation exception: {str(e)}"}
    
    def _parse_r2_patch_output(self, output: str) -> Dict[str, Any]:
        """Parse R2 output for patching opportunities"""
        return {
            "writable_sections": self._extract_writable_sections(output),
            "patchable_functions": self._extract_functions(output),
            "modifiable_strings": self._extract_strings(output),
            "hookable_imports": self._extract_imports(output)
        }
    
    def _extract_writable_sections(self, output: str) -> List[str]:
        """Extract writable sections from R2 output"""
        sections = []
        for line in output.split('\n'):
            if 'w' in line and ('0x' in line or 'section' in line.lower()):
                sections.append(line.strip())
        return sections
    
    def _extract_functions(self, output: str) -> List[str]:
        """Extract function information from R2 output"""
        functions = []
        for line in output.split('\n'):
            if line.startswith('0x') and ('fcn.' in line or 'sym.' in line):
                functions.append(line.strip())
        return functions[:20]  # Limit to first 20
    
    def _extract_strings(self, output: str) -> List[str]:
        """Extract string information from R2 output"""
        strings = []
        for line in output.split('\n'):
            if '0x' in line and ('"' in line or "'" in line):
                strings.append(line.strip())
        return strings[:20]  # Limit to first 20
    
    def _extract_imports(self, output: str) -> List[str]:
        """Extract import information from R2 output"""
        imports = []
        for line in output.split('\n'):
            if 'imp.' in line or 'IMPORT' in line:
                imports.append(line.strip())
        return imports[:20]  # Limit to first 20
    
    def _analyze_patch_opportunities(self, binary_path: Path) -> Dict[str, Any]:
        """Analyze potential patching opportunities"""
        opportunities = {
            "code_caves": [],
            "nop_sequences": [],
            "string_modifications": [],
            "function_hooks": []
        }
        
        try:
            # Look for code caves (sequences of null bytes or NOPs)
            with open(binary_path, 'rb') as f:
                data = f.read()
            
            # Find NOP sequences (0x90 on x86)
            nop_sequences = []
            i = 0
            while i < len(data) - 4:
                if data[i:i+4] == b'\x90\x90\x90\x90':
                    # Found at least 4 NOPs
                    start = i
                    while i < len(data) and data[i] == 0x90:
                        i += 1
                    nop_sequences.append({
                        "offset": hex(start),
                        "length": i - start,
                        "description": f"NOP sequence of {i - start} bytes"
                    })
                else:
                    i += 1
            
            opportunities["nop_sequences"] = nop_sequences[:10]  # Limit to first 10
            
            # Find null byte sequences (potential code caves)
            null_sequences = []
            i = 0
            while i < len(data) - 16:  # Look for caves of at least 16 bytes
                if data[i:i+16] == b'\x00' * 16:
                    start = i
                    while i < len(data) and data[i] == 0x00:
                        i += 1
                    if i - start >= 16:  # Only report caves of 16+ bytes
                        null_sequences.append({
                            "offset": hex(start),
                            "length": i - start,
                            "description": f"Code cave of {i - start} bytes"
                        })
                else:
                    i += 1
            
            opportunities["code_caves"] = null_sequences[:10]  # Limit to first 10
            
        except Exception as e:
            opportunities["error"] = str(e)
        
        return opportunities
    
    def _analyze_entry_points(self, binary_path: Path) -> Dict[str, Any]:
        """Analyze entry points for patching"""
        try:
            # Use readelf for ELF files
            result = self.tool_runner.run_command([
                "readelf", "-h", str(binary_path)
            ])
            
            entry_info = {}
            if result["success"]:
                for line in result["stdout"].split('\n'):
                    if 'Entry point address' in line:
                        entry_info["entry_point"] = line.strip()
                    elif 'Start of program headers' in line:
                        entry_info["program_headers"] = line.strip()
                    elif 'Start of section headers' in line:
                        entry_info["section_headers"] = line.strip()
            
            return {
                "entry_point_info": entry_info,
                "patch_recommendations": self._generate_patch_recommendations(entry_info)
            }
            
        except Exception as e:
            return {"error": f"Entry point analysis exception: {str(e)}"}
    
    def _generate_patch_recommendations(self, entry_info: Dict[str, str]) -> List[str]:
        """Generate patching recommendations based on analysis"""
        recommendations = [
            "Consider hooking main() function for runtime analysis",
            "Entry point could be modified to redirect execution",
            "String literals can be modified for behavior changes",
            "Import table modifications can redirect API calls",
            "Code caves can be used for custom payload injection"
        ]
        
        if entry_info.get("entry_point"):
            recommendations.append(f"Entry point identified: {entry_info['entry_point']}")
        
        return recommendations