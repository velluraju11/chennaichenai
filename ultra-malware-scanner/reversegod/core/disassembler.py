"""
Disassembler Module
Handles static disassembly and decompilation using Ghidra and Radare2
"""

import json
import tempfile
import shutil
from pathlib import Path
from typing import Dict, Any, Optional
import subprocess
import time

class Disassembler:
    def __init__(self, tool_runner):
        self.tool_runner = tool_runner
        
    def analyze(self, binary_path: Path) -> Dict[str, Any]:
        """Perform comprehensive disassembly analysis"""
        results = {
            "binary_path": str(binary_path),
            "timestamp": self._get_timestamp()
        }
        
        # Radare2 analysis
        results["radare2"] = self._run_radare2_analysis(binary_path)
        
        # Ghidra headless analysis
        results["ghidra"] = self._run_ghidra_analysis(binary_path)
        
        # Additional disassembly tools
        results["objdump_disasm"] = self._run_objdump_disassembly(binary_path)
        
        return results
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.now().isoformat()
    
    def _run_radare2_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Run comprehensive Radare2 analysis"""
        try:
            # Create r2 script for automated analysis
            r2_script = self._create_r2_script()
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.r2', delete=False) as script_file:
                script_file.write(r2_script)
                script_path = script_file.name
            
            try:
                # Run r2 with script
                result = self.tool_runner.run_command([
                    "r2", "-q", "-i", script_path, str(binary_path)
                ], timeout=300)  # 5 minute timeout
                
                if result["success"]:
                    return self._parse_r2_output(result["stdout"])
                else:
                    return {
                        "error": "Radare2 analysis failed",
                        "stderr": result["stderr"]
                    }
            finally:
                # Clean up script file
                Path(script_path).unlink(missing_ok=True)
                
        except Exception as e:
            return {"error": f"Radare2 analysis exception: {str(e)}"}
    
    def _create_r2_script(self) -> str:
        """Create Radare2 analysis script"""
        return """
# Radare2 automated analysis script
aaa
# Get basic info
i
echo "=== FUNCTIONS ==="
afl
echo "=== IMPORTS ==="
ii
echo "=== EXPORTS ==="
iE
echo "=== STRINGS ==="
iz
echo "=== SECTIONS ==="
iS
echo "=== ENTRY POINTS ==="
ie
echo "=== SYMBOLS ==="
is
echo "=== RELOCATIONS ==="
ir
echo "=== CONTROL FLOW GRAPH ==="
agC
echo "=== FUNCTION ANALYSIS ==="
afll
q
"""
    
    def _parse_r2_output(self, output: str) -> Dict[str, Any]:
        """Parse Radare2 output into structured data"""
        sections = {}
        current_section = None
        current_content = []
        
        for line in output.split('\n'):
            if line.startswith('=== ') and line.endswith(' ==='):
                if current_section:
                    sections[current_section] = '\n'.join(current_content)
                current_section = line.strip('= ')
                current_content = []
            else:
                current_content.append(line)
        
        # Add the last section
        if current_section:
            sections[current_section] = '\n'.join(current_content)
        
        return {
            "analysis_complete": True,
            "sections": sections,
            "raw_output": output
        }
    
    def _run_ghidra_analysis(self, binary_path: Path) -> Dict[str, Any]:
        """Run Ghidra headless analysis"""
        try:
            # Create temporary project directory
            with tempfile.TemporaryDirectory() as temp_dir:
                project_dir = Path(temp_dir) / "ghidra_project"
                project_dir.mkdir()
                
                # Create Ghidra headless script
                script_content = self._create_ghidra_script()
                script_path = project_dir / "analyze_binary.py"
                
                with open(script_path, 'w') as f:
                    f.write(script_content)
                
                # Run Ghidra headless
                ghidra_cmd = [
                    "analyzeHeadless",
                    str(project_dir),
                    "TempProject",
                    "-import", str(binary_path),
                    "-postScript", str(script_path),
                    "-deleteProject"
                ]
                
                result = self.tool_runner.run_command(ghidra_cmd, timeout=600)  # 10 minute timeout
                
                if result["success"]:
                    return self._parse_ghidra_output(result["stdout"])
                else:
                    return {
                        "error": "Ghidra analysis failed",
                        "stderr": result["stderr"]
                    }
                    
        except Exception as e:
            return {"error": f"Ghidra analysis exception: {str(e)}"}
    
    def _create_ghidra_script(self) -> str:
        """Create Ghidra analysis script"""
        return '''
# Ghidra headless analysis script
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor

# Get current program
program = getCurrentProgram()
print("=== PROGRAM INFO ===")
print("Name: " + program.getName())
print("Language: " + str(program.getLanguage()))
print("Compiler: " + str(program.getCompilerSpec()))

# Get functions
print("=== FUNCTIONS ===")
fm = program.getFunctionManager()
functions = fm.getFunctions(True)
for func in functions:
    print("Function: " + func.getName() + " @ " + str(func.getEntryPoint()))

# Get symbols
print("=== SYMBOLS ===")
st = program.getSymbolTable()
symbols = st.getAllSymbols(True)
for symbol in symbols:
    print("Symbol: " + symbol.getName() + " @ " + str(symbol.getAddress()))

# Decompile main functions
print("=== DECOMPILATION ===")
decompiler = DecompInterface()
decompiler.openProgram(program)

main_func = fm.getFunctionAt(program.getAddressFactory().getAddress("0x" + str(program.getImageBase().add(program.getMinAddress().getOffset()))))
if main_func:
    result = decompiler.decompileFunction(main_func, 30, ConsoleTaskMonitor())
    if result.decompileCompleted():
        print("Main function decompiled:")
        print(result.getDecompiledFunction().getC())

decompiler.dispose()
'''
    
    def _parse_ghidra_output(self, output: str) -> Dict[str, Any]:
        """Parse Ghidra output into structured data"""
        sections = {}
        current_section = None
        current_content = []
        
        for line in output.split('\n'):
            if line.startswith('=== ') and line.endswith(' ==='):
                if current_section:
                    sections[current_section] = '\n'.join(current_content)
                current_section = line.strip('= ')
                current_content = []
            else:
                current_content.append(line)
        
        if current_section:
            sections[current_section] = '\n'.join(current_content)
        
        return {
            "analysis_complete": True,
            "sections": sections,
            "raw_output": output
        }
    
    def _run_objdump_disassembly(self, binary_path: Path) -> Dict[str, Any]:
        """Run objdump disassembly"""
        try:
            # Disassemble all sections
            disasm_result = self.tool_runner.run_command([
                "objdump", "-d", str(binary_path)
            ])
            
            # Get all headers and info
            info_result = self.tool_runner.run_command([
                "objdump", "-x", str(binary_path)
            ])
            
            return {
                "disassembly": disasm_result["stdout"] if disasm_result["success"] else None,
                "headers_info": info_result["stdout"] if info_result["success"] else None,
                "disasm_error": disasm_result["stderr"] if not disasm_result["success"] else None,
                "info_error": info_result["stderr"] if not info_result["success"] else None
            }
            
        except Exception as e:
            return {"error": f"objdump analysis exception: {str(e)}"}