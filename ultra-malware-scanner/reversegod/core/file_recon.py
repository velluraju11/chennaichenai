"""
File Reconnaissance Module
Detects binary format, hashes, strings, and magic numbers
"""

import hashlib
import subprocess
import json
from pathlib import Path
from typing import Dict, Any, List
import re

# Optional import for python-magic (requires libmagic on Windows)
try:
    import magic
    MAGIC_AVAILABLE = True
except ImportError:
    MAGIC_AVAILABLE = False
    magic = None

class FileRecon:
    def __init__(self, tool_runner):
        self.tool_runner = tool_runner
        
    def analyze(self, binary_path: Path) -> Dict[str, Any]:
        """Perform comprehensive file reconnaissance"""
        results = {
            "binary_path": str(binary_path),
            "timestamp": self._get_timestamp()
        }
        
        # Basic file information
        results.update(self._get_basic_info(binary_path))
        
        # File type detection
        results.update(self._detect_file_type(binary_path))
        
        # Hash calculations
        results.update(self._calculate_hashes(binary_path))
        
        # String extraction
        results["strings"] = self._extract_strings(binary_path)
        
        # Binary analysis tools
        results.update(self._run_file_command(binary_path))
        results.update(self._run_readelf(binary_path))
        results.update(self._run_objdump(binary_path))
        results.update(self._run_binwalk(binary_path))
        
        return results
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.now().isoformat()
    
    def _get_basic_info(self, binary_path: Path) -> Dict[str, Any]:
        """Get basic file information"""
        stat = binary_path.stat()
        return {
            "filename": binary_path.name,
            "size": stat.st_size,
            "permissions": oct(stat.st_mode)[-3:],
            "modified_time": stat.st_mtime
        }
    
    def _detect_file_type(self, binary_path: Path) -> Dict[str, Any]:
        """Detect file type using python-magic or fallback methods"""
        if MAGIC_AVAILABLE:
            try:
                file_type = magic.from_file(str(binary_path))
                mime_type = magic.from_file(str(binary_path), mime=True)
                
                # Determine architecture and format
                arch_info = self._determine_architecture(file_type)
                
                return {
                    "file_type": file_type,
                    "mime_type": mime_type,
                    "architecture": arch_info["arch"],
                    "format": arch_info["format"],
                    "endianness": arch_info["endianness"]
                }
            except Exception as e:
                return self._fallback_file_detection(binary_path, str(e))
        else:
            return self._fallback_file_detection(binary_path, "python-magic not available")
    
    def _determine_architecture(self, file_type: str) -> Dict[str, str]:
        """Determine architecture from file type string"""
        arch_patterns = {
            "x86-64": ["x86-64", "x86_64", "AMD64"],
            "x86": ["80386", "i386", "x86"],
            "ARM": ["ARM", "aarch64"],
            "MIPS": ["MIPS"],
            "PowerPC": ["PowerPC", "PPC"]
        }
        
        format_patterns = {
            "ELF": ["ELF"],
            "PE": ["PE32", "MS-DOS"],
            "Mach-O": ["Mach-O"]
        }
        
        endian_patterns = {
            "little": ["LSB", "little"],
            "big": ["MSB", "big"]
        }
        
        result = {"arch": "Unknown", "format": "Unknown", "endianness": "Unknown"}
        
        for arch, patterns in arch_patterns.items():
            if any(pattern in file_type for pattern in patterns):
                result["arch"] = arch
                break
        
        for fmt, patterns in format_patterns.items():
            if any(pattern in file_type for pattern in patterns):
                result["format"] = fmt
                break
        
        for endian, patterns in endian_patterns.items():
            if any(pattern in file_type for pattern in patterns):
                result["endianness"] = endian
                break
        
        return result
    
    def _calculate_hashes(self, binary_path: Path) -> Dict[str, str]:
        """Calculate various hashes of the binary"""
        hashes = {}
        
        try:
            with open(binary_path, 'rb') as f:
                data = f.read()
                
            hashes["md5"] = hashlib.md5(data).hexdigest()
            hashes["sha1"] = hashlib.sha1(data).hexdigest()
            hashes["sha256"] = hashlib.sha256(data).hexdigest()
            
        except Exception as e:
            hashes["error"] = str(e)
        
        return hashes
    
    def _extract_strings(self, binary_path: Path, min_length: int = 4) -> List[str]:
        """Extract readable strings from binary"""
        try:
            result = self.tool_runner.run_command(
                ["strings", "-n", str(min_length), str(binary_path)]
            )
            
            if result["success"]:
                strings = result["stdout"].strip().split('\n')
                # Filter out empty strings and limit to reasonable number
                strings = [s for s in strings if s.strip()][:1000]
                return strings
            else:
                return []
                
        except Exception:
            # Fallback: manual string extraction
            return self._manual_string_extraction(binary_path, min_length)
    
    def _manual_string_extraction(self, binary_path: Path, min_length: int) -> List[str]:
        """Manual string extraction as fallback"""
        try:
            with open(binary_path, 'rb') as f:
                data = f.read()
            
            # Simple regex for printable ASCII strings
            pattern = rb'[!-~]{' + str(min_length).encode() + rb',}'
            matches = re.findall(pattern, data)
            
            return [match.decode('ascii', errors='ignore') for match in matches[:500]]
        except Exception:
            return []
    
    def _run_file_command(self, binary_path: Path) -> Dict[str, Any]:
        """Run the 'file' command for detailed file type information"""
        try:
            result = self.tool_runner.run_command(["file", "-b", str(binary_path)])
            return {
                "file_command_output": result["stdout"].strip() if result["success"] else None,
                "file_command_error": result["stderr"] if not result["success"] else None,
                "tool_used": result.get("tool_used", "external")
            }
        except Exception as e:
            return {"file_command_error": str(e)}
    
    def _run_readelf(self, binary_path: Path) -> Dict[str, Any]:
        """Run readelf for ELF binaries"""
        if not self._is_elf(binary_path):
            return {"readelf": "Not an ELF file"}
        
        try:
            # Get headers
            headers_result = self.tool_runner.run_command(
                ["readelf", "-h", str(binary_path)]
            )
            
            # Get sections
            sections_result = self.tool_runner.run_command(
                ["readelf", "-S", str(binary_path)]
            )
            
            # Get symbols
            symbols_result = self.tool_runner.run_command(
                ["readelf", "-s", str(binary_path)]
            )
            
            return {
                "readelf": {
                    "headers": headers_result["stdout"] if headers_result["success"] else None,
                    "sections": sections_result["stdout"] if sections_result["success"] else None,
                    "symbols": symbols_result["stdout"] if symbols_result["success"] else None
                }
            }
        except Exception as e:
            return {"readelf_error": str(e)}
    
    def _run_objdump(self, binary_path: Path) -> Dict[str, Any]:
        """Run objdump for binary analysis"""
        try:
            # Get headers
            headers_result = self.tool_runner.run_command(
                ["objdump", "-f", str(binary_path)]
            )
            
            # Get section headers
            sections_result = self.tool_runner.run_command(
                ["objdump", "-h", str(binary_path)]
            )
            
            return {
                "objdump": {
                    "file_headers": headers_result["stdout"] if headers_result["success"] else None,
                    "section_headers": sections_result["stdout"] if sections_result["success"] else None
                }
            }
        except Exception as e:
            return {"objdump_error": str(e)}
    
    def _run_binwalk(self, binary_path: Path) -> Dict[str, Any]:
        """Run binwalk for firmware analysis"""
        try:
            result = self.tool_runner.run_command(
                ["binwalk", str(binary_path)]
            )
            
            return {
                "binwalk": {
                    "output": result["stdout"] if result["success"] else None,
                    "error": result["stderr"] if not result["success"] else None
                }
            }
        except Exception as e:
            return {"binwalk_error": str(e)}
    
    def _fallback_file_detection(self, binary_path: Path, error_msg: str) -> Dict[str, Any]:
        """Fallback file type detection using magic bytes"""
        try:
            with open(binary_path, 'rb') as f:
                magic_bytes = f.read(16)
            
            file_type = "Unknown"
            mime_type = "application/octet-stream"
            format_type = "Unknown"
            arch = "Unknown"
            endianness = "Unknown"
            
            # Check common magic bytes
            if magic_bytes.startswith(b'\x7fELF'):
                file_type = "ELF executable"
                mime_type = "application/x-executable"
                format_type = "ELF"
                # Check architecture from ELF header
                if len(magic_bytes) > 4:
                    if magic_bytes[4] == 1:  # 32-bit
                        arch = "x86" if magic_bytes[5] == 1 else "x86"
                    elif magic_bytes[4] == 2:  # 64-bit
                        arch = "x86-64"
                    endianness = "little" if magic_bytes[5] == 1 else "big"
            elif magic_bytes.startswith(b'MZ'):
                file_type = "PE32 executable (MS Windows)"
                mime_type = "application/x-dosexec"
                format_type = "PE"
                arch = "x86"
                endianness = "little"
            elif magic_bytes.startswith(b'\xfe\xed\xfa\xce'):
                file_type = "Mach-O executable (32-bit big endian)"
                mime_type = "application/x-mach-binary"
                format_type = "Mach-O"
                arch = "x86"
                endianness = "big"
            elif magic_bytes.startswith(b'\xce\xfa\xed\xfe'):
                file_type = "Mach-O executable (32-bit little endian)"
                mime_type = "application/x-mach-binary"
                format_type = "Mach-O"
                arch = "x86"
                endianness = "little"
            elif magic_bytes.startswith(b'\xfe\xed\xfa\xcf'):
                file_type = "Mach-O executable (64-bit big endian)"
                mime_type = "application/x-mach-binary"
                format_type = "Mach-O"
                arch = "x86-64"
                endianness = "big"
            elif magic_bytes.startswith(b'\xcf\xfa\xed\xfe'):
                file_type = "Mach-O executable (64-bit little endian)"
                mime_type = "application/x-mach-binary"
                format_type = "Mach-O"
                arch = "x86-64"
                endianness = "little"
            
            return {
                "file_type": file_type,
                "mime_type": mime_type,
                "architecture": arch,
                "format": format_type,
                "endianness": endianness,
                "detection_method": "fallback",
                "magic_unavailable_reason": error_msg
            }
            
        except Exception as e:
            return {
                "file_type": "Unknown",
                "mime_type": "Unknown",
                "architecture": "Unknown",
                "format": "Unknown",
                "endianness": "Unknown",
                "error": f"Fallback detection failed: {str(e)}",
                "magic_unavailable_reason": error_msg
            }

    def _is_elf(self, binary_path: Path) -> bool:
        """Check if file is ELF format"""
        try:
            with open(binary_path, 'rb') as f:
                magic_bytes = f.read(4)
                return magic_bytes == b'\x7fELF'
        except Exception:
            return False