"""
Report Engine Module
Combines all results into JSON, HTML, or Markdown reports
"""

import json
from pathlib import Path
from typing import Dict, Any
from datetime import datetime
import base64

class ReportEngine:
    def __init__(self):
        self.templates_dir = Path("data/templates")
        
    def generate_report(self, analysis_results: Dict[str, Any], binary_path: Path, 
                       output_dir: Path, format_type: str) -> Path:
        """Generate comprehensive analysis report"""
        
        # Ensure output directory exists
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate report based on format
        if format_type == "json":
            return self._generate_json_report(analysis_results, binary_path, output_dir)
        elif format_type == "html":
            return self._generate_html_report(analysis_results, binary_path, output_dir)
        elif format_type == "markdown":
            return self._generate_markdown_report(analysis_results, binary_path, output_dir)
        else:
            raise ValueError(f"Unsupported report format: {format_type}")
    
    def _generate_json_report(self, analysis_results: Dict[str, Any], 
                             binary_path: Path, output_dir: Path) -> Path:
        """Generate JSON report"""
        report_data = {
            "metadata": {
                "binary_path": str(binary_path),
                "analysis_timestamp": datetime.now().isoformat(),
                "report_format": "json",
                "reversegod_version": "1.0.0"
            },
            "analysis_results": analysis_results
        }
        
        output_file = output_dir / f"{binary_path.stem}_analysis.json"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        return output_file
    
    def _generate_html_report(self, analysis_results: Dict[str, Any], 
                             binary_path: Path, output_dir: Path) -> Path:
        """Generate HTML report"""
        
        # Create HTML content
        html_content = self._create_html_content(analysis_results, binary_path)
        
        output_file = output_dir / f"{binary_path.stem}_analysis.html"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return output_file
    
    def _generate_markdown_report(self, analysis_results: Dict[str, Any], 
                                 binary_path: Path, output_dir: Path) -> Path:
        """Generate Markdown report"""
        
        markdown_content = self._create_markdown_content(analysis_results, binary_path)
        
        output_file = output_dir / f"{binary_path.stem}_analysis.md"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        return output_file
    
    def _create_html_content(self, analysis_results: Dict[str, Any], binary_path: Path) -> str:
        """Create comprehensive HTML report content"""
        
        # Extract key information
        file_recon = analysis_results.get("file_recon", {})
        ai_analysis = analysis_results.get("ai_analysis", {})
        risk_assessment = ai_analysis.get("risk_assessment", {})
        
        risk_level = risk_assessment.get("risk_level", "UNKNOWN")
        risk_color = self._get_risk_color(risk_level)
        
        html_template = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReverseGod Analysis Report - {binary_path.name}</title>
    <style>
        {self._get_html_styles()}
    </style>
</head>
<body>
    <div class="container">
        <header class="report-header">
            <h1>üöÄ ReverseGod Analysis Report</h1>
            <div class="binary-info">
                <h2>{binary_path.name}</h2>
                <p class="timestamp">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
        </header>

        <div class="risk-banner risk-{risk_level.lower()}">
            <h2>Risk Assessment: {risk_level}</h2>
            <p>Risk Score: {risk_assessment.get('risk_score', 'N/A')}/100</p>
        </div>

        {self._create_executive_summary_html(ai_analysis)}
        
        {self._create_file_info_html(file_recon)}
        
        {self._create_analysis_sections_html(analysis_results)}
        
        {self._create_recommendations_html(ai_analysis)}
        
        <footer class="report-footer">
            <p>Generated by ReverseGod v1.0.0 - Weaponized Gemini-powered binary analysis framework</p>
        </footer>
    </div>
</body>
</html>
"""
        return html_template
    
    def _create_executive_summary_html(self, ai_analysis: Dict[str, Any]) -> str:
        """Create executive summary HTML section"""
        summary = ai_analysis.get("executive_summary", "Executive summary not available")
        
        return f"""
        <section class="executive-summary">
            <h2>üìã Executive Summary</h2>
            <div class="summary-content">
                {self._format_text_for_html(summary)}
            </div>
        </section>
        """
    
    def _create_file_info_html(self, file_recon: Dict[str, Any]) -> str:
        """Create file information HTML section"""
        return f"""
        <section class="file-info">
            <h2>üìÅ File Information</h2>
            <div class="info-grid">
                <div class="info-item">
                    <strong>File Type:</strong> {file_recon.get('file_type', 'Unknown')}
                </div>
                <div class="info-item">
                    <strong>Architecture:</strong> {file_recon.get('architecture', 'Unknown')}
                </div>
                <div class="info-item">
                    <strong>Format:</strong> {file_recon.get('format', 'Unknown')}
                </div>
                <div class="info-item">
                    <strong>Size:</strong> {file_recon.get('size', 'Unknown')} bytes
                </div>
                <div class="info-item">
                    <strong>MD5:</strong> <code>{file_recon.get('md5', 'N/A')}</code>
                </div>
                <div class="info-item">
                    <strong>SHA256:</strong> <code>{file_recon.get('sha256', 'N/A')}</code>
                </div>
            </div>
        </section>
        """
    
    def _create_analysis_sections_html(self, analysis_results: Dict[str, Any]) -> str:
        """Create analysis sections HTML"""
        sections_html = []
        
        # Disassembly section
        if "disassembly" in analysis_results:
            sections_html.append(self._create_disassembly_section_html(analysis_results["disassembly"]))
        
        # Dynamic analysis section
        if "debugging" in analysis_results:
            sections_html.append(self._create_debugging_section_html(analysis_results["debugging"]))
        
        # Patching analysis section
        if "patching" in analysis_results:
            sections_html.append(self._create_patching_section_html(analysis_results["patching"]))
        
        # AI insights section
        if "ai_analysis" in analysis_results:
            sections_html.append(self._create_ai_insights_section_html(analysis_results["ai_analysis"]))
        
        return "\n".join(sections_html)
    
    def _create_disassembly_section_html(self, disassembly: Dict[str, Any]) -> str:
        """Create disassembly section HTML"""
        return f"""
        <section class="analysis-section">
            <h2>üß™ Disassembly & Decompilation</h2>
            <div class="analysis-content">
                <h3>Radare2 Analysis</h3>
                <p>Status: {'‚úÖ Complete' if disassembly.get('radare2', {}).get('analysis_complete') else '‚ùå Failed'}</p>
                
                <h3>Ghidra Analysis</h3>
                <p>Status: {'‚úÖ Complete' if disassembly.get('ghidra', {}).get('analysis_complete') else '‚ùå Failed'}</p>
                
                <details>
                    <summary>View Detailed Results</summary>
                    <pre class="code-block">{self._format_dict_for_html(disassembly)}</pre>
                </details>
            </div>
        </section>
        """
    
    def _create_debugging_section_html(self, debugging: Dict[str, Any]) -> str:
        """Create debugging section HTML"""
        strace_count = len(debugging.get("strace", {}).get("syscalls", []))
        ltrace_count = len(debugging.get("ltrace", {}).get("library_calls", []))
        
        return f"""
        <section class="analysis-section">
            <h2>üß† Dynamic Analysis & Debugging</h2>
            <div class="analysis-content">
                <h3>System Call Tracing</h3>
                <p>System calls captured: {strace_count}</p>
                
                <h3>Library Call Tracing</h3>
                <p>Library calls captured: {ltrace_count}</p>
                
                <h3>Memory Analysis</h3>
                <p>Valgrind analysis: {'‚úÖ Complete' if debugging.get('valgrind', {}).get('analysis_complete') else '‚ùå Failed'}</p>
                
                <details>
                    <summary>View Detailed Results</summary>
                    <pre class="code-block">{self._format_dict_for_html(debugging)}</pre>
                </details>
            </div>
        </section>
        """
    
    def _create_patching_section_html(self, patching: Dict[str, Any]) -> str:
        """Create patching section HTML"""
        code_caves = len(patching.get("patch_opportunities", {}).get("code_caves", []))
        nop_sequences = len(patching.get("patch_opportunities", {}).get("nop_sequences", []))
        
        return f"""
        <section class="analysis-section">
            <h2>üõ†Ô∏è Binary Modification Analysis</h2>
            <div class="analysis-content">
                <h3>Patching Opportunities</h3>
                <p>Code caves found: {code_caves}</p>
                <p>NOP sequences found: {nop_sequences}</p>
                
                <details>
                    <summary>View Detailed Results</summary>
                    <pre class="code-block">{self._format_dict_for_html(patching)}</pre>
                </details>
            </div>
        </section>
        """
    
    def _create_ai_insights_section_html(self, ai_analysis: Dict[str, Any]) -> str:
        """Create AI insights section HTML"""
        insights = ai_analysis.get("insights", {})
        
        return f"""
        <section class="analysis-section">
            <h2>ü§ñ AI-Powered Insights</h2>
            <div class="analysis-content">
                <h3>Technical Findings</h3>
                <p>{self._format_text_for_html(insights.get('technical_findings', 'No findings available'))}</p>
                
                <h3>Security Concerns</h3>
                <p>{self._format_text_for_html(insights.get('security_concerns', 'No concerns identified'))}</p>
                
                <h3>Behavioral Analysis</h3>
                <p>{self._format_text_for_html(insights.get('behavioral_analysis', 'No behavioral analysis available'))}</p>
            </div>
        </section>
        """
    
    def _create_recommendations_html(self, ai_analysis: Dict[str, Any]) -> str:
        """Create recommendations HTML section"""
        recommendations = ai_analysis.get("recommendations", [])
        
        recommendations_html = ""
        for i, rec in enumerate(recommendations, 1):
            recommendations_html += f"<li>{rec}</li>"
        
        return f"""
        <section class="recommendations">
            <h2>üí° Recommendations</h2>
            <ol>
                {recommendations_html}
            </ol>
        </section>
        """
    
    def _create_markdown_content(self, analysis_results: Dict[str, Any], binary_path: Path) -> str:
        """Create comprehensive Markdown report content"""
        
        file_recon = analysis_results.get("file_recon", {})
        ai_analysis = analysis_results.get("ai_analysis", {})
        risk_assessment = ai_analysis.get("risk_assessment", {})
        
        markdown_content = f"""# üöÄ ReverseGod Analysis Report

## Binary: {binary_path.name}
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---

## üéØ Risk Assessment: {risk_assessment.get('risk_level', 'UNKNOWN')}
**Risk Score:** {risk_assessment.get('risk_score', 'N/A')}/100

### Risk Factors:
{self._format_list_for_markdown(risk_assessment.get('risk_factors', []))}

---

## üìã Executive Summary
{ai_analysis.get('executive_summary', 'Executive summary not available')}

---

## üìÅ File Information
- **File Type:** {file_recon.get('file_type', 'Unknown')}
- **Architecture:** {file_recon.get('architecture', 'Unknown')}
- **Format:** {file_recon.get('format', 'Unknown')}
- **Size:** {file_recon.get('size', 'Unknown')} bytes
- **MD5:** `{file_recon.get('md5', 'N/A')}`
- **SHA256:** `{file_recon.get('sha256', 'N/A')}`

---

## üîç Analysis Results

### File Reconnaissance
- **Strings Extracted:** {len(file_recon.get('strings', []))} strings
- **File Command Output:** Available
- **Binary Analysis:** Complete

### Disassembly & Decompilation
{self._create_disassembly_markdown(analysis_results.get('disassembly', {}))}

### Dynamic Analysis
{self._create_debugging_markdown(analysis_results.get('debugging', {}))}

### Binary Modification Analysis
{self._create_patching_markdown(analysis_results.get('patching', {}))}

---

## ü§ñ AI-Powered Insights
{self._create_ai_insights_markdown(ai_analysis.get('insights', {}))}

---

## üí° Recommendations
{self._format_list_for_markdown(ai_analysis.get('recommendations', []))}

---

## üìä Technical Details

<details>
<summary>Click to expand full analysis results</summary>

```json
{json.dumps(analysis_results, indent=2)}
```

</details>

---

*Generated by ReverseGod v1.0.0 - Weaponized Gemini-powered binary analysis framework*
"""
        return markdown_content
    
    def _create_disassembly_markdown(self, disassembly: Dict[str, Any]) -> str:
        """Create disassembly markdown section"""
        r2_status = "‚úÖ Complete" if disassembly.get('radare2', {}).get('analysis_complete') else "‚ùå Failed"
        ghidra_status = "‚úÖ Complete" if disassembly.get('ghidra', {}).get('analysis_complete') else "‚ùå Failed"
        
        return f"""
- **Radare2 Analysis:** {r2_status}
- **Ghidra Analysis:** {ghidra_status}
- **objdump Analysis:** Available
"""
    
    def _create_debugging_markdown(self, debugging: Dict[str, Any]) -> str:
        """Create debugging markdown section"""
        strace_count = len(debugging.get("strace", {}).get("syscalls", []))
        ltrace_count = len(debugging.get("ltrace", {}).get("library_calls", []))
        valgrind_status = "‚úÖ Complete" if debugging.get('valgrind', {}).get('analysis_complete') else "‚ùå Failed"
        
        return f"""
- **System Calls Traced:** {strace_count} syscalls
- **Library Calls Traced:** {ltrace_count} calls
- **Memory Analysis:** {valgrind_status}
- **GDB Analysis:** Available
"""
    
    def _create_patching_markdown(self, patching: Dict[str, Any]) -> str:
        """Create patching markdown section"""
        code_caves = len(patching.get("patch_opportunities", {}).get("code_caves", []))
        nop_sequences = len(patching.get("patch_opportunities", {}).get("nop_sequences", []))
        
        return f"""
- **Code Caves Found:** {code_caves}
- **NOP Sequences Found:** {nop_sequences}
- **Entry Point Analysis:** Available
- **Hex Analysis:** Complete
"""
    
    def _create_ai_insights_markdown(self, insights: Dict[str, Any]) -> str:
        """Create AI insights markdown section"""
        return f"""
### Technical Findings
{insights.get('technical_findings', 'No findings available')}

### Security Concerns
{insights.get('security_concerns', 'No concerns identified')}

### Behavioral Analysis
{insights.get('behavioral_analysis', 'No behavioral analysis available')}
"""
    
    def _get_risk_color(self, risk_level: str) -> str:
        """Get color for risk level"""
        colors = {
            "LOW": "#28a745",
            "MODERATE": "#ffc107", 
            "HIGH": "#fd7e14",
            "CRITICAL": "#dc3545"
        }
        return colors.get(risk_level, "#6c757d")
    
    def _get_html_styles(self) -> str:
        """Get CSS styles for HTML report"""
        return """
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 0; background: #f8f9fa; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .report-header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; }
        .report-header h1 { margin: 0; font-size: 2.5em; }
        .binary-info h2 { margin: 10px 0 5px 0; font-size: 1.5em; }
        .timestamp { opacity: 0.8; margin: 0; }
        .risk-banner { padding: 20px; border-radius: 8px; margin-bottom: 20px; text-align: center; }
        .risk-low { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .risk-moderate { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .risk-high { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .risk-critical { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; font-weight: bold; }
        .executive-summary, .file-info, .analysis-section, .recommendations { background: white; padding: 25px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-top: 15px; }
        .info-item { padding: 10px; background: #f8f9fa; border-radius: 5px; }
        .code-block { background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 0.9em; }
        details { margin-top: 15px; }
        summary { cursor: pointer; font-weight: bold; padding: 10px; background: #e9ecef; border-radius: 5px; }
        .report-footer { text-align: center; padding: 20px; color: #6c757d; }
        h2 { color: #495057; border-bottom: 2px solid #e9ecef; padding-bottom: 10px; }
        h3 { color: #6c757d; margin-top: 20px; }
        code { background: #e9ecef; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; }
        """
    
    def _format_text_for_html(self, text: str) -> str:
        """Format text for HTML display"""
        if not text:
            return "No information available"
        
        # Convert newlines to <br> and wrap in paragraphs
        paragraphs = text.split('\n\n')
        formatted_paragraphs = []
        
        for para in paragraphs:
            if para.strip():
                formatted_para = para.replace('\n', '<br>')
                formatted_paragraphs.append(f"<p>{formatted_para}</p>")
        
        return '\n'.join(formatted_paragraphs)
    
    def _format_dict_for_html(self, data: Dict[str, Any]) -> str:
        """Format dictionary for HTML display"""
        return json.dumps(data, indent=2)
    
    def _format_list_for_markdown(self, items: list) -> str:
        """Format list for Markdown display"""
        if not items:
            return "- No items available"
        
        return '\n'.join([f"- {item}" for item in items])