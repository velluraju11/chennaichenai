"""
Gemini AI Core Module
AI-powered interpretation of raw tool output and report generation
"""

import json
import requests
from typing import Dict, Any, List
import time

class GeminiAICore:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent"
        
    def analyze(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Perform AI-powered analysis of all tool outputs"""
        results = {
            "timestamp": self._get_timestamp(),
            "ai_analysis_complete": False
        }
        
        try:
            # Prepare data for AI analysis
            analysis_summary = self._prepare_analysis_summary(analysis_results)
            
            # Generate AI insights
            results["insights"] = self._generate_insights(analysis_summary)
            
            # Assess risk level
            results["risk_assessment"] = self._assess_risk_level(analysis_results)
            
            # Generate recommendations
            results["recommendations"] = self._generate_recommendations(analysis_results)
            
            # Create executive summary
            results["executive_summary"] = self._create_executive_summary(analysis_results)
            
            results["ai_analysis_complete"] = True
            
        except Exception as e:
            results["error"] = f"AI analysis failed: {str(e)}"
        
        return results
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.now().isoformat()
    
    def _prepare_analysis_summary(self, analysis_results: Dict[str, Any]) -> str:
        """Prepare a concise summary of analysis results for AI processing"""
        summary_parts = []
        
        # File reconnaissance summary
        if "file_recon" in analysis_results:
            recon = analysis_results["file_recon"]
            summary_parts.append(f"""
FILE RECONNAISSANCE:
- File Type: {recon.get('file_type', 'Unknown')}
- Architecture: {recon.get('architecture', 'Unknown')}
- Format: {recon.get('format', 'Unknown')}
- Size: {recon.get('size', 'Unknown')} bytes
- MD5: {recon.get('md5', 'N/A')}
- SHA256: {recon.get('sha256', 'N/A')}
- Strings found: {len(recon.get('strings', []))} strings
""")
        
        # Disassembly summary
        if "disassembly" in analysis_results:
            disasm = analysis_results["disassembly"]
            summary_parts.append(f"""
DISASSEMBLY ANALYSIS:
- Radare2 analysis: {'Complete' if disasm.get('radare2', {}).get('analysis_complete') else 'Failed'}
- Ghidra analysis: {'Complete' if disasm.get('ghidra', {}).get('analysis_complete') else 'Failed'}
- Functions identified: Available in detailed analysis
""")
        
        # Dynamic analysis summary
        if "debugging" in analysis_results:
            debug = analysis_results["debugging"]
            summary_parts.append(f"""
DYNAMIC ANALYSIS:
- System calls traced: {len(debug.get('strace', {}).get('syscalls', []))} syscalls
- Library calls traced: {len(debug.get('ltrace', {}).get('library_calls', []))} calls
- Memory analysis: {'Complete' if debug.get('valgrind', {}).get('analysis_complete') else 'Failed'}
- GDB analysis: {'Complete' if debug.get('gdb', {}).get('analysis_complete') else 'Failed'}
""")
        
        # Patching analysis summary
        if "patching" in analysis_results:
            patch = analysis_results["patching"]
            summary_parts.append(f"""
BINARY MODIFICATION ANALYSIS:
- Code caves found: {len(patch.get('patch_opportunities', {}).get('code_caves', []))}
- NOP sequences found: {len(patch.get('patch_opportunities', {}).get('nop_sequences', []))}
- Entry point analysis: {'Complete' if patch.get('entry_point_analysis') else 'Failed'}
""")
        
        return "\n".join(summary_parts)
    
    def _generate_insights(self, analysis_summary: str) -> Dict[str, Any]:
        """Generate AI insights from analysis summary"""
        try:
            prompt = f"""
As a cybersecurity expert specializing in malware analysis and reverse engineering, analyze the following binary analysis results and provide key insights:

{analysis_summary}

Please provide:
1. Key technical findings
2. Potential security concerns
3. Behavioral analysis
4. Notable characteristics
5. Comparison to known malware families (if applicable)

Keep the analysis technical but concise.
"""
            
            response = self._call_gemini_api(prompt)
            
            return {
                "technical_findings": self._extract_section(response, "technical findings"),
                "security_concerns": self._extract_section(response, "security concerns"),
                "behavioral_analysis": self._extract_section(response, "behavioral analysis"),
                "notable_characteristics": self._extract_section(response, "notable characteristics"),
                "malware_comparison": self._extract_section(response, "malware families"),
                "full_response": response
            }
            
        except Exception as e:
            return {"error": f"Failed to generate insights: {str(e)}"}
    
    def _assess_risk_level(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Assess risk level based on analysis results"""
        risk_factors = []
        risk_score = 0
        
        # File reconnaissance risk factors
        if "file_recon" in analysis_results:
            recon = analysis_results["file_recon"]
            
            # Suspicious file types
            file_type = recon.get("file_type", "").lower()
            if any(suspicious in file_type for suspicious in ["packed", "upx", "encrypted", "obfuscated"]):
                risk_factors.append("Potentially packed or obfuscated binary")
                risk_score += 20
            
            # Suspicious strings
            strings = recon.get("strings", [])
            suspicious_strings = ["cmd.exe", "powershell", "rundll32", "regsvr32", "http://", "https://"]
            found_suspicious = [s for s in strings if any(sus in s.lower() for sus in suspicious_strings)]
            if found_suspicious:
                risk_factors.append(f"Suspicious strings found: {len(found_suspicious)} items")
                risk_score += 15
        
        # Dynamic analysis risk factors
        if "debugging" in analysis_results:
            debug = analysis_results["debugging"]
            
            # Suspicious system calls
            syscalls = debug.get("strace", {}).get("syscalls", [])
            suspicious_syscalls = ["execve", "socket", "connect", "sendto", "recvfrom"]
            found_syscalls = [sc for sc in syscalls if sc.get("name") in suspicious_syscalls]
            if found_syscalls:
                risk_factors.append(f"Network/execution syscalls detected: {len(found_syscalls)}")
                risk_score += 25
            
            # Memory issues
            valgrind = debug.get("valgrind", {}).get("memory_analysis", {})
            if valgrind.get("memory_leaks") or valgrind.get("invalid_reads"):
                risk_factors.append("Memory corruption issues detected")
                risk_score += 10
        
        # Determine risk level
        if risk_score >= 60:
            risk_level = "CRITICAL"
        elif risk_score >= 40:
            risk_level = "HIGH"
        elif risk_score >= 20:
            risk_level = "MODERATE"
        else:
            risk_level = "LOW"
        
        return {
            "risk_level": risk_level,
            "risk_score": risk_score,
            "risk_factors": risk_factors,
            "assessment_details": f"Risk assessment based on {len(risk_factors)} identified factors"
        }
    
    def _generate_recommendations(self, analysis_results: Dict[str, Any]) -> List[str]:
        """Generate actionable recommendations"""
        recommendations = []
        
        # Always include basic recommendations
        recommendations.extend([
            "Perform analysis in an isolated environment",
            "Monitor network traffic during execution",
            "Create memory dumps for further analysis",
            "Check for persistence mechanisms"
        ])
        
        # Specific recommendations based on findings
        if "file_recon" in analysis_results:
            recon = analysis_results["file_recon"]
            
            if recon.get("format") == "PE":
                recommendations.append("Analyze PE imports and exports for API usage patterns")
            elif recon.get("format") == "ELF":
                recommendations.append("Check ELF sections for unusual characteristics")
            
            if len(recon.get("strings", [])) > 100:
                recommendations.append("Perform detailed string analysis for IOCs")
        
        if "debugging" in analysis_results:
            debug = analysis_results["debugging"]
            
            if debug.get("strace", {}).get("syscalls"):
                recommendations.append("Analyze system call patterns for malicious behavior")
            
            if debug.get("valgrind", {}).get("memory_analysis"):
                recommendations.append("Investigate memory corruption vulnerabilities")
        
        if "patching" in analysis_results:
            patch = analysis_results["patching"]
            
            if patch.get("patch_opportunities", {}).get("code_caves"):
                recommendations.append("Monitor code caves for potential payload injection")
        
        return recommendations
    
    def _create_executive_summary(self, analysis_results: Dict[str, Any]) -> str:
        """Create executive summary of the analysis"""
        try:
            # Prepare summary data
            binary_path = analysis_results.get("file_recon", {}).get("binary_path", "Unknown")
            file_type = analysis_results.get("file_recon", {}).get("file_type", "Unknown")
            risk_level = analysis_results.get("ai_analysis", {}).get("risk_assessment", {}).get("risk_level", "UNKNOWN")
            
            summary_prompt = f"""
Create a concise executive summary for a binary analysis report of: {binary_path}

File Type: {file_type}
Risk Level: {risk_level}

Analysis included:
- File reconnaissance and metadata analysis
- Static disassembly and decompilation
- Dynamic analysis and debugging
- Binary modification assessment
- AI-powered threat assessment

Provide a 2-3 paragraph executive summary suitable for technical management.
"""
            
            return self._call_gemini_api(summary_prompt)
            
        except Exception as e:
            return f"Executive summary generation failed: {str(e)}"
    
    def _call_gemini_api(self, prompt: str) -> str:
        """Make API call to Gemini"""
        headers = {
            "Content-Type": "application/json"
        }
        
        data = {
            "contents": [{
                "parts": [{
                    "text": prompt
                }]
            }]
        }
        
        url = f"{self.base_url}?key={self.api_key}"
        
        try:
            response = requests.post(url, headers=headers, json=data, timeout=30)
            response.raise_for_status()
            
            result = response.json()
            
            if "candidates" in result and len(result["candidates"]) > 0:
                return result["candidates"][0]["content"]["parts"][0]["text"]
            else:
                return "No response generated"
                
        except requests.exceptions.RequestException as e:
            raise Exception(f"API request failed: {str(e)}")
        except KeyError as e:
            raise Exception(f"Unexpected API response format: {str(e)}")
    
    def _extract_section(self, text: str, section_name: str) -> str:
        """Extract specific section from AI response"""
        lines = text.split('\n')
        section_lines = []
        in_section = False
        
        for line in lines:
            if section_name.lower() in line.lower() and ('.' in line or ':' in line):
                in_section = True
                continue
            elif in_section and line.strip() and (line[0].isdigit() or line.startswith('-')):
                section_lines.append(line.strip())
            elif in_section and not line.strip():
                continue
            elif in_section and line.strip() and not (line[0].isdigit() or line.startswith('-')):
                break
        
        return '\n'.join(section_lines) if section_lines else "No specific information found"