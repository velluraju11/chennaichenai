"""
Tool Runner Utility
Handles execution of external tools with proper isolation and error handling
"""

import subprocess
import tempfile
import shutil
import os
from pathlib import Path
from typing import Dict, Any, List, Optional
import signal
import time
import sys

# Import the tool manager
try:
    from tools.tool_manager import ToolManager
    TOOL_MANAGER_AVAILABLE = True
except ImportError:
    TOOL_MANAGER_AVAILABLE = False

class ToolRunner:
    def __init__(self, isolate: bool = False):
        self.isolate = isolate
        self.temp_dir = None
        
        # Initialize tool manager if available
        if TOOL_MANAGER_AVAILABLE:
            self.tool_manager = ToolManager()
        else:
            self.tool_manager = None
        
        if self.isolate:
            self.temp_dir = tempfile.mkdtemp(prefix="reversegod_")
    
    def __del__(self):
        """Cleanup temporary directory"""
        if self.temp_dir and Path(self.temp_dir).exists():
            shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def run_command(self, command: List[str], timeout: int = 60, 
                   input_data: Optional[str] = None, 
                   working_dir: Optional[Path] = None) -> Dict[str, Any]:
        """
        Run external command with proper error handling and isolation
        Uses built-in tools when available, falls back to external tools
        
        Args:
            command: List of command and arguments
            timeout: Timeout in seconds
            input_data: Optional input data to send to stdin
            working_dir: Optional working directory
            
        Returns:
            Dict with success status, stdout, stderr, and return code
        """
        if not command:
            return {
                "success": False,
                "stdout": "",
                "stderr": "Empty command",
                "return_code": -1,
                "command": "",
                "timeout_occurred": False
            }
        
        tool_name = command[0]
        
        # Try built-in tool first if available
        if self.tool_manager and tool_name in ['file', 'strings', 'readelf', 'objdump', 'xxd', 'hexdump']:
            try:
                return self.tool_manager.run_tool(tool_name, command[1:], timeout)
            except Exception as e:
                # Fall back to external tool if built-in fails
                pass
        
        # Use external tool
        return self._run_external_command(command, timeout, input_data, working_dir)
    
    def _run_external_command(self, command: List[str], timeout: int = 60, 
                             input_data: Optional[str] = None, 
                             working_dir: Optional[Path] = None) -> Dict[str, Any]:
        """Run external command via subprocess"""
        result = {
            "success": False,
            "stdout": "",
            "stderr": "",
            "return_code": -1,
            "command": " ".join(command),
            "timeout_occurred": False
        }
        
        try:
            # Set working directory
            cwd = working_dir or (Path(self.temp_dir) if self.isolate else None)
            
            # Prepare environment
            env = os.environ.copy()
            if self.isolate:
                # Add isolation environment variables
                env["TMPDIR"] = self.temp_dir
                env["TEMP"] = self.temp_dir
                env["TMP"] = self.temp_dir
            
            # Start process
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE if input_data else None,
                text=True,
                cwd=cwd,
                env=env,
                preexec_fn=os.setsid if os.name != 'nt' else None  # Process group for Unix
            )
            
            try:
                # Run with timeout
                stdout, stderr = process.communicate(
                    input=input_data,
                    timeout=timeout
                )
                
                result["stdout"] = stdout
                result["stderr"] = stderr
                result["return_code"] = process.returncode
                result["success"] = process.returncode == 0
                
            except subprocess.TimeoutExpired:
                # Handle timeout
                result["timeout_occurred"] = True
                result["stderr"] = f"Command timed out after {timeout} seconds"
                
                # Kill process group
                try:
                    if os.name != 'nt':
                        os.killpg(os.getpgid(process.pid), signal.SIGTERM)
                    else:
                        process.terminate()
                    
                    # Wait a bit for graceful termination
                    time.sleep(2)
                    
                    if process.poll() is None:
                        # Force kill if still running
                        if os.name != 'nt':
                            os.killpg(os.getpgid(process.pid), signal.SIGKILL)
                        else:
                            process.kill()
                            
                except (OSError, ProcessLookupError):
                    pass  # Process already terminated
                
                # Get any partial output
                try:
                    stdout, stderr = process.communicate(timeout=1)
                    result["stdout"] = stdout
                    if not result["stderr"]:
                        result["stderr"] = stderr
                except:
                    pass
                    
        except FileNotFoundError:
            result["stderr"] = f"Command not found: {command[0]}"
        except PermissionError:
            result["stderr"] = f"Permission denied: {command[0]}"
        except Exception as e:
            result["stderr"] = f"Unexpected error: {str(e)}"
        
        return result
    
    def check_tool_availability(self, tool_name: str) -> bool:
        """Check if a tool is available in PATH"""
        try:
            result = self.run_command([tool_name, "--version"], timeout=5)
            return result["success"] or result["return_code"] == 0
        except:
            try:
                # Try alternative check
                result = self.run_command([tool_name, "-h"], timeout=5)
                return result["success"] or result["return_code"] == 0
            except:
                return False
    
    def get_available_tools(self) -> Dict[str, bool]:
        """Get availability status of all required tools"""
        if self.tool_manager:
            # Use tool manager for enhanced detection
            tool_status = self.tool_manager.get_tool_status()
            return {tool: status['available'] for tool, status in tool_status.items()}
        else:
            # Fallback to basic detection
            tools = {
                "file": self.check_tool_availability("file"),
                "strings": self.check_tool_availability("strings"),
                "readelf": self.check_tool_availability("readelf"),
                "objdump": self.check_tool_availability("objdump"),
                "binwalk": self.check_tool_availability("binwalk"),
                "r2": self.check_tool_availability("r2"),
                "radare2": self.check_tool_availability("radare2"),
                "gdb": self.check_tool_availability("gdb"),
                "strace": self.check_tool_availability("strace"),
                "ltrace": self.check_tool_availability("ltrace"),
                "valgrind": self.check_tool_availability("valgrind"),
                "xxd": self.check_tool_availability("xxd"),
                "hexdump": self.check_tool_availability("hexdump"),
                "analyzeHeadless": self.check_tool_availability("analyzeHeadless")
            }
            return tools
    
    def create_isolated_copy(self, file_path: Path) -> Path:
        """Create isolated copy of file for analysis"""
        if not self.isolate or not self.temp_dir:
            return file_path
        
        isolated_path = Path(self.temp_dir) / file_path.name
        shutil.copy2(file_path, isolated_path)
        
        # Set restrictive permissions
        isolated_path.chmod(0o600)
        
        return isolated_path
    
    def get_isolation_info(self) -> Dict[str, Any]:
        """Get information about isolation setup"""
        return {
            "isolated": self.isolate,
            "temp_dir": self.temp_dir,
            "available_tools": self.get_available_tools() if self.isolate else None
        }