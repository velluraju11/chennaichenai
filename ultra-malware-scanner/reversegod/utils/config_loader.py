"""
Configuration Loader Utility
Handles loading and managing configuration settings
"""

import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
import os

class ConfigLoader:
    def __init__(self, config_path: Optional[Path] = None):
        self.config_path = config_path or Path("data/tool_configs/config.json")
        self.config = self._load_default_config()
        
        # Load user config if exists
        if self.config_path.exists():
            self.config.update(self._load_config_file())
    
    def _load_default_config(self) -> Dict[str, Any]:
        """Load default configuration"""
        return {
            "tools": {
                "timeout_default": 60,
                "timeout_long": 300,
                "max_output_size": 10 * 1024 * 1024,  # 10MB
                "radare2": {
                    "timeout": 300,
                    "max_functions": 1000,
                    "analysis_depth": "aaa"
                },
                "ghidra": {
                    "timeout": 600,
                    "headless_timeout": 600,
                    "max_decompile_functions": 50
                },
                "gdb": {
                    "timeout": 120,
                    "max_backtrace_depth": 50
                },
                "strace": {
                    "timeout": 30,
                    "max_syscalls": 1000,
                    "trace_children": True
                },
                "ltrace": {
                    "timeout": 30,
                    "max_calls": 1000
                },
                "valgrind": {
                    "timeout": 60,
                    "tool": "memcheck",
                    "leak_check": "full"
                },
                "strings": {
                    "min_length": 4,
                    "max_strings": 1000
                },
                "binwalk": {
                    "timeout": 60,
                    "extract": False
                }
            },
            "output": {
                "default_format": "markdown",
                "include_raw_output": True,
                "compress_large_outputs": True,
                "max_string_display": 100
            },
            "security": {
                "isolate_by_default": False,
                "quarantine_suspicious": True,
                "max_file_size": 100 * 1024 * 1024,  # 100MB
                "allowed_extensions": [".exe", ".elf", ".bin", ".so", ".dll", ".dylib"]
            },
            "gemini": {
                "model": "gemini-pro",
                "max_tokens": 8192,
                "temperature": 0.1,
                "timeout": 30
            },
            "reporting": {
                "include_screenshots": False,
                "include_hex_dumps": True,
                "max_hex_dump_size": 2048,
                "include_disassembly": True,
                "max_disassembly_lines": 500
            }
        }
    
    def _load_config_file(self) -> Dict[str, Any]:
        """Load configuration from file"""
        try:
            with open(self.config_path, 'r') as f:
                if self.config_path.suffix.lower() == '.json':
                    return json.load(f)
                elif self.config_path.suffix.lower() in ['.yml', '.yaml']:
                    return yaml.safe_load(f)
                else:
                    # Try JSON first, then YAML
                    content = f.read()
                    try:
                        return json.loads(content)
                    except json.JSONDecodeError:
                        return yaml.safe_load(content)
        except Exception as e:
            print(f"Warning: Failed to load config file {self.config_path}: {e}")
            return {}
    
    def get(self, key_path: str, default: Any = None) -> Any:
        """
        Get configuration value using dot notation
        Example: get('tools.radare2.timeout')
        """
        keys = key_path.split('.')
        value = self.config
        
        for key in keys:
            if isinstance(value, dict) and key in value:
                value = value[key]
            else:
                return default
        
        return value
    
    def set(self, key_path: str, value: Any) -> None:
        """
        Set configuration value using dot notation
        Example: set('tools.radare2.timeout', 600)
        """
        keys = key_path.split('.')
        config = self.config
        
        for key in keys[:-1]:
            if key not in config:
                config[key] = {}
            config = config[key]
        
        config[keys[-1]] = value
    
    def get_tool_config(self, tool_name: str) -> Dict[str, Any]:
        """Get configuration for specific tool"""
        return self.get(f'tools.{tool_name}', {})
    
    def get_timeout(self, tool_name: str) -> int:
        """Get timeout for specific tool"""
        tool_config = self.get_tool_config(tool_name)
        return tool_config.get('timeout', self.get('tools.timeout_default', 60))
    
    def is_file_allowed(self, file_path: Path) -> bool:
        """Check if file is allowed for analysis"""
        # Check file size
        max_size = self.get('security.max_file_size', 100 * 1024 * 1024)
        if file_path.stat().st_size > max_size:
            return False
        
        # Check extension
        allowed_extensions = self.get('security.allowed_extensions', [])
        if allowed_extensions and file_path.suffix.lower() not in allowed_extensions:
            return False
        
        return True
    
    def should_isolate(self) -> bool:
        """Check if analysis should be isolated"""
        return self.get('security.isolate_by_default', False)
    
    def get_gemini_config(self) -> Dict[str, Any]:
        """Get Gemini API configuration"""
        return self.get('gemini', {})
    
    def get_output_config(self) -> Dict[str, Any]:
        """Get output configuration"""
        return self.get('output', {})
    
    def get_reporting_config(self) -> Dict[str, Any]:
        """Get reporting configuration"""
        return self.get('reporting', {})
    
    def save_config(self, config_path: Optional[Path] = None) -> None:
        """Save current configuration to file"""
        save_path = config_path or self.config_path
        save_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            with open(save_path, 'w') as f:
                if save_path.suffix.lower() == '.json':
                    json.dump(self.config, f, indent=2)
                else:
                    yaml.dump(self.config, f, default_flow_style=False, indent=2)
        except Exception as e:
            print(f"Error saving config to {save_path}: {e}")
    
    def create_tool_configs_directory(self) -> None:
        """Create tool configuration directory structure"""
        base_dir = Path("data/tool_configs")
        base_dir.mkdir(parents=True, exist_ok=True)
        
        # Create individual tool config files
        tool_configs = {
            "radare2.json": {
                "analysis_commands": [
                    "aaa",  # Analyze all
                    "afl",  # List functions
                    "ii",   # List imports
                    "iE",   # List exports
                    "iz",   # List strings
                    "iS",   # List sections
                    "ie",   # List entry points
                    "is",   # List symbols
                    "ir"    # List relocations
                ],
                "output_format": "json",
                "max_analysis_time": 300
            },
            "ghidra.json": {
                "headless_args": [
                    "-deleteProject",
                    "-noanalysis"
                ],
                "analysis_timeout": 600,
                "decompiler_timeout": 30
            },
            "gdb.json": {
                "init_commands": [
                    "set pagination off",
                    "set confirm off"
                ],
                "analysis_commands": [
                    "info file",
                    "info functions",
                    "info variables",
                    "info registers"
                ]
            }
        }
        
        for filename, config in tool_configs.items():
            config_file = base_dir / filename
            if not config_file.exists():
                with open(config_file, 'w') as f:
                    json.dump(config, f, indent=2)
    
    def validate_config(self) -> Dict[str, Any]:
        """Validate configuration and return validation results"""
        validation_results = {
            "valid": True,
            "warnings": [],
            "errors": []
        }
        
        # Check required sections
        required_sections = ['tools', 'output', 'security']
        for section in required_sections:
            if section not in self.config:
                validation_results["errors"].append(f"Missing required section: {section}")
                validation_results["valid"] = False
        
        # Check timeout values
        timeouts = [
            'tools.timeout_default',
            'tools.timeout_long'
        ]
        
        for timeout_key in timeouts:
            timeout_value = self.get(timeout_key)
            if timeout_value is not None and (not isinstance(timeout_value, int) or timeout_value <= 0):
                validation_results["warnings"].append(f"Invalid timeout value for {timeout_key}: {timeout_value}")
        
        # Check file size limits
        max_file_size = self.get('security.max_file_size')
        if max_file_size is not None and (not isinstance(max_file_size, int) or max_file_size <= 0):
            validation_results["warnings"].append(f"Invalid max_file_size: {max_file_size}")
        
        return validation_results