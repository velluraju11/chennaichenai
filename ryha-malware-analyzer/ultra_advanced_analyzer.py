#!/usr/bin/env python3
"""
RYHA Ultra Advanced Malware Analyzer
Advanced threat intelligence, geolocation tracking, and forensic analysis
"""

import os
import sys
import json
import time
import hashlib
import requests
import threading
import subprocess
import sqlite3
from datetime import datetime
from typing import Dict, List, Any, Optional
import socket
import struct
import geoip2.database
import geoip2.errors
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich import print as rprint
import psutil
import yara
import magic
import pefile
import ssdeep
import whois
import dns.resolver
import scapy.all as scapy
from urllib.parse import urlparse
import concurrent.futures
import queue
import re
import base64
import binascii

console = Console()

class UltraAdvancedAnalyzer:
    """Ultra Advanced Malware Analyzer with comprehensive threat intelligence"""
    
    def __init__(self):
        self.console = Console()
        self.results = {}
        self.threat_intel_db = "threat_intelligence.db"
        self.malware_families_db = {}
        self.ioc_feeds = []
        self.geolocation_db = None
        self.setup_databases()
        self.setup_threat_intel()
        
    def setup_databases(self):
        """Setup threat intelligence and malware family databases"""
        try:
            # Initialize SQLite database for threat intelligence
            conn = sqlite3.connect(self.threat_intel_db)
            cursor = conn.cursor()
            
            # Create tables for comprehensive threat intelligence
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS threat_actors (
                    id INTEGER PRIMARY KEY,
                    name TEXT UNIQUE,
                    country TEXT,
                    motivation TEXT,
                    capabilities TEXT,
                    known_malware TEXT,
                    last_activity TEXT,
                    attribution_confidence REAL
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS malware_samples (
                    id INTEGER PRIMARY KEY,
                    hash_md5 TEXT,
                    hash_sha1 TEXT,
                    hash_sha256 TEXT,
                    family TEXT,
                    variant TEXT,
                    first_seen TEXT,
                    source_country TEXT,
                    c2_servers TEXT,
                    capabilities TEXT,
                    threat_actor TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS network_indicators (
                    id INTEGER PRIMARY KEY,
                    ip_address TEXT,
                    domain TEXT,
                    url TEXT,
                    indicator_type TEXT,
                    malware_family TEXT,
                    threat_actor TEXT,
                    geolocation TEXT,
                    first_seen TEXT,
                    confidence REAL
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS attack_patterns (
                    id INTEGER PRIMARY KEY,
                    mitre_id TEXT,
                    technique_name TEXT,
                    description TEXT,
                    malware_families TEXT,
                    threat_actors TEXT
                )
            ''')
            
            conn.commit()
            conn.close()
            
            # Load GeoIP database for geolocation tracking
            try:
                self.geolocation_db = geoip2.database.Reader('GeoLite2-City.mmdb')
            except:
                rprint("[yellow]Warning: GeoIP database not found. Download GeoLite2-City.mmdb for geolocation features[/yellow]")
                
        except Exception as e:
            rprint(f"[red]Error setting up databases: {e}[/red]")
    
    def setup_threat_intel(self):
        """Setup threat intelligence feeds and known malware families"""
        # Known APT groups and their characteristics
        self.apt_groups = {
            "APT1": {"country": "China", "motivation": "Espionage", "techniques": ["Spear Phishing", "RATs"]},
            "APT28": {"country": "Russia", "motivation": "Espionage", "techniques": ["Zero-day", "UEFI"]},
            "APT29": {"country": "Russia", "motivation": "Espionage", "techniques": ["Supply Chain", "Cloud"]},
            "Lazarus": {"country": "North Korea", "motivation": "Financial", "techniques": ["Wiper", "Banking"]},
            "APT40": {"country": "China", "motivation": "Espionage", "techniques": ["Web Shells", "MSBuild"]},
            "FIN7": {"country": "Unknown", "motivation": "Financial", "techniques": ["POS", "Carbanak"]},
            "Carbanak": {"country": "Russia", "motivation": "Financial", "techniques": ["ATM", "Banking"]},
            "Equation Group": {"country": "USA", "motivation": "Espionage", "techniques": ["HDD Firmware", "BIOS"]},
            "APT41": {"country": "China", "motivation": "Dual Use", "techniques": ["Supply Chain", "Healthcare"]},
            "DarkHalo": {"country": "Russia", "motivation": "Espionage", "techniques": ["SolarWinds", "Sunburst"]}
        }
        
        # Known malware families and their signatures
        self.malware_families = {
            "Zeus": {"type": "Banking Trojan", "techniques": ["Man-in-Browser", "Form Grabbing"]},
            "Emotet": {"type": "Modular Trojan", "techniques": ["Email Spreading", "Credential Theft"]},
            "TrickBot": {"type": "Banking Trojan", "techniques": ["Web Injection", "Lateral Movement"]},
            "Ryuk": {"type": "Ransomware", "techniques": ["File Encryption", "Network Propagation"]},
            "Conti": {"type": "Ransomware", "techniques": ["Double Extortion", "RDP"]},
            "Cobalt Strike": {"type": "Red Team Tool", "techniques": ["Beacon", "Post-Exploitation"]},
            "Metasploit": {"type": "Penetration Testing", "techniques": ["Exploitation", "Payloads"]},
            "Stuxnet": {"type": "Worm", "techniques": ["PLC", "SCADA", "Zero-day"]},
            "WannaCry": {"type": "Ransomware", "techniques": ["EternalBlue", "SMB"]},
            "NotPetya": {"type": "Wiper", "techniques": ["PsExec", "WMI", "Credential Dumping"]}
        }
        
        # YARA rules for advanced detection
        self.yara_rules = """
        rule APT_Malware_Generic {
            meta:
                description = "Generic APT malware indicators"
                author = "RYHA Ultra Analyzer"
                date = "2025-08-15"
            strings:
                $encrypted_strings = { 48 89 E5 48 83 EC ?? 48 89 7D ?? 48 89 75 ?? }
                $persistence = "\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
                $c2_pattern = /https?:\/\/[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,}/
                $crypto_api = "CryptAcquireContext"
                $process_injection = "CreateRemoteThread"
            condition:
                2 of them
        }
        
        rule Banking_Trojan {
            meta:
                description = "Banking Trojan indicators"
            strings:
                $webinject = "webinject"
                $formgrab = "formgrab"
                $banking_strings = "online banking" nocase
                $certificate_theft = "CertOpenStore"
            condition:
                any of them
        }
        
        rule Ransomware_Indicators {
            meta:
                description = "Ransomware behavior indicators"
            strings:
                $encrypt = "CryptEncrypt"
                $ransom_note = "ransom" nocase
                $file_extensions = ".locked" nocase
                $bitcoin = "bitcoin" nocase
            condition:
                2 of them
        }
        """

    def analyze_file_advanced(self, file_path: str) -> Dict[str, Any]:
        """Comprehensive advanced file analysis"""
        results = {
            "file_info": {},
            "hashes": {},
            "entropy": 0,
            "strings": [],
            "pe_analysis": {},
            "yara_matches": [],
            "threat_intel": {},
            "behavioral_analysis": {},
            "network_analysis": {},
            "attribution": {}
        }
        
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                
                task1 = progress.add_task("Computing file hashes...", total=100)
                results["hashes"] = self.compute_hashes(file_path)
                progress.update(task1, advance=25)
                
                task2 = progress.add_task("Analyzing file structure...", total=100)
                results["file_info"] = self.analyze_file_structure(file_path)
                progress.update(task2, advance=25)
                
                task3 = progress.add_task("Running YARA analysis...", total=100)
                results["yara_matches"] = self.run_yara_analysis(file_path)
                progress.update(task3, advance=25)
                
                task4 = progress.add_task("PE structure analysis...", total=100)
                if file_path.lower().endswith(('.exe', '.dll', '.sys')):
                    results["pe_analysis"] = self.analyze_pe_structure(file_path)
                progress.update(task4, advance=25)
                
                task5 = progress.add_task("Threat intelligence lookup...", total=100)
                results["threat_intel"] = self.threat_intelligence_lookup(results["hashes"])
                progress.update(task5, advance=100)
                
                task6 = progress.add_task("Attribution analysis...", total=100)
                results["attribution"] = self.analyze_attribution(results)
                progress.update(task6, advance=100)
                
        except Exception as e:
            rprint(f"[red]Error in advanced analysis: {e}[/red]")
            
        return results

    def compute_hashes(self, file_path: str) -> Dict[str, str]:
        """Compute multiple hash types for the file"""
        hashes = {}
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            hashes['md5'] = hashlib.md5(data).hexdigest()
            hashes['sha1'] = hashlib.sha1(data).hexdigest()
            hashes['sha256'] = hashlib.sha256(data).hexdigest()
            hashes['sha512'] = hashlib.sha512(data).hexdigest()
            
            # Fuzzy hashing for similarity detection
            try:
                hashes['ssdeep'] = ssdeep.hash(data)
            except:
                hashes['ssdeep'] = "Not available"
                
        except Exception as e:
            rprint(f"[red]Error computing hashes: {e}[/red]")
            
        return hashes

    def analyze_file_structure(self, file_path: str) -> Dict[str, Any]:
        """Analyze file structure and metadata"""
        info = {}
        try:
            # Basic file info
            stat = os.stat(file_path)
            info['size'] = stat.st_size
            info['created'] = datetime.fromtimestamp(stat.st_ctime).isoformat()
            info['modified'] = datetime.fromtimestamp(stat.st_mtime).isoformat()
            
            # File type detection
            try:
                info['mime_type'] = magic.from_file(file_path, mime=True)
                info['file_type'] = magic.from_file(file_path)
            except:
                info['mime_type'] = "Unknown"
                info['file_type'] = "Unknown"
                
            # Entropy calculation for packed detection
            with open(file_path, 'rb') as f:
                data = f.read()
                info['entropy'] = self.calculate_entropy(data)
                
            # Extract strings
            info['suspicious_strings'] = self.extract_suspicious_strings(data)
            
        except Exception as e:
            rprint(f"[red]Error analyzing file structure: {e}[/red]")
            
        return info

    def calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
            
        # Count frequency of each byte
        frequency = {}
        for byte in data:
            frequency[byte] = frequency.get(byte, 0) + 1
            
        # Calculate entropy
        entropy = 0
        data_len = len(data)
        for count in frequency.values():
            if count > 0:
                probability = count / data_len
                entropy -= probability * (probability.bit_length() - 1)
                
        return entropy

    def extract_suspicious_strings(self, data: bytes) -> List[str]:
        """Extract suspicious strings from binary data"""
        suspicious_patterns = [
            r'[A-Za-z0-9+/]{20,}={0,2}',  # Base64
            r'[0-9a-fA-F]{32,}',  # Hex strings
            r'https?://[^\s]+',  # URLs
            r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Emails
            r'(?:[0-9]{1,3}\.){3}[0-9]{1,3}',  # IP addresses
            r'[A-Za-z]:\\[^<>:"|?*\n\r]*',  # Windows paths
            r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion',  # Registry paths
        ]
        
        suspicious_strings = []
        text = data.decode('utf-8', errors='ignore')
        
        for pattern in suspicious_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            suspicious_strings.extend(matches[:10])  # Limit results
            
        return suspicious_strings

    def run_yara_analysis(self, file_path: str) -> List[Dict[str, Any]]:
        """Run YARA rules against the file"""
        matches = []
        try:
            # Compile YARA rules
            rules = yara.compile(source=self.yara_rules)
            
            # Scan file
            yara_matches = rules.match(file_path)
            
            for match in yara_matches:
                match_info = {
                    'rule': match.rule,
                    'meta': dict(match.meta),
                    'strings': []
                }
                
                for string in match.strings:
                    match_info['strings'].append({
                        'identifier': string.identifier,
                        'instances': [{'offset': inst.offset, 'matched_length': inst.matched_length} 
                                    for inst in string.instances]
                    })
                    
                matches.append(match_info)
                
        except Exception as e:
            rprint(f"[red]Error in YARA analysis: {e}[/red]")
            
        return matches

    def analyze_pe_structure(self, file_path: str) -> Dict[str, Any]:
        """Analyze PE file structure"""
        pe_info = {}
        try:
            pe = pefile.PE(file_path)
            
            # Basic PE info
            pe_info['machine'] = hex(pe.FILE_HEADER.Machine)
            pe_info['timestamp'] = datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp).isoformat()
            pe_info['entry_point'] = hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
            pe_info['image_base'] = hex(pe.OPTIONAL_HEADER.ImageBase)
            
            # Sections analysis
            sections = []
            for section in pe.sections:
                section_info = {
                    'name': section.Name.decode('utf-8').strip('\x00'),
                    'virtual_address': hex(section.VirtualAddress),
                    'size': section.SizeOfRawData,
                    'entropy': section.get_entropy(),
                    'characteristics': hex(section.Characteristics)
                }
                sections.append(section_info)
            pe_info['sections'] = sections
            
            # Imports analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                imports = []
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_imports = {
                        'dll': entry.dll.decode('utf-8'),
                        'functions': []
                    }
                    for imp in entry.imports:
                        if imp.name:
                            dll_imports['functions'].append(imp.name.decode('utf-8'))
                    imports.append(dll_imports)
                pe_info['imports'] = imports[:10]  # Limit results
                
            # Check for suspicious characteristics
            pe_info['suspicious_indicators'] = self.check_pe_suspicious_indicators(pe)
            
            pe.close()
            
        except Exception as e:
            rprint(f"[red]Error analyzing PE structure: {e}[/red]")
            
        return pe_info

    def check_pe_suspicious_indicators(self, pe) -> List[str]:
        """Check for suspicious PE indicators"""
        indicators = []
        
        try:
            # Check for packed sections (high entropy)
            for section in pe.sections:
                if section.get_entropy() > 7.0:
                    indicators.append(f"High entropy section: {section.Name.decode('utf-8').strip()}")
                    
            # Check for suspicious imports
            suspicious_apis = [
                'CreateRemoteThread', 'WriteProcessMemory', 'VirtualAllocEx',
                'SetWindowsHookEx', 'GetProcAddress', 'LoadLibrary',
                'CryptAcquireContext', 'InternetOpen', 'HttpSendRequest'
            ]
            
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    for imp in entry.imports:
                        if imp.name and imp.name.decode('utf-8') in suspicious_apis:
                            indicators.append(f"Suspicious API: {imp.name.decode('utf-8')}")
                            
            # Check for unusual entry point
            if pe.OPTIONAL_HEADER.AddressOfEntryPoint < 0x1000:
                indicators.append("Unusual entry point location")
                
        except Exception as e:
            rprint(f"[red]Error checking PE indicators: {e}[/red]")
            
        return indicators

    def threat_intelligence_lookup(self, hashes: Dict[str, str]) -> Dict[str, Any]:
        """Lookup threat intelligence for file hashes"""
        threat_intel = {
            'virustotal': {},
            'malware_bazaar': {},
            'hybrid_analysis': {},
            'known_families': [],
            'threat_actors': []
        }
        
        try:
            # VirusTotal lookup (requires API key)
            vt_results = self.virustotal_lookup(hashes.get('sha256', ''))
            if vt_results:
                threat_intel['virustotal'] = vt_results
                
            # MalwareBazaar lookup
            mb_results = self.malware_bazaar_lookup(hashes.get('sha256', ''))
            if mb_results:
                threat_intel['malware_bazaar'] = mb_results
                
            # Check against known malware families
            threat_intel['known_families'] = self.check_known_families(hashes)
            
        except Exception as e:
            rprint(f"[red]Error in threat intelligence lookup: {e}[/red]")
            
        return threat_intel

    def virustotal_lookup(self, sha256: str) -> Dict[str, Any]:
        """Lookup file hash in VirusTotal"""
        # Note: Requires VirusTotal API key
        # This is a placeholder implementation
        return {
            'scanned': False,
            'detection_ratio': '0/0',
            'scan_date': 'Not available',
            'permalink': f'https://www.virustotal.com/gui/file/{sha256}'
        }

    def malware_bazaar_lookup(self, sha256: str) -> Dict[str, Any]:
        """Lookup file hash in MalwareBazaar"""
        try:
            url = "https://mb-api.abuse.ch/api/v1/"
            data = {
                'query': 'get_info',
                'hash': sha256
            }
            
            response = requests.post(url, data=data, timeout=10)
            if response.status_code == 200:
                return response.json()
                
        except Exception as e:
            rprint(f"[yellow]MalwareBazaar lookup failed: {e}[/yellow]")
            
        return {}

    def check_known_families(self, hashes: Dict[str, str]) -> List[str]:
        """Check against database of known malware families"""
        families = []
        
        try:
            conn = sqlite3.connect(self.threat_intel_db)
            cursor = conn.cursor()
            
            for hash_type, hash_value in hashes.items():
                if hash_type in ['md5', 'sha1', 'sha256']:
                    cursor.execute(f"SELECT family FROM malware_samples WHERE hash_{hash_type} = ?", (hash_value,))
                    result = cursor.fetchone()
                    if result:
                        families.append(result[0])
                        
            conn.close()
            
        except Exception as e:
            rprint(f"[red]Error checking known families: {e}[/red]")
            
        return families

    def analyze_attribution(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze potential threat actor attribution"""
        attribution = {
            'likely_actors': [],
            'confidence_scores': {},
            'attribution_indicators': [],
            'geolocation_clues': [],
            'campaign_indicators': []
        }
        
        try:
            # Analyze compilation timestamps
            if 'pe_analysis' in analysis_results and 'timestamp' in analysis_results['pe_analysis']:
                attribution['compilation_time'] = analysis_results['pe_analysis']['timestamp']
                
            # Check for known malware family indicators
            threat_intel = analysis_results.get('threat_intel', {})
            known_families = threat_intel.get('known_families', [])
            
            for family in known_families:
                if family in self.malware_families:
                    attribution['attribution_indicators'].append(f"Known malware family: {family}")
                    
            # Analyze suspicious strings for attribution clues
            file_info = analysis_results.get('file_info', {})
            suspicious_strings = file_info.get('suspicious_strings', [])
            
            # Look for language-specific strings, URLs, etc.
            for string in suspicious_strings:
                if self.is_url(string):
                    domain = urlparse(string).netloc
                    geo_info = self.geolocate_domain(domain)
                    if geo_info:
                        attribution['geolocation_clues'].append(geo_info)
                        
            # Calculate confidence scores for different threat actors
            for actor, info in self.apt_groups.items():
                confidence = self.calculate_actor_confidence(analysis_results, actor, info)
                if confidence > 0.3:  # Threshold for inclusion
                    attribution['confidence_scores'][actor] = confidence
                    attribution['likely_actors'].append(actor)
                    
        except Exception as e:
            rprint(f"[red]Error in attribution analysis: {e}[/red]")
            
        return attribution

    def is_url(self, string: str) -> bool:
        """Check if string is a URL"""
        try:
            result = urlparse(string)
            return all([result.scheme, result.netloc])
        except:
            return False

    def geolocate_domain(self, domain: str) -> Optional[Dict[str, Any]]:
        """Geolocate a domain name"""
        try:
            # Resolve domain to IP
            answers = dns.resolver.resolve(domain, 'A')
            ip = str(answers[0])
            
            # Geolocate IP
            if self.geolocation_db:
                response = self.geolocation_db.city(ip)
                return {
                    'ip': ip,
                    'country': response.country.name,
                    'city': response.city.name,
                    'latitude': float(response.location.latitude) if response.location.latitude else None,
                    'longitude': float(response.location.longitude) if response.location.longitude else None
                }
                
        except Exception:
            pass
            
        return None

    def calculate_actor_confidence(self, analysis_results: Dict[str, Any], actor: str, actor_info: Dict[str, Any]) -> float:
        """Calculate confidence score for threat actor attribution"""
        confidence = 0.0
        
        try:
            # Check YARA matches against known techniques
            yara_matches = analysis_results.get('yara_matches', [])
            for match in yara_matches:
                rule_name = match.get('rule', '')
                if any(technique.lower() in rule_name.lower() for technique in actor_info.get('techniques', [])):
                    confidence += 0.3
                    
            # Check PE characteristics
            pe_analysis = analysis_results.get('pe_analysis', {})
            suspicious_indicators = pe_analysis.get('suspicious_indicators', [])
            
            # Country-specific indicators
            geolocation_clues = analysis_results.get('attribution', {}).get('geolocation_clues', [])
            for clue in geolocation_clues:
                if clue.get('country') == actor_info.get('country'):
                    confidence += 0.4
                    
            # Normalize confidence score
            confidence = min(confidence, 1.0)
            
        except Exception as e:
            rprint(f"[red]Error calculating actor confidence: {e}[/red]")
            
        return confidence

    def network_traffic_analysis(self, pcap_file: Optional[str] = None) -> Dict[str, Any]:
        """Analyze network traffic for C2 communication patterns"""
        network_analysis = {
            'suspicious_connections': [],
            'c2_indicators': [],
            'dns_requests': [],
            'http_traffic': [],
            'encryption_detected': False
        }
        
        try:
            if pcap_file and os.path.exists(pcap_file):
                packets = scapy.rdpcap(pcap_file)
                
                for packet in packets[:1000]:  # Limit analysis
                    if packet.haslayer(scapy.IP):
                        src_ip = packet[scapy.IP].src
                        dst_ip = packet[scapy.IP].dst
                        
                        # Geolocate IPs
                        src_geo = self.geolocate_ip(src_ip)
                        dst_geo = self.geolocate_ip(dst_ip)
                        
                        connection = {
                            'src_ip': src_ip,
                            'dst_ip': dst_ip,
                            'src_geo': src_geo,
                            'dst_geo': dst_geo,
                            'protocol': packet[scapy.IP].proto
                        }
                        
                        # Check for suspicious connections
                        if self.is_suspicious_connection(src_ip, dst_ip):
                            network_analysis['suspicious_connections'].append(connection)
                            
                    # Analyze DNS requests
                    if packet.haslayer(scapy.DNS):
                        dns_query = packet[scapy.DNS].qd.qname.decode('utf-8')
                        network_analysis['dns_requests'].append(dns_query)
                        
                        # Check for DGA domains
                        if self.is_dga_domain(dns_query):
                            network_analysis['c2_indicators'].append(f"Potential DGA domain: {dns_query}")
                            
        except Exception as e:
            rprint(f"[red]Error in network analysis: {e}[/red]")
            
        return network_analysis

    def geolocate_ip(self, ip: str) -> Optional[Dict[str, Any]]:
        """Geolocate an IP address"""
        try:
            if self.geolocation_db:
                response = self.geolocation_db.city(ip)
                return {
                    'country': response.country.name,
                    'city': response.city.name,
                    'latitude': float(response.location.latitude) if response.location.latitude else None,
                    'longitude': float(response.location.longitude) if response.location.longitude else None
                }
        except:
            pass
        return None

    def is_suspicious_connection(self, src_ip: str, dst_ip: str) -> bool:
        """Check if connection is suspicious"""
        # Check against known malicious IP ranges
        suspicious_ranges = [
            '10.0.0.0/8',    # Private networks (suspicious in malware context)
            '172.16.0.0/12',
            '192.168.0.0/16'
        ]
        
        # Check for connections to known bad countries/regions
        dst_geo = self.geolocate_ip(dst_ip)
        if dst_geo:
            suspicious_countries = ['Unknown', 'Anonymous Proxy']
            if dst_geo.get('country') in suspicious_countries:
                return True
                
        return False

    def is_dga_domain(self, domain: str) -> bool:
        """Check if domain looks like DGA (Domain Generation Algorithm)"""
        # Simple heuristics for DGA detection
        if len(domain) < 6:
            return False
            
        # Calculate entropy of domain name
        entropy = self.calculate_entropy(domain.encode())
        
        # Check for random-looking patterns
        consonant_count = sum(1 for c in domain.lower() if c in 'bcdfghjklmnpqrstvwxyz')
        vowel_count = sum(1 for c in domain.lower() if c in 'aeiou')
        
        # DGA domains often have high entropy and unusual consonant/vowel ratios
        if entropy > 3.5 and consonant_count > vowel_count * 2:
            return True
            
        return False

    def behavioral_analysis(self, file_path: str) -> Dict[str, Any]:
        """Perform behavioral analysis using dynamic execution"""
        behavioral = {
            'process_creation': [],
            'file_operations': [],
            'registry_operations': [],
            'network_activity': [],
            'persistence_mechanisms': []
        }
        
        # Note: This would require a sandbox environment
        # Placeholder for behavioral analysis capabilities
        rprint("[yellow]Behavioral analysis requires sandbox environment[/yellow]")
        
        return behavioral

    def generate_comprehensive_report(self, analysis_results: Dict[str, Any], output_file: str):
        """Generate comprehensive analysis report"""
        try:
            timestamp = datetime.now().isoformat()
            
            report = {
                "analysis_metadata": {
                    "timestamp": timestamp,
                    "analyzer": "RYHA Ultra Advanced Analyzer v3.0",
                    "analysis_type": "Comprehensive Threat Intelligence"
                },
                "executive_summary": self.generate_executive_summary(analysis_results),
                "detailed_analysis": analysis_results,
                "threat_assessment": self.generate_threat_assessment(analysis_results),
                "mitigation_recommendations": self.generate_mitigation_recommendations(analysis_results),
                "iocs": self.extract_iocs(analysis_results)
            }
            
            # Save JSON report
            with open(output_file, 'w') as f:
                json.dump(report, f, indent=2, default=str)
                
            # Generate human-readable report
            self.generate_human_readable_report(report, output_file.replace('.json', '.md'))
            
            rprint(f"[green]Comprehensive report saved to: {output_file}[/green]")
            
        except Exception as e:
            rprint(f"[red]Error generating report: {e}[/red]")

    def generate_executive_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate executive summary of analysis"""
        summary = {
            "threat_level": "Unknown",
            "confidence": 0.0,
            "key_findings": [],
            "recommended_actions": []
        }
        
        try:
            # Determine threat level based on analysis
            yara_matches = len(results.get('yara_matches', []))
            attribution = results.get('attribution', {})
            likely_actors = attribution.get('likely_actors', [])
            
            if yara_matches > 2 or likely_actors:
                summary["threat_level"] = "High"
                summary["confidence"] = 0.8
            elif yara_matches > 0:
                summary["threat_level"] = "Medium"
                summary["confidence"] = 0.6
            else:
                summary["threat_level"] = "Low"
                summary["confidence"] = 0.3
                
            # Key findings
            if yara_matches > 0:
                summary["key_findings"].append(f"Matched {yara_matches} YARA rules")
                
            if likely_actors:
                summary["key_findings"].append(f"Potential threat actors: {', '.join(likely_actors)}")
                
            # Recommendations
            if summary["threat_level"] in ["High", "Medium"]:
                summary["recommended_actions"] = [
                    "Immediate quarantine recommended",
                    "Full network scan advised",
                    "Review access logs",
                    "Update security policies"
                ]
                
        except Exception as e:
            rprint(f"[red]Error generating executive summary: {e}[/red]")
            
        return summary

    def generate_threat_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate detailed threat assessment"""
        assessment = {
            "malware_family": "Unknown",
            "attack_vectors": [],
            "capabilities": [],
            "persistence_methods": [],
            "data_exfiltration_risk": "Low"
        }
        
        try:
            # Analyze PE imports for capabilities
            pe_analysis = results.get('pe_analysis', {})
            imports = pe_analysis.get('imports', [])
            
            for dll_import in imports:
                dll_name = dll_import.get('dll', '').lower()
                functions = dll_import.get('functions', [])
                
                # Network capabilities
                if dll_name in ['wininet.dll', 'ws2_32.dll']:
                    assessment["capabilities"].append("Network communication")
                    assessment["data_exfiltration_risk"] = "High"
                    
                # Persistence capabilities
                if dll_name in ['advapi32.dll'] and any('reg' in func.lower() for func in functions):
                    assessment["persistence_methods"].append("Registry modification")
                    
                # Process manipulation
                if any(func in ['CreateRemoteThread', 'WriteProcessMemory'] for func in functions):
                    assessment["capabilities"].append("Process injection")
                    
        except Exception as e:
            rprint(f"[red]Error generating threat assessment: {e}[/red]")
            
        return assessment

    def generate_mitigation_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate mitigation recommendations"""
        recommendations = []
        
        try:
            executive_summary = self.generate_executive_summary(results)
            threat_level = executive_summary.get("threat_level", "Unknown")
            
            if threat_level == "High":
                recommendations.extend([
                    "Immediate isolation of affected systems",
                    "Deploy advanced threat detection",
                    "Conduct forensic investigation",
                    "Review and update incident response procedures",
                    "Implement additional network segmentation"
                ])
            elif threat_level == "Medium":
                recommendations.extend([
                    "Enhanced monitoring of affected systems",
                    "Update antivirus signatures",
                    "Review access controls",
                    "Conduct security awareness training"
                ])
            else:
                recommendations.extend([
                    "Continue routine monitoring",
                    "Maintain current security posture",
                    "Regular security updates"
                ])
                
        except Exception as e:
            rprint(f"[red]Error generating recommendations: {e}[/red]")
            
        return recommendations

    def extract_iocs(self, results: Dict[str, Any]) -> Dict[str, List[str]]:
        """Extract Indicators of Compromise (IOCs)"""
        iocs = {
            "file_hashes": [],
            "ip_addresses": [],
            "domains": [],
            "urls": [],
            "registry_keys": [],
            "file_paths": []
        }
        
        try:
            # File hashes
            hashes = results.get('hashes', {})
            for hash_type, hash_value in hashes.items():
                if hash_type in ['md5', 'sha1', 'sha256']:
                    iocs["file_hashes"].append(f"{hash_type.upper()}: {hash_value}")
                    
            # Extract from suspicious strings
            file_info = results.get('file_info', {})
            suspicious_strings = file_info.get('suspicious_strings', [])
            
            for string in suspicious_strings:
                if self.is_url(string):
                    iocs["urls"].append(string)
                    domain = urlparse(string).netloc
                    if domain:
                        iocs["domains"].append(domain)
                elif re.match(r'(?:[0-9]{1,3}\.){3}[0-9]{1,3}', string):
                    iocs["ip_addresses"].append(string)
                elif 'SOFTWARE\\Microsoft\\Windows' in string:
                    iocs["registry_keys"].append(string)
                elif string.startswith(('C:\\', 'D:\\', '\\\\', '/')):
                    iocs["file_paths"].append(string)
                    
        except Exception as e:
            rprint(f"[red]Error extracting IOCs: {e}[/red]")
            
        return iocs

    def generate_human_readable_report(self, report: Dict[str, Any], output_file: str):
        """Generate human-readable markdown report"""
        try:
            with open(output_file, 'w') as f:
                f.write("# RYHA Ultra Advanced Malware Analysis Report\n\n")
                
                # Executive Summary
                summary = report.get("executive_summary", {})
                f.write("## Executive Summary\n\n")
                f.write(f"**Threat Level:** {summary.get('threat_level', 'Unknown')}\n\n")
                f.write(f"**Confidence:** {summary.get('confidence', 0.0):.2f}\n\n")
                
                key_findings = summary.get('key_findings', [])
                if key_findings:
                    f.write("### Key Findings\n\n")
                    for finding in key_findings:
                        f.write(f"- {finding}\n")
                    f.write("\n")
                
                # Attribution Analysis
                attribution = report["detailed_analysis"].get("attribution", {})
                if attribution.get("likely_actors"):
                    f.write("## Attribution Analysis\n\n")
                    f.write("### Likely Threat Actors\n\n")
                    for actor in attribution["likely_actors"]:
                        confidence = attribution.get("confidence_scores", {}).get(actor, 0.0)
                        f.write(f"- **{actor}** (Confidence: {confidence:.2f})\n")
                    f.write("\n")
                
                # IOCs
                iocs = report.get("iocs", {})
                f.write("## Indicators of Compromise (IOCs)\n\n")
                
                for ioc_type, ioc_list in iocs.items():
                    if ioc_list:
                        f.write(f"### {ioc_type.replace('_', ' ').title()}\n\n")
                        for ioc in ioc_list[:10]:  # Limit to first 10
                            f.write(f"- `{ioc}`\n")
                        f.write("\n")
                
                # Mitigation Recommendations
                recommendations = report.get("mitigation_recommendations", [])
                if recommendations:
                    f.write("## Mitigation Recommendations\n\n")
                    for i, rec in enumerate(recommendations, 1):
                        f.write(f"{i}. {rec}\n")
                    f.write("\n")
                
            rprint(f"[green]Human-readable report saved to: {output_file}[/green]")
            
        except Exception as e:
            rprint(f"[red]Error generating human-readable report: {e}[/red]")

    def display_results_table(self, results: Dict[str, Any]):
        """Display analysis results in a formatted table"""
        # Executive Summary Table
        summary = self.generate_executive_summary(results)
        
        summary_table = Table(title="🛡️ Analysis Summary", show_header=True, header_style="bold magenta")
        summary_table.add_column("Metric", style="cyan")
        summary_table.add_column("Value", style="green")
        
        summary_table.add_row("Threat Level", summary.get("threat_level", "Unknown"))
        summary_table.add_row("Confidence", f"{summary.get('confidence', 0.0):.2f}")
        summary_table.add_row("File Size", str(results.get('file_info', {}).get('size', 'Unknown')))
        summary_table.add_row("Entropy", f"{results.get('file_info', {}).get('entropy', 0.0):.2f}")
        
        console.print(summary_table)
        console.print()
        
        # Attribution Table
        attribution = results.get('attribution', {})
        if attribution.get('likely_actors'):
            attr_table = Table(title="🎯 Attribution Analysis", show_header=True, header_style="bold red")
            attr_table.add_column("Threat Actor", style="cyan")
            attr_table.add_column("Confidence", style="yellow")
            attr_table.add_column("Country", style="green")
            
            for actor in attribution['likely_actors']:
                confidence = attribution.get('confidence_scores', {}).get(actor, 0.0)
                country = self.apt_groups.get(actor, {}).get('country', 'Unknown')
                attr_table.add_row(actor, f"{confidence:.2f}", country)
                
            console.print(attr_table)
            console.print()
        
        # YARA Matches Table
        yara_matches = results.get('yara_matches', [])
        if yara_matches:
            yara_table = Table(title="🔍 YARA Detections", show_header=True, header_style="bold yellow")
            yara_table.add_column("Rule", style="cyan")
            yara_table.add_column("Description", style="green")
            
            for match in yara_matches:
                rule = match.get('rule', 'Unknown')
                description = match.get('meta', {}).get('description', 'No description')
                yara_table.add_row(rule, description)
                
            console.print(yara_table)

def main():
    """Main function for ultra advanced analyzer"""
    console = Console()
    
    # Display banner
    banner = """
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║                    🛡️  RYHA ULTRA ADVANCED ANALYZER 🛡️                      ║
    ║                                                                              ║
    ║    🔥 Advanced Threat Intelligence & Attribution Analysis                    ║
    ║    🌍 Geolocation Tracking & Hacker Attribution                            ║
    ║    🎯 APT Group Detection & Campaign Analysis                               ║
    ║    🔍 Comprehensive IOC Extraction & YARA Detection                        ║
    ║    📊 Real-time Network Traffic Analysis                                   ║
    ║                                                                              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝
    """
    
    console.print(Panel(banner, style="bold green"))
    
    if len(sys.argv) < 2:
        console.print("[red]Usage: python ultra_advanced_analyzer.py <file_path> [pcap_file][/red]")
        sys.exit(1)
    
    file_path = sys.argv[1]
    pcap_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not os.path.exists(file_path):
        console.print(f"[red]File not found: {file_path}[/red]")
        sys.exit(1)
    
    # Initialize analyzer
    analyzer = UltraAdvancedAnalyzer()
    
    # Run comprehensive analysis
    console.print("[bold cyan]Starting ultra advanced analysis...[/bold cyan]")
    
    with console.status("[bold green]Analyzing file...") as status:
        results = analyzer.analyze_file_advanced(file_path)
        
        if pcap_file:
            status.update("[bold green]Analyzing network traffic...")
            results['network_analysis'] = analyzer.network_traffic_analysis(pcap_file)
        
        status.update("[bold green]Performing behavioral analysis...")
        results['behavioral_analysis'] = analyzer.behavioral_analysis(file_path)
    
    # Display results
    analyzer.display_results_table(results)
    
    # Generate comprehensive report
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"ultra_advanced_analysis_{timestamp}.json"
    
    console.print(f"\n[bold cyan]Generating comprehensive report...[/bold cyan]")
    analyzer.generate_comprehensive_report(results, output_file)
    
    console.print(f"\n[bold green]✅ Ultra advanced analysis completed![/bold green]")
    console.print(f"[green]Report saved to: {output_file}[/green]")

if __name__ == "__main__":
    main()
