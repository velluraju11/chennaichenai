#!/usr/bin/env python3
"""
RYHA Ultra Advanced Malware Analyzer - Simplified Demo Version
Advanced threat intelligence and attribution analysis (Demo Mode)
"""

import os
import sys
import json
import time
import hashlib
import requests
import threading
import subprocess
import sqlite3
from datetime import datetime
from typing import Dict, List, Any, Optional
import socket
import struct
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich import print as rprint
import psutil
import re
import base64
import binascii

console = Console()

class UltraAdvancedAnalyzerDemo:
    """Ultra Advanced Malware Analyzer Demo Version"""
    
    def __init__(self):
        self.console = Console()
        self.results = {}
        self.threat_intel_db = "threat_intelligence_demo.db"
        self.setup_databases()
        self.setup_threat_intel()
        
    def setup_databases(self):
        """Setup demo threat intelligence database"""
        try:
            conn = sqlite3.connect(self.threat_intel_db)
            cursor = conn.cursor()
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS threat_actors (
                    id INTEGER PRIMARY KEY,
                    name TEXT UNIQUE,
                    country TEXT,
                    motivation TEXT,
                    malware_families TEXT
                )
            ''')
            
            # Insert demo threat actors
            demo_actors = [
                ("APT1", "China", "Espionage", "Backdoor.APT1,Seasalt"),
                ("APT28", "Russia", "Espionage", "X-Agent,Seduploader"),
                ("APT29", "Russia", "Espionage", "SUNBURST,TEARDROP"),
                ("Lazarus", "North Korea", "Financial", "WannaCry,HOPLIGHT"),
                ("APT40", "China", "Espionage", "China Chopper,Caterpillar")
            ]
            
            for actor in demo_actors:
                cursor.execute("INSERT OR IGNORE INTO threat_actors (name, country, motivation, malware_families) VALUES (?, ?, ?, ?)", actor)
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            rprint(f"[red]Error setting up demo database: {e}[/red]")
    
    def setup_threat_intel(self):
        """Setup demo threat intelligence data"""
        self.apt_groups = {
            "APT1": {
                "country": "China", 
                "motivation": "Espionage",
                "techniques": ["Spear Phishing", "RATs", "Credential Theft"],
                "indicators": ["apt", "china", "remote", "backdoor"]
            },
            "APT28": {
                "country": "Russia",
                "motivation": "Espionage", 
                "techniques": ["Zero-day", "UEFI", "Spear Phishing"],
                "indicators": ["russia", "sofacy", "fancy", "x-agent"]
            },
            "APT29": {
                "country": "Russia",
                "motivation": "Espionage",
                "techniques": ["Supply Chain", "Cloud", "SUNBURST"], 
                "indicators": ["cozy", "bear", "sunburst", "teardrop"]
            },
            "Lazarus": {
                "country": "North Korea",
                "motivation": "Financial",
                "techniques": ["Wiper", "Banking", "Ransomware"],
                "indicators": ["lazarus", "wannacry", "north", "korea"]
            },
            "APT40": {
                "country": "China", 
                "motivation": "Espionage",
                "techniques": ["Web Shells", "MSBuild", "Maritime"],
                "indicators": ["leviathan", "china", "chopper", "web"]
            }
        }

    def analyze_file_advanced(self, file_path: str) -> Dict[str, Any]:
        """Comprehensive demo analysis"""
        results = {
            "file_info": {},
            "hashes": {},
            "strings": [],
            "pe_analysis": {},
            "yara_matches": [],
            "threat_intel": {},
            "attribution": {},
            "network_analysis": {},
            "geolocation_intel": {}
        }
        
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                
                task1 = progress.add_task("🔐 Computing cryptographic hashes...", total=100)
                results["hashes"] = self.compute_hashes(file_path)
                progress.update(task1, advance=100)
                
                task2 = progress.add_task("🔍 Analyzing file structure and metadata...", total=100)
                results["file_info"] = self.analyze_file_structure(file_path)
                progress.update(task2, advance=100)
                
                task3 = progress.add_task("🎯 Extracting suspicious strings and IOCs...", total=100)
                results["strings"] = self.extract_suspicious_strings_from_file(file_path)
                progress.update(task3, advance=100)
                
                task4 = progress.add_task("🛡️ Running behavioral pattern analysis...", total=100)
                results["yara_matches"] = self.simulate_yara_analysis(file_path)
                progress.update(task4, advance=100)
                
                task5 = progress.add_task("🧠 Performing threat intelligence lookup...", total=100)
                results["threat_intel"] = self.threat_intelligence_lookup(results)
                progress.update(task5, advance=100)
                
                task6 = progress.add_task("🎯 Analyzing threat actor attribution...", total=100)
                results["attribution"] = self.analyze_attribution(results)
                progress.update(task6, advance=100)
                
                task7 = progress.add_task("🌐 Simulating network analysis...", total=100)
                results["network_analysis"] = self.simulate_network_analysis(results)
                progress.update(task7, advance=100)
                
                task8 = progress.add_task("🗺️ Performing geolocation intelligence...", total=100)
                results["geolocation_intel"] = self.simulate_geolocation_analysis(results)
                progress.update(task8, advance=100)
                
        except Exception as e:
            rprint(f"[red]Error in advanced analysis: {e}[/red]")
            
        return results

    def compute_hashes(self, file_path: str) -> Dict[str, str]:
        """Compute cryptographic hashes"""
        hashes = {}
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            hashes['md5'] = hashlib.md5(data).hexdigest()
            hashes['sha1'] = hashlib.sha1(data).hexdigest()
            hashes['sha256'] = hashlib.sha256(data).hexdigest()
            hashes['sha512'] = hashlib.sha512(data).hexdigest()
            hashes['file_size'] = len(data)
            
        except Exception as e:
            rprint(f"[red]Error computing hashes: {e}[/red]")
            
        return hashes

    def analyze_file_structure(self, file_path: str) -> Dict[str, Any]:
        """Analyze file structure and metadata"""
        info = {}
        try:
            stat = os.stat(file_path)
            info['size'] = stat.st_size
            info['created'] = datetime.fromtimestamp(stat.st_ctime).isoformat()
            info['modified'] = datetime.fromtimestamp(stat.st_mtime).isoformat()
            
            # Read file content for analysis
            with open(file_path, 'rb') as f:
                data = f.read()
                
            # Calculate entropy
            info['entropy'] = self.calculate_entropy(data)
            
            # Check file type
            if data.startswith(b'MZ'):
                info['file_type'] = 'PE Executable'
                info['mime_type'] = 'application/x-executable'
            else:
                info['file_type'] = 'Unknown Binary'
                info['mime_type'] = 'application/octet-stream'
                
        except Exception as e:
            rprint(f"[red]Error analyzing file structure: {e}[/red]")
            
        return info

    def calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0
            
        frequency = {}
        for byte in data:
            frequency[byte] = frequency.get(byte, 0) + 1
            
        entropy = 0
        data_len = len(data)
        for count in frequency.values():
            if count > 0:
                probability = count / data_len
                if probability > 0:
                    entropy -= probability * (probability.bit_length() - 1)
                
        return entropy

    def extract_suspicious_strings_from_file(self, file_path: str) -> List[str]:
        """Extract suspicious strings from file"""
        suspicious_strings = []
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            text = data.decode('utf-8', errors='ignore')
            
            patterns = [
                r'[A-Za-z0-9+/]{20,}={0,2}',  # Base64
                r'https?://[^\s]+',  # URLs
                r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Emails
                r'(?:[0-9]{1,3}\.){3}[0-9]{1,3}',  # IP addresses
                r'[A-Za-z]:\\[^<>:"|?*\n\r]*',  # Windows paths
                r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion',  # Registry
                r'CreateRemoteThread|WriteProcessMemory|VirtualAllocEx',  # APIs
                r'APT|LAZARUS|CHINA|RUSSIA',  # Attribution indicators
            ]
            
            for pattern in patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                suspicious_strings.extend(matches[:5])  # Limit results
                
        except Exception as e:
            rprint(f"[red]Error extracting strings: {e}[/red]")
            
        return suspicious_strings

    def simulate_yara_analysis(self, file_path: str) -> List[Dict[str, Any]]:
        """Simulate YARA rule matching"""
        matches = []
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read().decode('utf-8', errors='ignore')
                
            # Simulate YARA rule matches based on content
            if 'CreateRemoteThread' in data:
                matches.append({
                    'rule': 'Process_Injection_APIs',
                    'meta': {'description': 'Process injection techniques detected'},
                    'confidence': 0.8
                })
                
            if 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' in data:
                matches.append({
                    'rule': 'Registry_Persistence', 
                    'meta': {'description': 'Registry persistence mechanism'},
                    'confidence': 0.7
                })
                
            if any(word in data.upper() for word in ['APT', 'CHINA', 'LAZARUS']):
                matches.append({
                    'rule': 'APT_Attribution_Indicators',
                    'meta': {'description': 'APT group attribution indicators found'},
                    'confidence': 0.9
                })
                
            if 'http://' in data or 'https://' in data:
                matches.append({
                    'rule': 'Network_Communication',
                    'meta': {'description': 'Network communication patterns'},
                    'confidence': 0.6
                })
                
        except Exception as e:
            rprint(f"[red]Error in YARA simulation: {e}[/red]")
            
        return matches

    def threat_intelligence_lookup(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate threat intelligence lookup"""
        threat_intel = {
            'known_families': [],
            'reputation_score': 0,
            'first_seen': None,
            'last_seen': None,
            'intelligence_sources': []
        }
        
        try:
            # Simulate hash lookup
            hashes = analysis_results.get('hashes', {})
            sha256 = hashes.get('sha256', '')
            
            # Simulate known malware family detection
            suspicious_strings = analysis_results.get('strings', [])
            for string in suspicious_strings:
                if 'APT' in string.upper():
                    threat_intel['known_families'].append('APT_Unknown')
                    threat_intel['reputation_score'] = 85
                elif 'LAZARUS' in string.upper():
                    threat_intel['known_families'].append('Lazarus_Group')
                    threat_intel['reputation_score'] = 95
                elif 'CHINA' in string.upper():
                    threat_intel['known_families'].append('Chinese_APT')
                    threat_intel['reputation_score'] = 80
                    
            # Set dates
            threat_intel['first_seen'] = datetime.now().isoformat()
            threat_intel['intelligence_sources'] = ['VirusTotal_Demo', 'MalwareBazaar_Demo']
            
        except Exception as e:
            rprint(f"[red]Error in threat intelligence lookup: {e}[/red]")
            
        return threat_intel

    def analyze_attribution(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze threat actor attribution"""
        attribution = {
            'primary_suspects': [],
            'confidence_scores': {},
            'attribution_evidence': {},
            'final_assessment': {}
        }
        
        try:
            suspicious_strings = analysis_results.get('strings', [])
            yara_matches = analysis_results.get('yara_matches', [])
            
            # Calculate attribution scores for each APT group
            for actor, info in self.apt_groups.items():
                confidence = 0.0
                evidence = []
                
                # Check for attribution indicators in strings
                for string in suspicious_strings:
                    for indicator in info['indicators']:
                        if indicator.lower() in string.lower():
                            confidence += 0.3
                            evidence.append(f"String indicator: {indicator}")
                            
                # Check YARA matches
                for match in yara_matches:
                    rule_name = match.get('rule', '').lower()
                    if any(technique.lower() in rule_name for technique in info['techniques']):
                        confidence += 0.2
                        evidence.append(f"Technique match: {match.get('rule')}")
                        
                # Normalize confidence
                confidence = min(confidence, 1.0)
                
                if confidence > 0.2:
                    attribution['confidence_scores'][actor] = confidence
                    attribution['attribution_evidence'][actor] = evidence
                    
            # Sort by confidence
            sorted_actors = sorted(attribution['confidence_scores'].items(), 
                                 key=lambda x: x[1], reverse=True)
            
            attribution['primary_suspects'] = [actor for actor, conf in sorted_actors[:3]]
            
            # Generate final assessment
            if sorted_actors:
                top_actor, top_confidence = sorted_actors[0]
                attribution['final_assessment'] = {
                    'primary_attribution': top_actor,
                    'confidence_level': 'High' if top_confidence > 0.7 else 'Medium' if top_confidence > 0.4 else 'Low',
                    'country': self.apt_groups[top_actor]['country'],
                    'motivation': self.apt_groups[top_actor]['motivation']
                }
                
        except Exception as e:
            rprint(f"[red]Error in attribution analysis: {e}[/red]")
            
        return attribution

    def simulate_network_analysis(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate network traffic analysis"""
        network_analysis = {
            'c2_communications': [],
            'suspicious_connections': [],
            'dns_requests': [],
            'data_exfiltration_risk': 'Medium'
        }
        
        try:
            suspicious_strings = analysis_results.get('strings', [])
            
            # Look for network indicators in strings
            for string in suspicious_strings:
                # URLs indicate C2 communication
                if string.startswith(('http://', 'https://')):
                    network_analysis['c2_communications'].append({
                        'type': 'HTTP C2',
                        'url': string,
                        'confidence': 0.8,
                        'threat_level': 'High'
                    })
                    
                # IP addresses
                elif re.match(r'^\d+\.\d+\.\d+\.\d+$', string):
                    network_analysis['suspicious_connections'].append({
                        'type': 'Suspicious IP',
                        'ip': string,
                        'confidence': 0.6,
                        'geolocation': 'Unknown'
                    })
                    
                # Email addresses (for data exfiltration)
                elif '@' in string and '.' in string:
                    network_analysis['data_exfiltration_risk'] = 'High'
                    
        except Exception as e:
            rprint(f"[red]Error in network analysis simulation: {e}[/red]")
            
        return network_analysis

    def simulate_geolocation_analysis(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate geolocation intelligence"""
        geolocation = {
            'source_countries': {},
            'infrastructure_analysis': {},
            'hacker_locations': []
        }
        
        try:
            # Simulate geolocation based on attribution
            attribution = analysis_results.get('attribution', {})
            primary_suspects = attribution.get('primary_suspects', [])
            
            for actor in primary_suspects:
                if actor in self.apt_groups:
                    country = self.apt_groups[actor]['country']
                    geolocation['source_countries'][country] = geolocation['source_countries'].get(country, 0) + 1
                    
            # Simulate infrastructure analysis
            network_analysis = analysis_results.get('network_analysis', {})
            c2_communications = network_analysis.get('c2_communications', [])
            
            if c2_communications:
                geolocation['infrastructure_analysis'] = {
                    'hosting_countries': ['Russia', 'China', 'Netherlands'],
                    'bulletproof_hosting': True,
                    'fast_flux_detected': False
                }
                
                # Simulate hacker location tracking
                for country in geolocation['source_countries']:
                    geolocation['hacker_locations'].append({
                        'country': country,
                        'confidence': 0.7,
                        'evidence': 'Attribution analysis',
                        'risk_level': 'High' if country in ['Russia', 'China', 'North Korea'] else 'Medium'
                    })
                    
        except Exception as e:
            rprint(f"[red]Error in geolocation analysis: {e}[/red]")
            
        return geolocation

    def display_results_table(self, results: Dict[str, Any]):
        """Display comprehensive results"""
        console.print("\n" + "="*100)
        console.print("[bold cyan]🛡️ RYHA ULTRA ADVANCED ANALYSIS RESULTS 🛡️[/bold cyan]")
        console.print("="*100)
        
        # File Analysis Summary
        file_info = results.get('file_info', {})
        hashes = results.get('hashes', {})
        
        summary_table = Table(title="📊 File Analysis Summary", show_header=True, header_style="bold magenta")
        summary_table.add_column("Metric", style="cyan")
        summary_table.add_column("Value", style="green")
        summary_table.add_column("Assessment", style="yellow")
        
        summary_table.add_row("File Size", f"{hashes.get('file_size', 0)} bytes", "Normal")
        summary_table.add_row("File Type", file_info.get('file_type', 'Unknown'), "PE Executable")
        summary_table.add_row("Entropy", f"{file_info.get('entropy', 0.0):.2f}", 
                             "High" if file_info.get('entropy', 0.0) > 6.0 else "Normal")
        summary_table.add_row("MD5", hashes.get('md5', 'N/A')[:16] + "...", "Unique")
        summary_table.add_row("SHA256", hashes.get('sha256', 'N/A')[:16] + "...", "Unique")
        
        console.print(summary_table)
        console.print()
        
        # Threat Attribution
        attribution = results.get('attribution', {})
        if attribution.get('primary_suspects'):
            attr_table = Table(title="🎯 Threat Actor Attribution", show_header=True, header_style="bold red")
            attr_table.add_column("Threat Actor", style="cyan")
            attr_table.add_column("Country", style="green")
            attr_table.add_column("Confidence", style="yellow")
            attr_table.add_column("Motivation", style="magenta")
            attr_table.add_column("Evidence Count", style="white")
            
            confidence_scores = attribution.get('confidence_scores', {})
            attribution_evidence = attribution.get('attribution_evidence', {})
            
            for actor in attribution['primary_suspects']:
                confidence = confidence_scores.get(actor, 0.0)
                evidence_count = len(attribution_evidence.get(actor, []))
                actor_info = self.apt_groups.get(actor, {})
                
                attr_table.add_row(
                    actor,
                    actor_info.get('country', 'Unknown'),
                    f"{confidence:.2f}",
                    actor_info.get('motivation', 'Unknown'),
                    str(evidence_count)
                )
                
            console.print(attr_table)
            console.print()
        
        # Network Analysis
        network_analysis = results.get('network_analysis', {})
        if network_analysis.get('c2_communications') or network_analysis.get('suspicious_connections'):
            network_table = Table(title="🌐 Network Intelligence", show_header=True, header_style="bold blue")
            network_table.add_column("Type", style="cyan")
            network_table.add_column("Indicator", style="yellow")
            network_table.add_column("Threat Level", style="red")
            network_table.add_column("Confidence", style="green")
            
            for c2 in network_analysis.get('c2_communications', []):
                network_table.add_row(
                    c2.get('type', 'C2'),
                    c2.get('url', 'Unknown')[:50] + "...",
                    c2.get('threat_level', 'High'),
                    f"{c2.get('confidence', 0.0):.2f}"
                )
                
            for conn in network_analysis.get('suspicious_connections', []):
                network_table.add_row(
                    conn.get('type', 'Connection'),
                    conn.get('ip', 'Unknown'),
                    'Medium',
                    f"{conn.get('confidence', 0.0):.2f}"
                )
                
            console.print(network_table)
            console.print()
        
        # Geolocation Intelligence
        geolocation = results.get('geolocation_intel', {})
        hacker_locations = geolocation.get('hacker_locations', [])
        
        if hacker_locations:
            geo_table = Table(title="🗺️ Hacker Geolocation Intelligence", show_header=True, header_style="bold magenta")
            geo_table.add_column("Country", style="cyan")
            geo_table.add_column("Confidence", style="yellow")
            geo_table.add_column("Risk Level", style="red")
            geo_table.add_column("Evidence", style="green")
            
            for location in hacker_locations:
                geo_table.add_row(
                    location.get('country', 'Unknown'),
                    f"{location.get('confidence', 0.0):.2f}",
                    location.get('risk_level', 'Unknown'),
                    location.get('evidence', 'Unknown')
                )
                
            console.print(geo_table)
            console.print()
        
        # YARA Detections
        yara_matches = results.get('yara_matches', [])
        if yara_matches:
            yara_table = Table(title="🔍 Behavioral Analysis (YARA)", show_header=True, header_style="bold yellow")
            yara_table.add_column("Rule", style="cyan")
            yara_table.add_column("Description", style="green")
            yara_table.add_column("Confidence", style="yellow")
            
            for match in yara_matches:
                yara_table.add_row(
                    match.get('rule', 'Unknown'),
                    match.get('meta', {}).get('description', 'No description'),
                    f"{match.get('confidence', 0.0):.2f}"
                )
                
            console.print(yara_table)
            console.print()

    def generate_comprehensive_report(self, analysis_results: Dict[str, Any], output_file: str):
        """Generate comprehensive JSON report"""
        try:
            timestamp = datetime.now().isoformat()
            
            # Generate executive summary
            exec_summary = self.generate_executive_summary(analysis_results)
            
            report = {
                "analysis_metadata": {
                    "timestamp": timestamp,
                    "analyzer": "RYHA Ultra Advanced Analyzer v3.0 (Demo)",
                    "analysis_type": "Comprehensive Threat Intelligence"
                },
                "executive_summary": exec_summary,
                "detailed_analysis": analysis_results,
                "threat_assessment": self.generate_threat_assessment(analysis_results),
                "mitigation_recommendations": self.generate_recommendations(analysis_results),
                "iocs": self.extract_iocs(analysis_results)
            }
            
            with open(output_file, 'w') as f:
                json.dump(report, f, indent=2, default=str)
                
            rprint(f"[green]✅ Comprehensive report saved to: {output_file}[/green]")
            
        except Exception as e:
            rprint(f"[red]Error generating report: {e}[/red]")

    def generate_executive_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate executive summary"""
        yara_matches = len(results.get('yara_matches', []))
        attribution = results.get('attribution', {})
        threat_intel = results.get('threat_intel', {})
        
        threat_level = "Low"
        confidence = 0.3
        
        if yara_matches > 2:
            threat_level = "High"
            confidence = 0.8
        elif yara_matches > 0:
            threat_level = "Medium" 
            confidence = 0.6
            
        if attribution.get('primary_suspects'):
            confidence = max(confidence, 0.7)
            threat_level = "High"
            
        return {
            "threat_level": threat_level,
            "confidence": confidence,
            "key_findings": [
                f"{yara_matches} behavioral patterns detected",
                f"{len(attribution.get('primary_suspects', []))} threat actors identified",
                f"Reputation score: {threat_intel.get('reputation_score', 0)}"
            ],
            "recommendation": "Immediate investigation required" if threat_level == "High" else "Monitor closely"
        }

    def generate_threat_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate threat assessment"""
        return {
            "malware_family": "Unknown APT Tool",
            "attack_vectors": ["Process Injection", "Registry Persistence"],
            "capabilities": ["Network Communication", "Data Exfiltration"],
            "persistence_methods": ["Registry Run Keys"],
            "data_exfiltration_risk": results.get('network_analysis', {}).get('data_exfiltration_risk', 'Low')
        }

    def generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate mitigation recommendations"""
        recommendations = [
            "Quarantine the affected system immediately",
            "Block network communications to identified C2 servers",
            "Monitor for lateral movement attempts",
            "Update endpoint detection rules",
            "Conduct forensic imaging of affected systems",
            "Review and strengthen access controls",
            "Implement network segmentation",
            "Update threat intelligence feeds"
        ]
        return recommendations

    def extract_iocs(self, results: Dict[str, Any]) -> Dict[str, List[str]]:
        """Extract Indicators of Compromise"""
        iocs = {
            "file_hashes": [],
            "network_indicators": [],
            "registry_keys": [],
            "file_paths": []
        }
        
        # File hashes
        hashes = results.get('hashes', {})
        for hash_type, hash_value in hashes.items():
            if hash_type in ['md5', 'sha1', 'sha256']:
                iocs["file_hashes"].append(f"{hash_type.upper()}: {hash_value}")
                
        # Network indicators
        network_analysis = results.get('network_analysis', {})
        for c2 in network_analysis.get('c2_communications', []):
            iocs["network_indicators"].append(c2.get('url', ''))
            
        for conn in network_analysis.get('suspicious_connections', []):
            iocs["network_indicators"].append(conn.get('ip', ''))
            
        # Extract from strings
        strings = results.get('strings', [])
        for string in strings:
            if 'SOFTWARE\\Microsoft\\Windows' in string:
                iocs["registry_keys"].append(string)
            elif string.startswith(('C:\\', 'D:\\', '\\\\')):
                iocs["file_paths"].append(string)
                
        return iocs

def main():
    """Main function for ultra advanced analyzer demo"""
    console = Console()
    
    # Display banner
    banner = """
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║                🛡️  RYHA ULTRA ADVANCED ANALYZER (DEMO) 🛡️                   ║
    ║                                                                              ║
    ║    🔥 Advanced Threat Intelligence & Attribution Analysis                    ║
    ║    🌍 Geolocation Tracking & Hacker Attribution                            ║
    ║    🎯 APT Group Detection & Campaign Analysis                               ║
    ║    🔍 Comprehensive IOC Extraction & Behavioral Analysis                   ║
    ║    📊 Network Intelligence & C2 Detection                                  ║
    ║    🕵️ End-level Forensic Analysis & Evidence Collection                     ║
    ║                                                                              ║
    ║                          🚀 DEMO VERSION 🚀                                 ║
    ╚══════════════════════════════════════════════════════════════════════════════╝
    """
    
    console.print(Panel(banner, style="bold green"))
    
    if len(sys.argv) < 2:
        console.print("[red]Usage: python ultra_advanced_analyzer_demo.py <file_path>[/red]")
        sys.exit(1)
    
    file_path = sys.argv[1]
    
    if not os.path.exists(file_path):
        console.print(f"[red]File not found: {file_path}[/red]")
        sys.exit(1)
    
    # Initialize analyzer
    analyzer = UltraAdvancedAnalyzerDemo()
    
    # Run comprehensive analysis
    console.print("[bold cyan]🚀 Starting ultra advanced analysis...[/bold cyan]")
    
    with console.status("[bold green]Performing comprehensive analysis...") as status:
        results = analyzer.analyze_file_advanced(file_path)
    
    # Display results
    analyzer.display_results_table(results)
    
    # Generate comprehensive report
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"ultra_advanced_analysis_{timestamp}.json"
    
    console.print(f"\n[bold cyan]📋 Generating comprehensive report...[/bold cyan]")
    analyzer.generate_comprehensive_report(results, output_file)
    
    # Final summary
    console.print(f"\n[bold green]✅ Ultra Advanced Analysis Completed![/bold green]")
    console.print(f"[green]📋 Report saved to: {output_file}[/green]")
    console.print(f"[cyan]🎯 Threat Level: {results.get('executive_summary', {}).get('threat_level', 'Unknown')}[/cyan]")
    
    # Display key findings
    console.print("\n[bold yellow]🔔 KEY FINDINGS:[/bold yellow]")
    attribution = results.get('attribution', {})
    if attribution.get('primary_suspects'):
        console.print(f"• [red]Primary Threat Actor: {attribution['primary_suspects'][0]}[/red]")
        final_assessment = attribution.get('final_assessment', {})
        console.print(f"• [yellow]Country of Origin: {final_assessment.get('country', 'Unknown')}[/yellow]")
        console.print(f"• [cyan]Motivation: {final_assessment.get('motivation', 'Unknown')}[/cyan]")
    
    yara_matches = len(results.get('yara_matches', []))
    console.print(f"• [green]Behavioral Patterns Detected: {yara_matches}[/green]")
    
    network_analysis = results.get('network_analysis', {})
    c2_count = len(network_analysis.get('c2_communications', []))
    if c2_count > 0:
        console.print(f"• [red]C2 Communications Found: {c2_count}[/red]")
    
    console.print("\n[bold red]⚠️  IMMEDIATE ACTIONS REQUIRED:[/bold red]")
    console.print("• Quarantine affected systems")
    console.print("• Block identified network indicators") 
    console.print("• Notify incident response team")
    console.print("• Initiate threat hunting procedures")

if __name__ == "__main__":
    main()
