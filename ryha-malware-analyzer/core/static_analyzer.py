# static_analyzer.py
"""Static analysis: YARA, strings, hash, file type, PE analysis"""

import subprocess
import hashlib
import os
import re
import pefile
try:
    import magic
except ImportError:
    magic = None

def yara_scan(file_path, rules_path=None):
    """Scan file with YARA rules"""
    try:
        if not rules_path or not os.path.exists(rules_path):
            # Create basic YARA rule if none exists
            return "No YARA rules found - using basic detection"
        
        result = subprocess.run([
            "yara", rules_path, file_path
        ], capture_output=True, text=True, timeout=30)
        return result.stdout.strip() if result.stdout.strip() else "No YARA matches"
    except subprocess.TimeoutExpired:
        return "YARA scan timeout"
    except FileNotFoundError:
        return "YARA not installed - install with: pip install yara-python"
    except Exception as e:
        return f"YARA error: {e}"

def extract_strings(file_path, min_length=4):
    """Extract printable strings from file"""
    try:
        strings = []
        with open(file_path, 'rb') as f:
            data = f.read()
            # Extract ASCII strings
            ascii_strings = re.findall(b'[ -~]{' + str(min_length).encode() + b',}', data)
            strings.extend([s.decode('ascii', errors='ignore') for s in ascii_strings])
            
            # Extract Unicode strings
            unicode_strings = re.findall(b'(?:[ -~]\x00){' + str(min_length).encode() + b',}', data)
            strings.extend([s.decode('utf-16le', errors='ignore') for s in unicode_strings])
        
        return list(set(strings))[:100]  # Limit to first 100 unique strings
    except Exception as e:
        return [f"Strings extraction error: {e}"]

def get_hashes(file_path):
    """Calculate MD5, SHA1, SHA256 hashes"""
    hashes = {}
    try:
        with open(file_path, "rb") as f:
            data = f.read()
            hashes["md5"] = hashlib.md5(data).hexdigest()
            hashes["sha1"] = hashlib.sha1(data).hexdigest()
            hashes["sha256"] = hashlib.sha256(data).hexdigest()
            hashes["size"] = len(data)
    except Exception as e:
        hashes["error"] = str(e)
    return hashes

def detect_file_type(file_path):
    """Detect file type using magic numbers"""
    try:
        if magic:
            return magic.from_file(file_path)
        else:
            # Fallback file type detection
            with open(file_path, 'rb') as f:
                header = f.read(16)
                if header.startswith(b'MZ'):
                    return "PE32 executable"
                elif header.startswith(b'\x7fELF'):
                    return "ELF executable"
                elif header.startswith(b'PK'):
                    return "ZIP archive"
                elif header.startswith(b'%PDF'):
                    return "PDF document"
                else:
                    return "Unknown file type"
    except Exception as e:
        return f"Type detection error: {e}"

def analyze_pe_file(file_path):
    """Analyze PE file structure"""
    try:
        pe = pefile.PE(file_path)
        info = {
            "machine": hex(pe.FILE_HEADER.Machine),
            "timestamp": pe.FILE_HEADER.TimeDateStamp,
            "sections": len(pe.sections),
            "imports": [],
            "exports": [],
            "suspicious_sections": []
        }
        
        # Get imports
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore')
                functions = [imp.name.decode('utf-8', errors='ignore') if imp.name else f"Ordinal_{imp.ordinal}" 
                           for imp in entry.imports[:10]]  # Limit to first 10
                info["imports"].append({"dll": dll_name, "functions": functions})
        
        # Get exports
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols[:10]:  # Limit to first 10
                if exp.name:
                    info["exports"].append(exp.name.decode('utf-8', errors='ignore'))
        
        # Check for suspicious sections
        for section in pe.sections:
            section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')
            entropy = section.get_entropy()
            if entropy > 7.0:  # High entropy might indicate packing/encryption
                info["suspicious_sections"].append({
                    "name": section_name,
                    "entropy": entropy,
                    "virtual_size": section.Misc_VirtualSize,
                    "raw_size": section.SizeOfRawData
                })
        
        pe.close()
        return info
    except Exception as e:
        return {"error": f"PE analysis failed: {e}"}

def run_static_analysis(file_path, yara_rules=None):
    """Run complete static analysis"""
    if not os.path.exists(file_path):
        return {"error": f"File not found: {file_path}"}
    
    results = {
        "file_path": file_path,
        "hashes": get_hashes(file_path),
        "file_type": detect_file_type(file_path),
        "strings": extract_strings(file_path),
        "yara": yara_scan(file_path, yara_rules),
        "pe_analysis": None
    }
    
    # If it's a PE file, do additional analysis
    if "PE32" in results["file_type"] or "executable" in results["file_type"].lower():
        results["pe_analysis"] = analyze_pe_file(file_path)
    
    return results
