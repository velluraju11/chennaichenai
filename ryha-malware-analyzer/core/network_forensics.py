#!/usr/bin/env python3
"""
Advanced Network Forensics and C2 Detection Module
Real-time network traffic analysis and command & control detection
"""

import scapy.all as scapy
import dpkt
import socket
import struct
import re
import json
import hashlib
import base64
from collections import defaultdict, Counter
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
import dns.resolver
import requests
import threading
import queue
import time

class AdvancedNetworkForensics:
    """Advanced network forensics and C2 detection engine"""
    
    def __init__(self):
        self.c2_signatures = self.load_c2_signatures()
        self.dga_patterns = self.load_dga_patterns() 
        self.malicious_ips = set()
        self.suspicious_domains = set()
        self.network_sessions = {}
        self.packet_buffer = queue.Queue(maxsize=10000)
        
    def load_c2_signatures(self) -> Dict[str, Any]:
        """Load command and control communication signatures"""
        return {
            "cobalt_strike": {
                "http_patterns": [
                    r"/jquery-[0-9]\.[0-9]\.[0-9]\.min\.js",
                    r"/ga\.js",
                    r"/fwlink\/\?LinkID=\d+"
                ],
                "user_agents": [
                    "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; MAAU)",
                    "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0; MAAU)"
                ],
                "beacon_intervals": [60, 120, 180, 240, 300],  # Common beacon intervals in seconds
                "jitter_patterns": [0.1, 0.2, 0.3],  # Jitter percentages
                "post_patterns": [
                    r"&session=[a-f0-9]{8}&id=[a-f0-9]{8}",
                    r"data=[a-zA-Z0-9+/]{20,}={0,2}"
                ]
            },
            "metasploit": {
                "http_patterns": [
                    r"/INITM",
                    r"/INITJM", 
                    r"/[A-Z]{4,8}"
                ],
                "user_agents": [
                    "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)",
                    "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.6)"
                ],
                "ssl_patterns": [
                    "ApacheBench/2.3",
                    "libwww-perl"
                ]
            },
            "empire": {
                "http_patterns": [
                    r"/admin/get\.php",
                    r"/news\.php",
                    r"/login/process\.php"
                ],
                "user_agents": [
                    "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko"
                ],
                "profile_patterns": [
                    "session=[a-zA-Z0-9]{32}",
                    "__VIEWSTATE=[a-zA-Z0-9+/]+"
                ]
            },
            "apt_groups": {
                "apt28_x-agent": {
                    "domains": [r".*\.bit$", r".*\.tk$"],
                    "ports": [80, 443, 8080],
                    "protocols": ["HTTP", "HTTPS"]
                },
                "apt29_beacon": {
                    "domains": [r".*\.avsvmcloud\.com", r".*\.freescanonline\.com"],
                    "tls_jarm": ["2ad2ad0002ad2ad0002ad2ad2ad2ad"],
                    "certificate_patterns": ["*.microsoft-analytics.com"]
                }
            }
        }
        
    def load_dga_patterns(self) -> Dict[str, Any]:
        """Load Domain Generation Algorithm patterns"""
        return {
            "conficker": {
                "algorithm": "md5_based",
                "length_range": [8, 12],
                "tlds": [".com", ".net", ".org", ".info", ".biz"],
                "pattern": r"[a-z]{8,12}\.(com|net|org|info|biz)$"
            },
            "torpig": {
                "algorithm": "date_based",
                "length_range": [8, 15],
                "tlds": [".com", ".net"],
                "pattern": r"[a-z]{8,15}\.(com|net)$"
            },
            "kraken": {
                "algorithm": "seed_based", 
                "length_range": [10, 20],
                "tlds": [".com", ".net", ".org"],
                "vowel_ratio": {"min": 0.2, "max": 0.4},
                "consonant_clusters": True
            },
            "necurs": {
                "algorithm": "rsa_based",
                "length_range": [12, 16],
                "tlds": [".bit"],
                "pattern": r"[a-z0-9]{12,16}\.bit$"
            }
        }

    def analyze_network_traffic(self, pcap_file: str = None, interface: str = None) -> Dict[str, Any]:
        """Comprehensive network traffic analysis"""
        analysis_results = {
            "c2_communications": [],
            "dga_domains": [],
            "suspicious_connections": [],
            "data_exfiltration": [],
            "lateral_movement": [],
            "network_reconnaissance": [],
            "dns_analysis": {},
            "tls_analysis": {},
            "timing_analysis": {},
            "statistical_analysis": {}
        }
        
        try:
            if pcap_file:
                packets = scapy.rdpcap(pcap_file)
                analysis_results = self.analyze_packet_capture(packets)
            elif interface:
                # Real-time capture
                analysis_results = self.real_time_analysis(interface)
            else:
                print("[Warning] No packet source specified")
                
        except Exception as e:
            print(f"Error in network traffic analysis: {e}")
            
        return analysis_results

    def analyze_packet_capture(self, packets: List[scapy.Packet]) -> Dict[str, Any]:
        """Analyze captured packets for malicious activity"""
        results = {
            "c2_communications": [],
            "dga_domains": [],
            "suspicious_connections": [],
            "data_exfiltration": [],
            "network_sessions": {},
            "timing_patterns": [],
            "protocol_anomalies": []
        }
        
        connections = defaultdict(list)
        dns_queries = []
        http_requests = []
        tls_connections = []
        
        try:
            for packet in packets:
                timestamp = datetime.fromtimestamp(float(packet.time))
                
                # IP layer analysis
                if packet.haslayer(scapy.IP):
                    src_ip = packet[scapy.IP].src
                    dst_ip = packet[scapy.IP].dst
                    
                    # Track connections
                    connection_key = f"{src_ip}:{dst_ip}"
                    connections[connection_key].append({
                        "timestamp": timestamp,
                        "size": len(packet),
                        "protocol": packet[scapy.IP].proto
                    })
                    
                    # TCP analysis
                    if packet.haslayer(scapy.TCP):
                        tcp_analysis = self.analyze_tcp_packet(packet, timestamp)
                        if tcp_analysis:
                            if tcp_analysis["type"] == "http":
                                http_requests.append(tcp_analysis)
                            elif tcp_analysis["type"] == "suspicious":
                                results["suspicious_connections"].append(tcp_analysis)
                                
                    # UDP analysis  
                    elif packet.haslayer(scapy.UDP):
                        udp_analysis = self.analyze_udp_packet(packet, timestamp)
                        if udp_analysis:
                            results["suspicious_connections"].append(udp_analysis)
                
                # DNS analysis
                if packet.haslayer(scapy.DNS):
                    dns_analysis = self.analyze_dns_packet(packet, timestamp)
                    if dns_analysis:
                        dns_queries.append(dns_analysis)
                        if dns_analysis.get("is_dga"):
                            results["dga_domains"].append(dns_analysis)
                            
            # Analyze connection patterns
            results["c2_communications"] = self.detect_c2_communications(connections, http_requests)
            results["data_exfiltration"] = self.detect_data_exfiltration(connections)
            results["timing_patterns"] = self.analyze_timing_patterns(connections)
            results["network_sessions"] = self.reconstruct_network_sessions(connections)
            
        except Exception as e:
            print(f"Error analyzing packet capture: {e}")
            
        return results

    def analyze_tcp_packet(self, packet: scapy.Packet, timestamp: datetime) -> Optional[Dict[str, Any]]:
        """Analyze TCP packet for suspicious activity"""
        try:
            src_ip = packet[scapy.IP].src
            dst_ip = packet[scapy.IP].dst
            src_port = packet[scapy.TCP].sport
            dst_port = packet[scapy.TCP].dport
            
            analysis = {
                "src_ip": src_ip,
                "dst_ip": dst_ip,
                "src_port": src_port,
                "dst_port": dst_port,
                "timestamp": timestamp,
                "flags": packet[scapy.TCP].flags,
                "size": len(packet)
            }
            
            # HTTP analysis
            if dst_port in [80, 8080, 8000] or src_port in [80, 8080, 8000]:
                if packet.haslayer(scapy.Raw):
                    payload = packet[scapy.Raw].load.decode('utf-8', errors='ignore')
                    http_analysis = self.analyze_http_payload(payload)
                    if http_analysis:
                        analysis.update(http_analysis)
                        analysis["type"] = "http"
                        return analysis
                        
            # HTTPS/TLS analysis
            elif dst_port == 443 or src_port == 443:
                tls_analysis = self.analyze_tls_connection(packet)
                if tls_analysis:
                    analysis.update(tls_analysis)
                    analysis["type"] = "tls"
                    
            # Check for suspicious ports
            elif self.is_suspicious_port(dst_port) or self.is_suspicious_port(src_port):
                analysis["type"] = "suspicious"
                analysis["reason"] = f"Suspicious port usage: {dst_port}"
                return analysis
                
            # Check for port scanning
            if packet[scapy.TCP].flags == 2:  # SYN flag
                analysis["type"] = "scan_attempt"
                return analysis
                
        except Exception as e:
            print(f"Error analyzing TCP packet: {e}")
            
        return None

    def analyze_udp_packet(self, packet: scapy.Packet, timestamp: datetime) -> Optional[Dict[str, Any]]:
        """Analyze UDP packet for suspicious activity"""
        try:
            src_ip = packet[scapy.IP].src
            dst_ip = packet[scapy.IP].dst
            src_port = packet[scapy.UDP].sport
            dst_port = packet[scapy.UDP].dport
            
            # Check for DNS tunneling
            if dst_port == 53 and packet.haslayer(scapy.Raw):
                payload_size = len(packet[scapy.Raw].load)
                if payload_size > 512:  # Unusually large DNS query
                    return {
                        "type": "dns_tunneling",
                        "src_ip": src_ip,
                        "dst_ip": dst_ip,
                        "payload_size": payload_size,
                        "timestamp": timestamp,
                        "reason": "Unusually large DNS query"
                    }
                    
            # Check for suspicious UDP ports
            elif self.is_suspicious_port(dst_port):
                return {
                    "type": "suspicious_udp",
                    "src_ip": src_ip,
                    "dst_ip": dst_ip,
                    "dst_port": dst_port,
                    "timestamp": timestamp,
                    "reason": f"Suspicious UDP port: {dst_port}"
                }
                
        except Exception as e:
            print(f"Error analyzing UDP packet: {e}")
            
        return None

    def analyze_dns_packet(self, packet: scapy.Packet, timestamp: datetime) -> Optional[Dict[str, Any]]:
        """Analyze DNS packet for DGA and malicious domains"""
        try:
            if packet[scapy.DNS].qr == 0:  # Query
                domain = packet[scapy.DNS].qd.qname.decode('utf-8').rstrip('.')
                
                analysis = {
                    "domain": domain,
                    "timestamp": timestamp,
                    "query_type": packet[scapy.DNS].qd.qtype,
                    "src_ip": packet[scapy.IP].src
                }
                
                # Check for DGA domains
                dga_analysis = self.detect_dga_domain(domain)
                if dga_analysis:
                    analysis.update(dga_analysis)
                    analysis["is_dga"] = True
                    
                # Check against known malicious domains
                if domain in self.suspicious_domains:
                    analysis["is_malicious"] = True
                    analysis["threat_level"] = "High"
                    
                # Check for DNS tunneling indicators
                if len(domain) > 50 or domain.count('.') > 5:
                    analysis["possible_tunneling"] = True
                    
                return analysis
                
        except Exception as e:
            print(f"Error analyzing DNS packet: {e}")
            
        return None

    def analyze_http_payload(self, payload: str) -> Optional[Dict[str, Any]]:
        """Analyze HTTP payload for C2 patterns"""
        try:
            analysis = {}
            
            # Extract HTTP headers and body
            if '\r\n\r\n' in payload:
                headers, body = payload.split('\r\n\r\n', 1)
            else:
                headers = payload
                body = ""
                
            # Parse HTTP request line
            lines = headers.split('\r\n')
            if lines:
                request_line = lines[0]
                if ' ' in request_line:
                    method, path, version = request_line.split(' ', 2)
                    analysis["method"] = method
                    analysis["path"] = path
                    analysis["version"] = version
                    
            # Extract headers
            header_dict = {}
            for line in lines[1:]:
                if ':' in line:
                    key, value = line.split(':', 1)
                    header_dict[key.strip().lower()] = value.strip()
                    
            analysis["headers"] = header_dict
            analysis["body"] = body
            
            # Check for C2 patterns
            c2_match = self.match_c2_patterns(analysis)
            if c2_match:
                analysis["c2_family"] = c2_match["family"]
                analysis["confidence"] = c2_match["confidence"]
                analysis["indicators"] = c2_match["indicators"]
                
            return analysis
            
        except Exception as e:
            print(f"Error analyzing HTTP payload: {e}")
            
        return None

    def match_c2_patterns(self, http_analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Match HTTP traffic against known C2 patterns"""
        try:
            path = http_analysis.get("path", "")
            headers = http_analysis.get("headers", {})
            body = http_analysis.get("body", "")
            user_agent = headers.get("user-agent", "")
            
            for family, patterns in self.c2_signatures.items():
                if family == "apt_groups":
                    continue
                    
                confidence = 0
                indicators = []
                
                # Check HTTP path patterns
                for pattern in patterns.get("http_patterns", []):
                    if re.search(pattern, path, re.IGNORECASE):
                        confidence += 0.3
                        indicators.append(f"Path pattern: {pattern}")
                        
                # Check User-Agent patterns
                if user_agent in patterns.get("user_agents", []):
                    confidence += 0.4
                    indicators.append(f"User-Agent: {user_agent}")
                    
                # Check POST patterns
                for pattern in patterns.get("post_patterns", []):
                    if re.search(pattern, body, re.IGNORECASE):
                        confidence += 0.3
                        indicators.append(f"POST pattern: {pattern}")
                        
                if confidence > 0.5:  # Threshold for positive match
                    return {
                        "family": family,
                        "confidence": min(confidence, 1.0),
                        "indicators": indicators
                    }
                    
        except Exception as e:
            print(f"Error matching C2 patterns: {e}")
            
        return None

    def detect_dga_domain(self, domain: str) -> Optional[Dict[str, Any]]:
        """Detect if domain is generated by DGA algorithm"""
        try:
            analysis = {
                "domain": domain,
                "dga_family": None,
                "confidence": 0.0,
                "indicators": []
            }
            
            # Basic length check
            domain_parts = domain.split('.')
            if len(domain_parts) < 2:
                return None
                
            subdomain = domain_parts[0]
            tld = '.' + '.'.join(domain_parts[1:])
            
            # Check against known DGA patterns
            for family, patterns in self.dga_patterns.items():
                confidence = 0
                indicators = []
                
                # Length check
                length_range = patterns.get("length_range", [0, 100])
                if length_range[0] <= len(subdomain) <= length_range[1]:
                    confidence += 0.2
                    indicators.append(f"Length in range: {length_range}")
                    
                # TLD check
                if tld.lower() in patterns.get("tlds", []):
                    confidence += 0.3
                    indicators.append(f"Suspicious TLD: {tld}")
                    
                # Pattern matching
                pattern = patterns.get("pattern", "")
                if pattern and re.match(pattern, domain.lower()):
                    confidence += 0.4
                    indicators.append(f"Pattern match: {pattern}")
                    
                # Vowel/consonant ratio analysis
                if "vowel_ratio" in patterns:
                    vowel_ratio = self.calculate_vowel_ratio(subdomain)
                    expected_range = patterns["vowel_ratio"]
                    if not (expected_range["min"] <= vowel_ratio <= expected_range["max"]):
                        confidence += 0.2
                        indicators.append(f"Unusual vowel ratio: {vowel_ratio:.2f}")
                        
                if confidence > 0.6:  # Threshold for DGA detection
                    analysis["dga_family"] = family
                    analysis["confidence"] = min(confidence, 1.0)
                    analysis["indicators"] = indicators
                    return analysis
                    
            # Generic DGA detection based on entropy and randomness
            entropy = self.calculate_entropy(subdomain.encode())
            if entropy > 3.5:  # High entropy suggests randomness
                char_freq = self.analyze_character_frequency(subdomain)
                if char_freq["randomness_score"] > 0.7:
                    analysis["dga_family"] = "unknown"
                    analysis["confidence"] = 0.7
                    analysis["indicators"] = [
                        f"High entropy: {entropy:.2f}",
                        f"High randomness: {char_freq['randomness_score']:.2f}"
                    ]
                    return analysis
                    
        except Exception as e:
            print(f"Error detecting DGA domain: {e}")
            
        return None

    def calculate_vowel_ratio(self, text: str) -> float:
        """Calculate vowel to consonant ratio"""
        vowels = "aeiou"
        vowel_count = sum(1 for c in text.lower() if c in vowels)
        total_letters = sum(1 for c in text if c.isalpha())
        
        if total_letters == 0:
            return 0.0
        return vowel_count / total_letters

    def calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0.0
            
        frequency = {}
        for byte in data:
            frequency[byte] = frequency.get(byte, 0) + 1
            
        entropy = 0.0
        data_len = len(data)
        for count in frequency.values():
            if count > 0:
                probability = count / data_len
                entropy -= probability * (probability.bit_length() - 1)
                
        return entropy

    def analyze_character_frequency(self, text: str) -> Dict[str, float]:
        """Analyze character frequency for randomness detection"""
        if not text:
            return {"randomness_score": 0.0}
            
        # Count character frequencies
        char_freq = Counter(text.lower())
        total_chars = len(text)
        
        # Calculate frequency distribution
        frequencies = [count / total_chars for count in char_freq.values()]
        
        # Calculate standard deviation of frequencies
        mean_freq = sum(frequencies) / len(frequencies)
        variance = sum((f - mean_freq) ** 2 for f in frequencies) / len(frequencies)
        std_dev = variance ** 0.5
        
        # Random text has more uniform distribution (lower std dev)
        # But we want to detect algorithmic generation, which often has patterns
        randomness_score = 1.0 - min(std_dev * 10, 1.0)  # Normalize to 0-1
        
        return {
            "randomness_score": randomness_score,
            "char_count": len(char_freq),
            "std_deviation": std_dev
        }

    def detect_c2_communications(self, connections: Dict[str, List], 
                               http_requests: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Detect command and control communications"""
        c2_communications = []
        
        try:
            # Analyze connection patterns for beaconing
            for connection_key, packets in connections.items():
                if len(packets) > 5:  # Minimum packets for pattern analysis
                    beacon_analysis = self.analyze_beacon_pattern(packets)
                    if beacon_analysis["is_beacon"]:
                        c2_communications.append({
                            "type": "beacon",
                            "connection": connection_key,
                            "beacon_interval": beacon_analysis["interval"],
                            "jitter": beacon_analysis["jitter"],
                            "confidence": beacon_analysis["confidence"]
                        })
                        
            # Analyze HTTP requests for C2 patterns
            for request in http_requests:
                if request.get("c2_family"):
                    c2_communications.append({
                        "type": "http_c2",
                        "family": request["c2_family"],
                        "confidence": request["confidence"],
                        "indicators": request["indicators"],
                        "src_ip": request["src_ip"],
                        "dst_ip": request["dst_ip"]
                    })
                    
        except Exception as e:
            print(f"Error detecting C2 communications: {e}")
            
        return c2_communications

    def analyze_beacon_pattern(self, packets: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze packets for beacon-like communication patterns"""
        analysis = {
            "is_beacon": False,
            "interval": 0,
            "jitter": 0.0,
            "confidence": 0.0
        }
        
        try:
            if len(packets) < 5:
                return analysis
                
            # Calculate time intervals between packets
            timestamps = [p["timestamp"] for p in packets]
            timestamps.sort()
            
            intervals = []
            for i in range(1, len(timestamps)):
                interval = (timestamps[i] - timestamps[i-1]).total_seconds()
                intervals.append(interval)
                
            if not intervals:
                return analysis
                
            # Calculate statistics
            mean_interval = sum(intervals) / len(intervals)
            
            # Calculate jitter (variance in timing)
            variance = sum((interval - mean_interval) ** 2 for interval in intervals) / len(intervals)
            std_dev = variance ** 0.5
            jitter = std_dev / mean_interval if mean_interval > 0 else 0
            
            # Beacon detection heuristics
            confidence = 0
            
            # Regular intervals suggest beaconing
            if std_dev < mean_interval * 0.3:  # Low variance
                confidence += 0.4
                
            # Check against known beacon intervals
            for family, patterns in self.c2_signatures.items():
                if family == "apt_groups":
                    continue
                beacon_intervals = patterns.get("beacon_intervals", [])
                for known_interval in beacon_intervals:
                    if abs(mean_interval - known_interval) < 30:  # Within 30 seconds
                        confidence += 0.3
                        break
                        
            # Long-duration connections suggest persistence
            total_duration = (timestamps[-1] - timestamps[0]).total_seconds()
            if total_duration > 300:  # More than 5 minutes
                confidence += 0.2
                
            # Check packet sizes for consistency
            sizes = [p["size"] for p in packets]
            size_variance = sum((size - sum(sizes)/len(sizes)) ** 2 for size in sizes) / len(sizes)
            if size_variance < 100:  # Consistent packet sizes
                confidence += 0.1
                
            analysis["is_beacon"] = confidence > 0.5
            analysis["interval"] = mean_interval
            analysis["jitter"] = jitter
            analysis["confidence"] = min(confidence, 1.0)
            
        except Exception as e:
            print(f"Error analyzing beacon pattern: {e}")
            
        return analysis

    def detect_data_exfiltration(self, connections: Dict[str, List]) -> List[Dict[str, Any]]:
        """Detect potential data exfiltration based on traffic patterns"""
        exfiltration_indicators = []
        
        try:
            for connection_key, packets in connections.items():
                src_ip, dst_ip = connection_key.split(':')
                
                # Calculate data volumes
                total_sent = sum(p["size"] for p in packets if p.get("direction") == "outbound")
                total_received = sum(p["size"] for p in packets if p.get("direction") == "inbound")
                
                # Large outbound transfers are suspicious
                if total_sent > 1024 * 1024:  # More than 1MB sent
                    ratio = total_sent / max(total_received, 1)
                    if ratio > 10:  # Much more data sent than received
                        exfiltration_indicators.append({
                            "type": "large_upload",
                            "src_ip": src_ip,
                            "dst_ip": dst_ip,
                            "bytes_sent": total_sent,
                            "bytes_received": total_received,
                            "ratio": ratio,
                            "confidence": min(ratio / 50, 1.0)
                        })
                        
                # Check for unusual upload patterns
                if len(packets) > 10:
                    upload_pattern = self.analyze_upload_pattern(packets)
                    if upload_pattern["suspicious"]:
                        exfiltration_indicators.append({
                            "type": "suspicious_upload_pattern",
                            "src_ip": src_ip,
                            "dst_ip": dst_ip,
                            "pattern": upload_pattern,
                            "confidence": upload_pattern["confidence"]
                        })
                        
        except Exception as e:
            print(f"Error detecting data exfiltration: {e}")
            
        return exfiltration_indicators

    def analyze_upload_pattern(self, packets: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze upload patterns for suspicious characteristics"""
        pattern = {
            "suspicious": False,
            "confidence": 0.0,
            "indicators": []
        }
        
        try:
            # Sort packets by timestamp
            sorted_packets = sorted(packets, key=lambda x: x["timestamp"])
            
            # Check for burst uploads
            burst_threshold = 10  # packets
            time_window = 60  # seconds
            
            for i in range(len(sorted_packets) - burst_threshold):
                window_start = sorted_packets[i]["timestamp"]
                window_end = sorted_packets[i + burst_threshold]["timestamp"]
                
                if (window_end - window_start).total_seconds() < time_window:
                    pattern["suspicious"] = True
                    pattern["confidence"] += 0.3
                    pattern["indicators"].append("Burst upload detected")
                    break
                    
            # Check for regular upload intervals (automated exfiltration)
            if len(sorted_packets) > 20:
                intervals = []
                for i in range(1, len(sorted_packets)):
                    interval = (sorted_packets[i]["timestamp"] - sorted_packets[i-1]["timestamp"]).total_seconds()
                    intervals.append(interval)
                    
                mean_interval = sum(intervals) / len(intervals)
                variance = sum((interval - mean_interval) ** 2 for interval in intervals) / len(intervals)
                std_dev = variance ** 0.5
                
                if std_dev < mean_interval * 0.2:  # Very regular intervals
                    pattern["suspicious"] = True
                    pattern["confidence"] += 0.4
                    pattern["indicators"].append("Regular upload intervals")
                    
        except Exception as e:
            print(f"Error analyzing upload pattern: {e}")
            
        return pattern

    def analyze_timing_patterns(self, connections: Dict[str, List]) -> List[Dict[str, Any]]:
        """Analyze timing patterns for suspicious behavior"""
        timing_patterns = []
        
        try:
            for connection_key, packets in connections.items():
                if len(packets) > 10:
                    # Analyze for off-hours activity
                    off_hours_analysis = self.analyze_off_hours_activity(packets)
                    if off_hours_analysis["suspicious"]:
                        timing_patterns.append({
                            "type": "off_hours_activity",
                            "connection": connection_key,
                            "analysis": off_hours_analysis
                        })
                        
                    # Analyze for timezone patterns
                    timezone_analysis = self.analyze_timezone_patterns(packets)
                    if timezone_analysis["confidence"] > 0.5:
                        timing_patterns.append({
                            "type": "timezone_pattern",
                            "connection": connection_key,
                            "analysis": timezone_analysis
                        })
                        
        except Exception as e:
            print(f"Error analyzing timing patterns: {e}")
            
        return timing_patterns

    def analyze_off_hours_activity(self, packets: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze for suspicious off-hours network activity"""
        analysis = {
            "suspicious": False,
            "off_hours_ratio": 0.0,
            "confidence": 0.0
        }
        
        try:
            off_hours_count = 0
            total_packets = len(packets)
            
            for packet in packets:
                timestamp = packet["timestamp"]
                hour = timestamp.hour
                
                # Define off-hours (outside 8 AM - 6 PM)
                if hour < 8 or hour > 18:
                    off_hours_count += 1
                    
            off_hours_ratio = off_hours_count / total_packets
            analysis["off_hours_ratio"] = off_hours_ratio
            
            if off_hours_ratio > 0.7:  # More than 70% off-hours
                analysis["suspicious"] = True
                analysis["confidence"] = min(off_hours_ratio, 1.0)
                
        except Exception as e:
            print(f"Error analyzing off-hours activity: {e}")
            
        return analysis

    def analyze_timezone_patterns(self, packets: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze timezone patterns to identify potential source location"""
        analysis = {
            "likely_timezone": None,
            "confidence": 0.0,
            "working_hours_pattern": {}
        }
        
        try:
            # Count activity by hour
            hour_counts = defaultdict(int)
            for packet in packets:
                hour = packet["timestamp"].hour
                hour_counts[hour] += 1
                
            # Find peak activity hours
            max_count = max(hour_counts.values()) if hour_counts else 0
            peak_hours = [hour for hour, count in hour_counts.items() 
                         if count > max_count * 0.8]
            
            # Try to match against common working hours in different timezones
            timezone_patterns = {
                "UTC+8": list(range(9, 18)),    # Asia/Shanghai (China)
                "UTC+3": list(range(9, 18)),    # Europe/Moscow (Russia)
                "UTC+9": list(range(9, 18)),    # Asia/Seoul (North Korea)
                "UTC-5": list(range(9, 18)),    # America/New_York (USA East)
                "UTC-8": list(range(9, 18)),    # America/Los_Angeles (USA West)
            }
            
            best_match = None
            best_overlap = 0
            
            for timezone, work_hours in timezone_patterns.items():
                overlap = len(set(peak_hours) & set(work_hours))
                if overlap > best_overlap:
                    best_overlap = overlap
                    best_match = timezone
                    
            if best_match and best_overlap >= 3:  # At least 3 hours overlap
                analysis["likely_timezone"] = best_match
                analysis["confidence"] = min(best_overlap / len(peak_hours), 1.0)
                analysis["working_hours_pattern"] = dict(hour_counts)
                
        except Exception as e:
            print(f"Error analyzing timezone patterns: {e}")
            
        return analysis

    def reconstruct_network_sessions(self, connections: Dict[str, List]) -> Dict[str, Any]:
        """Reconstruct network sessions from packet data"""
        sessions = {}
        
        try:
            for connection_key, packets in connections.items():
                src_ip, dst_ip = connection_key.split(':')
                
                # Sort packets by timestamp
                sorted_packets = sorted(packets, key=lambda x: x["timestamp"])
                
                if not sorted_packets:
                    continue
                    
                session = {
                    "src_ip": src_ip,
                    "dst_ip": dst_ip,
                    "start_time": sorted_packets[0]["timestamp"],
                    "end_time": sorted_packets[-1]["timestamp"],
                    "duration": (sorted_packets[-1]["timestamp"] - sorted_packets[0]["timestamp"]).total_seconds(),
                    "packet_count": len(packets),
                    "total_bytes": sum(p["size"] for p in packets),
                    "protocols": list(set(p["protocol"] for p in packets)),
                    "session_pattern": self.classify_session_pattern(packets)
                }
                
                sessions[connection_key] = session
                
        except Exception as e:
            print(f"Error reconstructing network sessions: {e}")
            
        return sessions

    def classify_session_pattern(self, packets: List[Dict[str, Any]]) -> str:
        """Classify the type of network session based on packet patterns"""
        try:
            if len(packets) < 3:
                return "short_session"
                
            # Analyze packet timing
            sorted_packets = sorted(packets, key=lambda x: x["timestamp"])
            intervals = []
            
            for i in range(1, len(sorted_packets)):
                interval = (sorted_packets[i]["timestamp"] - sorted_packets[i-1]["timestamp"]).total_seconds()
                intervals.append(interval)
                
            if not intervals:
                return "unknown"
                
            mean_interval = sum(intervals) / len(intervals)
            variance = sum((interval - mean_interval) ** 2 for interval in intervals) / len(intervals)
            std_dev = variance ** 0.5
            
            # Classification logic
            if std_dev < mean_interval * 0.2 and mean_interval > 30:
                return "beacon"
            elif std_dev < mean_interval * 0.1:
                return "automated"
            elif mean_interval < 1.0:
                return "interactive"
            elif sum(p["size"] for p in packets) > 1024 * 1024:
                return "bulk_transfer"
            else:
                return "normal"
                
        except Exception as e:
            print(f"Error classifying session pattern: {e}")
            return "unknown"

    def is_suspicious_port(self, port: int) -> bool:
        """Check if port is commonly used by malware"""
        # Common malware ports
        suspicious_ports = {
            1433, 1434,  # SQL Server (often targeted)
            3389,        # RDP (lateral movement)
            4444,        # Common backdoor port
            5555,        # Common backdoor port
            6666,        # Common backdoor port
            7777,        # Common backdoor port
            8080,        # Alternative HTTP (often used by malware)
            9999,        # Common backdoor port
            31337,       # Elite/leet port (hackers)
            12345,       # NetBus trojan
            54321,       # Back Orifice trojan
            65506        # PhatBot worm
        }
        
        # High ports that might be suspicious
        if port > 49152:  # Dynamic/private port range
            return True
            
        return port in suspicious_ports

    def analyze_tls_connection(self, packet: scapy.Packet) -> Optional[Dict[str, Any]]:
        """Analyze TLS connection for suspicious characteristics"""
        try:
            if packet.haslayer(scapy.Raw):
                payload = packet[scapy.Raw].load
                
                # Basic TLS analysis
                analysis = {
                    "payload_size": len(payload),
                    "potential_issues": []
                }
                
                # Check for unusual payload sizes
                if len(payload) > 16384:  # Larger than typical TLS record
                    analysis["potential_issues"].append("Unusually large TLS payload")
                    
                # Check for non-standard TLS patterns
                if payload[:3] not in [b'\x16\x03\x01', b'\x16\x03\x02', b'\x16\x03\x03']:
                    analysis["potential_issues"].append("Non-standard TLS version")
                    
                return analysis if analysis["potential_issues"] else None
                
        except Exception as e:
            print(f"Error analyzing TLS connection: {e}")
            
        return None

    def real_time_analysis(self, interface: str) -> Dict[str, Any]:
        """Perform real-time network analysis"""
        print(f"[Info] Starting real-time analysis on interface: {interface}")
        
        # This would implement real-time packet capture and analysis
        # Placeholder for real-time functionality
        return {
            "message": "Real-time analysis would be implemented here",
            "interface": interface,
            "status": "monitoring"
        }
