# unpacker.py
"""Unpacking: UPX, binwalk, entropy analysis"""

import subprocess
import os
import math
from collections import Counter

def check_upx_packing(file_path):
    """Check if file is UPX packed"""
    try:
        # Check for UPX signature
        with open(file_path, 'rb') as f:
            data = f.read(1024)  # Read first 1KB
            if b'UPX' in data:
                return {"packed": True, "packer": "UPX", "confidence": "High"}
        
        # Try UPX detection command if available
        try:
            result = subprocess.run(['upx', '-t', file_path], 
                                  capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                return {"packed": True, "packer": "UPX", "confidence": "Confirmed"}
        except (FileNotFoundError, subprocess.TimeoutExpired):
            pass
        
        return {"packed": False, "packer": None}
    except Exception as e:
        return {"error": f"UPX check failed: {e}"}

def calculate_entropy(data):
    """Calculate Shannon entropy of data"""
    if not data:
        return 0
    
    # Count frequency of each byte
    counter = Counter(data)
    length = len(data)
    
    # Calculate entropy
    entropy = 0
    for count in counter.values():
        p = count / length
        entropy -= p * math.log2(p)
    
    return entropy

def analyze_sections_entropy(file_path):
    """Analyze entropy of file sections (basic)"""
    try:
        with open(file_path, 'rb') as f:
            data = f.read()
        
        # Analyze file in chunks
        chunk_size = min(1024, len(data) // 10) if len(data) > 1024 else len(data)
        entropies = []
        
        for i in range(0, len(data), chunk_size):
            chunk = data[i:i+chunk_size]
            entropy = calculate_entropy(chunk)
            entropies.append(entropy)
        
        avg_entropy = sum(entropies) / len(entropies) if entropies else 0
        max_entropy = max(entropies) if entropies else 0
        
        # High entropy might indicate packing/encryption
        is_suspicious = avg_entropy > 7.5 or max_entropy > 7.8
        
        return {
            "average_entropy": round(avg_entropy, 2),
            "max_entropy": round(max_entropy, 2),
            "suspicious": is_suspicious,
            "analysis": "High entropy detected - possible packing/encryption" if is_suspicious else "Normal entropy"
        }
    except Exception as e:
        return {"error": f"Entropy analysis failed: {e}"}

def run_binwalk_analysis(file_path):
    """Run binwalk to detect embedded files"""
    try:
        result = subprocess.run(['binwalk', '-e', file_path], 
                              capture_output=True, text=True, timeout=60)
        
        if result.returncode == 0:
            lines = result.stdout.strip().split('\n')
            findings = []
            for line in lines:
                if line.strip() and not line.startswith('DECIMAL'):
                    findings.append(line.strip())
            
            return {
                "embedded_files": len(findings),
                "findings": findings[:10],  # Limit to first 10
                "extracted": "Files extracted" if findings else "No embedded files"
            }
        else:
            return {"error": "Binwalk execution failed"}
    except FileNotFoundError:
        return {"error": "Binwalk not installed"}
    except subprocess.TimeoutExpired:
        return {"error": "Binwalk timeout"}
    except Exception as e:
        return {"error": f"Binwalk analysis failed: {e}"}

def detect_file_format(file_path):
    """Detect file format and potential obfuscation"""
    try:
        with open(file_path, 'rb') as f:
            header = f.read(64)
        
        formats = {
            b'MZ': 'PE/DOS executable',
            b'\x7fELF': 'ELF executable',
            b'PK\x03\x04': 'ZIP archive',
            b'PK\x05\x06': 'ZIP archive (empty)',
            b'%PDF': 'PDF document',
            b'\x89PNG': 'PNG image',
            b'\xff\xd8\xff': 'JPEG image',
            b'GIF8': 'GIF image'
        }
        
        detected_format = "Unknown"
        for signature, format_name in formats.items():
            if header.startswith(signature):
                detected_format = format_name
                break
        
        return {
            "format": detected_format,
            "header_hex": header[:16].hex(),
            "suspicious": detected_format == "Unknown" and len(header) > 0
        }
    except Exception as e:
        return {"error": f"Format detection failed: {e}"}

def run_unpacking(file_path):
    """Run complete unpacking analysis"""
    if not os.path.exists(file_path):
        return {"error": f"File not found: {file_path}"}
    
    results = {
        "file_path": file_path,
        "upx_analysis": check_upx_packing(file_path),
        "entropy_analysis": analyze_sections_entropy(file_path),
        "format_analysis": detect_file_format(file_path),
        "binwalk_analysis": run_binwalk_analysis(file_path)
    }
    
    # Overall assessment
    is_packed = (results["upx_analysis"].get("packed", False) or 
                results["entropy_analysis"].get("suspicious", False))
    
    results["assessment"] = {
        "likely_packed": is_packed,
        "confidence": "High" if results["upx_analysis"].get("packed") else "Medium" if is_packed else "Low",
        "recommendation": "Manual unpacking required" if is_packed else "No unpacking needed"
    }
    
    return results
